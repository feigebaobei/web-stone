<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>&#x8bbe;&#x8ba1;&#x6a21;&#x5f0f;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="设计模式">设计模式</h1>
<blockquote>
<p>可以在大范围内使用，也可以在小范围内使用。
在实际开发中，一般多种开发方式混合在一起。
一共沉淀了29种设计模式。</p>
</blockquote>
<ul>
<li>创建型
<ul>
<li>工厂模式</li>
<li>单例模式</li>
<li>原型模式</li>
</ul>
</li>
<li>结构型
<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li>行为型
<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>发布订阅模式</li>
<li>迭代器模式</li>
<li>职责链模式</li>
<li>模块模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介模式</li>
<li>解释器模式</li>
<li>环形模式</li>
<li>回调模式</li>
<li>惰性模式</li>
<li>沙箱模式</li>
<li>链模式</li>
<li>依赖注入模式</li>
<li>金子模式（可扩展插件的模式）（可插件模式）</li>
</ul>
</li>
</ul>
<h2 id="为什么要总结设计模式">为什么要总结设计模式</h2>
<ul>
<li>解决常见问题</li>
<li>有名称便于交流</li>
<li>方便 code review</li>
<li>方便理解现有代码</li>
</ul>
<h2 id="设计模式的六大原则"><a href="/engineered/design-principle.html">设计模式的六大原则</a></h2>
<h2 id="工厂模式">工厂模式</h2>
<p>抽象了创建具体对象的过程。就是使用工厂函数。<br>
该模式就是为了创建对象。
像工厂产出统一套件一样。
常用于创建对象。</p>
<pre><code>function createPerson (name, age, job) {
    var o = new Object()
    o.name = name
    o.age = age
    o.job = job
    o.sayName = function () {
        console.log(this.name)
    }
    return o
}
</code></pre>
<h2 id="单例模式">单例模式</h2>
<p>也叫单体模式，核心思想是确保一个类只对应一个实例。即使多次实例化。其实例结果是相同的。
在实现中只能有一个的事物。如：一个公司只能有一个会计系统，一个超市只能有一个收银系统。
esm 规范的模块天然支持单例模式。
常用于单一实例。</p>
<pre><code>var Singleton = function () {
    let instance = null
    function init () {
        var o = Object.create(null)
        o.name = 'top'
        o.admin = true
        o.sayHi = () =&gt; {
            console.log('hi')
        }
        return o
    }
    return {
        getInstance: function () {
            if (!instance) {
                instance = init()
            }
            return instance
        }
    }
}()
var a = Singleton.getInstance()
var b = Singleton.getInstance()
a === b
</code></pre>
<p>store(redux/vuex/pinia)/injector
在<a href="/util/index.html">util</a> <a href="/language/javascript/proxyReflect.html">proxy</a> <a href="/language/javascript/decorator.html">decorator</a>中在此示例。</p>
<h2 id="原型模式">原型模式</h2>
<p>就是实例化一个类
常用于方法、功能复用。</p>
<pre><code>function Foo () {}
Foo.prototype.hi = () =&gt; {}
var foo = new Foo()
</code></pre>
<h2 id="适配器模式">适配器模式</h2>
<p>把不合适的接口从一个合适的接口输出。
常用于统一“接口”。实现1 对接 n 或 n 对接 1.</p>
<pre><code>// 若
var hong = {
  say: () =&gt; {
    console.log('hi')
  }
}
var ming = {
  speak: () =&gt; {
    console.log('hi')
  }
}
var mingAdapter = {
  say: ming.speak
}
// 则可以这样使用
var friend = [hong, mingAdapter]
friend.forEach(item =&gt; {
  console.log(item)
  item.say()
})
</code></pre>
<h2 id="装饰器模式">装饰器模式</h2>
<p>常用于封装已经有的类或其方法或其属性或其参数。</p>
<pre><code>let dfn = () =&gt; {
  //
}
class MyClass {
}
// use
@dfn
class MyClass {
  constructor () {}
  fire () {}
}
// es5方法，会修改原来的属性。
</code></pre>
<h2 id="代理模式">代理模式</h2>
<p>用来控制访问本体对象。在模块模式的基础上开发出来的模式。先写一个单一原则的方法。再写一个控制触发该方法的方法（代理）
是把一些开销很大的对象，延迟到真正需要它的时候才去创建执行。
常用于：隔离、保护、验证、阻隔、缓冲、代理等。</p>
<pre><code>class User {
  constructor (name, age) {
    this.name = name
    this.age = age
  }
}
var handler = {
  set: (target, key, value, receiver) =&gt; {
    console.log(target, key, value, receiver)
    target[kye] = value
  },
  construct: (target, args, newTarget) =&gt; {
    console.log(target, args, newTarget)
    if (200 &lt; args[1]) {
      return {error: new Error('age is invalid')}
    } else {
      var a = Array.prototype.slice.call(args, 0)
      return new target(...a)
    }
  }
}
var proxy = new Proxy(User, handler)
var u = new proxy('u', 33)
let {proxy: p, revoke} = Proxy.revocable(User, handler)
revoke() // 解除代理
var a = new p('a', 23) // Uncaught TypeError: Cannot perform 'construct' on a proxy that has been revoked
</code></pre>
<h2 id="外观模式门面模式">外观模式（门面模式）</h2>
<p>对外提供一个大接口，在大接口的方法体时调用模块（或定义域）内的子方法。
如此可省去用户调用多个小接口的麻烦。让模块更内聚。<br>
<code>compose</code>方法就是一种体现。
常用于把一推方法放在一起执行。</p>
<pre><code>// demo0
function a () {...}
function b () {...}
function ab () {
  a()
  b()
}
ab()

// demo1
stopEvent()
function stopEvent () {
  stopPropagation()
  preventDefault()
}
function stopPropagation() {}
function preventDefault() {}
</code></pre>
<h2 id="桥接模式">桥接模式</h2>
<p>类的嵌套。
可利用常用的基本类。
与依赖注入相反。
依赖注入是单例的。桥接模式是多例的。</p>
<pre><code>class Base0 {}
class Base1 {}
class Super {
  constructor () {
    this.base0 = new Base0()
    this.base1 = new Base1()
  }
}
</code></pre>
<h2 id="组合模式">组合模式</h2>
<p>把多个命令（或方法）组合起来。可追加命令，再依次执行。
与门面模式类似。</p>
<pre><code>class MacroCommand {
  constructor () {
    this.commandList = []
  }
  add (fn) {
    this.commandList.push(fn)
  }
  execute () {
    this.commandList.forEach(cb =&gt; cb())
  }
}
let macroCommand = new MacroCommand()
macroCommand.add(firstCommand)
macroCommand.add(secondCommand)
macroCommand.add(threeCommand)
macroCommand.execute()
</code></pre>
<h2 id="享元模式共享模式">享元模式（共享模式）</h2>
<p>该模式是创建一个类，把相同的属性定义在该类中，把不同的属性定义在该类外面。<br>
当需要类的实例需要某些属性时，保持相同属性不变，改变不同属性为希望的属性。再返回该实例。<br>
当需要很多具有若干相同属性与不同属性的对象时，可以使用享元模式。<br>
// 该模式下的实例是共享的一个对象。</p>
<pre><code>function Circle (color) {
  this.color = color
  this.x
  this.y
  this.r
  this.setAttr = (x, y, r) =&gt; {
    this.x = x
    this.y = y
    this.r = r
  }
  this.draw = () =&gt; console.log('draw')
}
let shapeFactory = (function () {
  let store = {}
  return {
    getCircle: (color) =&gt; {
      if (!store[color]) {
        store[color] = new Circle(color)
      }
      return store[color]
    }
  }
})()
let circle0 = shapeFactory.getCircle('red')
circle.setAttr(1, 2, 3)
circle.draw()
</code></pre>
<h2 id="策略模式">策略模式</h2>
<p>策略模式可看作为 if/else 判断的另一种表现形式，在达到相同目的的同时，减少了代码量以及代码维护成本。<br>
分离算法的使用、算法的实现。
常用于表单验证、活动奖品。</p>
<pre><code class="language-js"><span class="hljs-comment">// demo0</span>
<span class="hljs-keyword">var</span> realize = {
    <span class="hljs-attr">first</span>: <span class="hljs-function">() =&gt;</span> {},
    <span class="hljs-attr">second</span>: <span class="hljs-function">() =&gt;</span> {},
    <span class="hljs-attr">third</span>: <span class="hljs-function">() =&gt;</span> {}
}
<span class="hljs-keyword">let</span> result = realize[param] ? realize[param]() : <span class="hljs-literal">null</span>

<span class="hljs-comment">// demo1</span>
<span class="hljs-comment">// html</span>
<span class="hljs-comment">// &lt;form&gt;</span>
<span class="hljs-comment">// js</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;submit&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">preventDefault</span>()
  <span class="hljs-keyword">var</span> validator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Validator</span>()
  <span class="hljs-keyword">var</span> result = validator.<span class="hljs-title function_">test</span>({
    <span class="hljs-string">&#x27;userName&#x27;</span>: [
      {<span class="hljs-attr">rule</span>: <span class="hljs-string">&#x27;isRequired&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">userName</span>.<span class="hljs-property">value</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;string&#x27;</span>},
      ...
    ],
    ...
  })
})

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Validator</span> () {}
<span class="hljs-title class_">Validator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">rules</span> = {
  <span class="hljs-attr">isRequired</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(^\s*)|(\s*$)/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)
  },
  ...
}
<span class="hljs-title class_">Validator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-function">(<span class="hljs-params">rules</span>) =&gt;</span> {
  <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>
  <span class="hljs-keyword">var</span> valid = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> rules) {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rules[key].<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">let</span> {rule, value, message} = rules[key][i]
      <span class="hljs-keyword">let</span> result = that.<span class="hljs-property">rules</span>[rule](value)
      <span class="hljs-comment">// let result = that.rules[rule].apply(this, value)</span>
      <span class="hljs-keyword">if</span> (!result) {
        valid = {
          <span class="hljs-attr">errValue</span>: key,
          <span class="hljs-attr">errMsg</span>: message
        }
        <span class="hljs-keyword">break</span>
      }
    }
    valid &amp;&amp; <span class="hljs-keyword">break</span>
  }
  <span class="hljs-keyword">return</span> valid
}

</code></pre>
<h2 id="模板方法模式">模板方法模式</h2>
<p>模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类。
在子类中的方法修改父类中的方法。
很像抽象类。
常用于
基本实践过程如下：</p>
<pre><code>function SaveData () {}
SaveData.prototype.check = () =&gt; {
  console.log('check data format')
}
SaveData.prototype.store = () =&gt; {
  console.log('store to db')
}
SaveData.prototype.feedback = () =&gt; {
  console.log('success save')
}
function SaveUser () {}
SaveUser.prototype = new SaveData()
SaveUser.prototype.check = (name) =&gt; {
  if (typeof name === 'string') {
    return name !== ''
  } else {
    return new Error('name is invalid')
  }
}
</code></pre>
<h2 id="观察者模式">观察者模式</h2>
<p>常用于统一分发消息。</p>
<pre><code>                 subject
                  ^   |
                  |   |
                  |   |
                  |   |
       subscribe  |   |  fire event
                  |   |
                  |   |
                  |   V
                 observer
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// use function</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Public</span> () {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">addSub</span> = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> { <span class="hljs-comment">// 添加订阅者</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">set</span>(item, <span class="hljs-title class_">Simple</span>())
  }
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">removeSub</span> = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">delete</span>(item)
  }
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">notice</span> = <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// 通知所有的订阅者，然后调用订阅者的指定方法。</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-title function_">compile</span>())
  }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span> () {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">compile</span> () {
    <span class="hljs-comment">//</span>
  }
}

<span class="hljs-comment">// use class format</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {
  <span class="hljs-title function_">constructor</span> () {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>
  }
  <span class="hljs-title function_">add</span>(<span class="hljs-params">...observer</span>) {
    observer.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">set</span>(item, <span class="hljs-title class_">Simple</span>())
    })
  }
  <span class="hljs-title function_">remove</span>(<span class="hljs-params">observer</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">delete</span>(observer)
  }
  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-title function_">update</span>())
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {
  <span class="hljs-title function_">constructor</span> () {
    <span class="hljs-comment">// ...</span>
  }
  update () {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;update&#x27;</span>)
  }
}
<span class="hljs-keyword">let</span> [o0, o1] = [<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>()]
<span class="hljs-keyword">let</span> sub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>()
sub.<span class="hljs-title function_">add</span>(o0, o1)
sub.<span class="hljs-title function_">notify</span>()
</code></pre>
<h2 id="发布订阅模式">发布订阅模式</h2>
<p>常用于监听变化、事件传递、消息通信、流式处理。<br>
<a href="/language/javascript/proxyReflect.html">用 proxy 写的示例</a></p>
<h2 id="迭代器模式">迭代器模式</h2>
<p>实现统一遍历接口。<br>
内部迭代器
用于遍历。</p>
<pre><code class="language-js">$.<span class="hljs-title function_">each</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], <span class="hljs-keyword">function</span> (<span class="hljs-params">index, value</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, value)
})
</code></pre>
<p>外部迭代器</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params">arr</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, value] <span class="hljs-keyword">of</span> arr.<span class="hljs-title function_">entries</span>()) {
    <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([index, value])
  }
}
<span class="hljs-keyword">let</span> ite = <span class="hljs-title function_">gen</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>])
ite.<span class="hljs-title function_">next</span>()
ite.<span class="hljs-title function_">next</span>()
ite.<span class="hljs-title function_">next</span>()
</code></pre>
<p>es6 中 Iterator 接口部署在 Symbol.iterator 属性上。<br>
当执行<code>[Symbol.iterator]()</code>会返回一个遍历器对象。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]
<span class="hljs-keyword">var</span> ite = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()
<span class="hljs-comment">// arr[Symbol.iterator]   是遍历器生成函数</span>
<span class="hljs-comment">// arr[Symbol.iterator]() 是遍历器对象</span>
ite.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// {value: &#x27;a&#x27;, done: false}</span>
ite.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// {value: &#x27;b&#x27;, done: false}</span>
ite.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// {value: &#x27;c&#x27;, done: false}</span>
ite.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// {value: undefined, done: true}</span>
</code></pre>
<h2 id="职责链模式">职责链模式</h2>
<p>消除请求的发送者与接收者的耦合。</p>
<ol>
<li>发送者知道链中的第一个接收者，它向这个接收者发送该请求。</li>
<li>每一个接收者都对请求进行分析，然后要么处理它，要么把它往下传递。</li>
<li>每一个接收者只知道它在链中的下家(successor)。</li>
<li>如果没有任何接收者处理请求，那么请求会从链中离开。</li>
<li>过程很像链表。</li>
<li>一般最后一个是兜底的。</li>
</ol>
<p>有点像 compose / 葫芦娃救爷爷 /
可以代替 switch。
常用于解决方案排队。</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">order500</span>(<span class="hljs-params">orderType, isPay, count</span>) {
  <span class="hljs-keyword">if</span> (orderType == <span class="hljs-number">1</span> &amp;&amp; isPay == <span class="hljs-literal">true</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;亲爱的用户，您中奖了100元红包了&#x27;</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//我不知道下一个节点是谁,反正把请求往后面传递</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;nextSuccessor&#x27;</span>
  }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">order200</span>(<span class="hljs-params">orderType, isPay, count</span>) {
  <span class="hljs-keyword">if</span> (orderType == <span class="hljs-number">2</span> &amp;&amp; isPay == <span class="hljs-literal">true</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;亲爱的用户，您中奖了20元红包了&#x27;</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//我不知道下一个节点是谁,反正把请求往后面传递</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;nextSuccessor&#x27;</span>
  }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">orderNormal</span>(<span class="hljs-params">orderType, isPay, count</span>) {
  <span class="hljs-comment">// 普通用户来处理中奖信息</span>
  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;亲爱的用户，您已抽到10元优惠卷&#x27;</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;亲爱的用户，请再接再厉哦&#x27;</span>)
  }
}
<span class="hljs-comment">// 下面需要编写职责链模式的封装构造函数方法</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Chain</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span> = fn
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span> = <span class="hljs-literal">null</span>
}
<span class="hljs-title class_">Chain</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setNextSuccessor</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">successor</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span> = successor)
}
<span class="hljs-comment">// 把请求往下传递</span>
<span class="hljs-title class_">Chain</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">passRequest</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> ret = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>)
  <span class="hljs-keyword">if</span> (ret === <span class="hljs-string">&#x27;nextSuccessor&#x27;</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span> &amp;&amp;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span>.<span class="hljs-property">passRequest</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span>, <span class="hljs-variable language_">arguments</span>)
    )
  }
  <span class="hljs-keyword">return</span> ret
}
<span class="hljs-comment">//现在我们把3个函数分别包装成职责链节点：</span>
<span class="hljs-keyword">var</span> chainOrder500 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>(order500)
<span class="hljs-keyword">var</span> chainOrder200 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>(order200)
<span class="hljs-keyword">var</span> chainOrderNormal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>(orderNormal)

<span class="hljs-comment">// 然后指定节点在职责链中的顺序</span>
chainOrder500.<span class="hljs-title function_">setNextSuccessor</span>(chainOrder200)
chainOrder200.<span class="hljs-title function_">setNextSuccessor</span>(chainOrderNormal)

<span class="hljs-comment">//最后把请求传递给第一个节点：</span>
chainOrder500.<span class="hljs-title function_">passRequest</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">500</span>) <span class="hljs-comment">// 亲爱的用户，您中奖了100元红包了</span>
chainOrder500.<span class="hljs-title function_">passRequest</span>(<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">500</span>) <span class="hljs-comment">// 亲爱的用户，您中奖了20元红包了</span>
chainOrder500.<span class="hljs-title function_">passRequest</span>(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">500</span>) <span class="hljs-comment">// 亲爱的用户，您已抽到10元优惠卷</span>
chainOrder500.<span class="hljs-title function_">passRequest</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 亲爱的用户，请再接再厉哦</span>

<span class="hljs-comment">// 我优化过的1</span>
<span class="hljs-keyword">let</span> symbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;chain&#x27;</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Chain</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">threshold, ...fnList</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">threshold</span> = threshold
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fnMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(fnList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> [item, <span class="hljs-title class_">Symbol</span>()]))
  }
  <span class="hljs-title function_">add</span>(<span class="hljs-params">fn</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fnMap</span>.<span class="hljs-title function_">set</span>(fn, <span class="hljs-title class_">Symbol</span>())
  }
  <span class="hljs-title function_">remove</span>(<span class="hljs-params">fn</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fnMap</span>.<span class="hljs-title function_">delete</span>(fn) <span class="hljs-comment">// boolean</span>
  }
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">fnList</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_fnMap</span>.<span class="hljs-title function_">keys</span>())
  }
  <span class="hljs-title function_">passRequest</span>(<span class="hljs-params">threshold, ...args</span>) {
    <span class="hljs-keyword">let</span> res
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">fnList</span>.<span class="hljs-property">length</span>; i++) {
      res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fnList</span>[i](...args)
      <span class="hljs-keyword">if</span> (res === threshold) {
        <span class="hljs-keyword">break</span>
      }
    }
    <span class="hljs-keyword">return</span> res
  }
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">fn0</span> = (<span class="hljs-params">a</span>) =&gt; {
  <span class="hljs-keyword">if</span> ((a = <span class="hljs-number">1</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> symbol
  }
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">fn1</span> = (<span class="hljs-params">a</span>) =&gt; {
  <span class="hljs-keyword">if</span> ((a = <span class="hljs-number">2</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> symbol
  }
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">fn2</span> = (<span class="hljs-params">a, b, c</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>
}
<span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>(symbol, fn0, fn1, fn2)
<span class="hljs-title function_">clog</span>(c.<span class="hljs-title function_">passRequest</span>(<span class="hljs-number">0</span>))

<span class="hljs-comment">// 我优化过的2</span>
<span class="hljs-keyword">let</span> chain = <span class="hljs-keyword">function</span> (<span class="hljs-params">threshold, ...fnList</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">fnList</span> = fnList
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-comment">// this.fnList</span>
    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">fnList</span>.<span class="hljs-property">length</span>; i++) {
      res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fnList</span>[i](...args)
      <span class="hljs-keyword">if</span> (res === threshold) {
        <span class="hljs-comment">// go on</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">break</span>
      }
    }
    <span class="hljs-keyword">return</span> res
  }
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">fn0</span> = (<span class="hljs-params">a</span>) =&gt; {
  <span class="hljs-title function_">clog</span>(<span class="hljs-string">&#x27;fn0&#x27;</span>, a)
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;chain&#x27;</span>)
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">fn1</span> = (<span class="hljs-params">a, b</span>) =&gt; {
  <span class="hljs-title function_">clog</span>(<span class="hljs-string">&#x27;fn1&#x27;</span>, a, b)
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">fn2</span> = (<span class="hljs-params">a, b, c</span>) =&gt; {
  <span class="hljs-title function_">clog</span>(<span class="hljs-string">&#x27;fn2&#x27;</span>, a, b, c)
}
<span class="hljs-keyword">let</span> cf = <span class="hljs-title function_">chain</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;chain&#x27;</span>), fn0, fn1, fn2)
<span class="hljs-title function_">cf</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// 输出到fn1</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn1</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;nextSuccessor&#x27;</span>
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn2</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)
  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    self.<span class="hljs-title function_">next</span>()
  }, <span class="hljs-number">1000</span>)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn3</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)
}
<span class="hljs-comment">// 下面需要编写职责链模式的封装构造函数方法</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Chain</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span> = fn
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span> = <span class="hljs-literal">null</span>
}
<span class="hljs-title class_">Chain</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setNextSuccessor</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">successor</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span> = successor)
}
<span class="hljs-comment">// 把请求往下传递</span>
<span class="hljs-title class_">Chain</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">passRequest</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> ret = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>)
  <span class="hljs-keyword">if</span> (ret === <span class="hljs-string">&#x27;nextSuccessor&#x27;</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span> &amp;&amp;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span>.<span class="hljs-property">passRequest</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span>, <span class="hljs-variable language_">arguments</span>)
    )
  }
  <span class="hljs-keyword">return</span> ret
}
<span class="hljs-title class_">Chain</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">next</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span> &amp;&amp;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span>.<span class="hljs-property">passRequest</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">successor</span>, <span class="hljs-variable language_">arguments</span>)
  )
}
<span class="hljs-comment">//现在我们把3个函数分别包装成职责链节点：</span>
<span class="hljs-keyword">var</span> chainFn1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>(<span class="hljs-title class_">Fn1</span>)
<span class="hljs-keyword">var</span> chainFn2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>(<span class="hljs-title class_">Fn2</span>)
<span class="hljs-keyword">var</span> chainFn3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>(<span class="hljs-title class_">Fn3</span>)

<span class="hljs-comment">// 然后指定节点在职责链中的顺序</span>
chainFn1.<span class="hljs-title function_">setNextSuccessor</span>(chainFn2)
chainFn2.<span class="hljs-title function_">setNextSuccessor</span>(chainFn3)

chainFn1.<span class="hljs-title function_">passRequest</span>() <span class="hljs-comment">// 打印出1，2 过1秒后 会打印出3</span>
</code></pre>
<h2 id="模块模式">模块模式</h2>
<p>把方法、属性分为分开的与私有的。
像闭包。
常用于模块化</p>
<pre><code class="language-js"><span class="hljs-comment">// 闭包</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">ModuleFn</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> privateVar = <span class="hljs-number">0</span>
  <span class="hljs-keyword">var</span> <span class="hljs-title function_">privateFn</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;privateFn&#x27;</span>)
  }
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">publicFn0</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;publicFn0&#x27;</span>)
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;privateVar&#x27;</span>, privateVar)
    },
    <span class="hljs-attr">publicFn1</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;publicFn1&#x27;</span>)
      <span class="hljs-title function_">privateFn</span>()
    },
  }
})()
<span class="hljs-title class_">ModuleFn</span>.<span class="hljs-title function_">publicFn0</span>()
<span class="hljs-title class_">ModuleFn</span>.<span class="hljs-title function_">publicFn1</span>()
<span class="hljs-comment">// commonjs同理</span>
<span class="hljs-comment">// esm同理</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 再使用class实现一次</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SingleChain</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;data-footstone&#x27;</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DutyChain</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chain</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleChain</span>()
  }
  <span class="hljs-title function_">append</span>(<span class="hljs-params">rule, fn</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chain</span>.<span class="hljs-title function_">append</span>({ rule, fn })
  }
  <span class="hljs-title function_">remove</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// to do</span>
  }
  <span class="hljs-title function_">execute</span>(<span class="hljs-params">pararms</span>) {
    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">chain</span>.<span class="hljs-property">head</span>
    <span class="hljs-keyword">let</span> res = undefind
    <span class="hljs-keyword">while</span> (cur) {
      <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">value</span>.<span class="hljs-title function_">rule</span>(pararms)) {
        res = cur.<span class="hljs-property">value</span>.<span class="hljs-title function_">fn</span>(params)
        <span class="hljs-keyword">break</span>
      }
      cur = cur.<span class="hljs-property">next</span>
    }
    <span class="hljs-keyword">return</span> res
  }
}
</code></pre>
<h2 id="命令模式">命令模式</h2>
<p>执行一个执行某些特定事情的指令。像是封装了一个方法。<br>
把需要重用的逻辑封装为一个方法，再在需要的地方调用此方法。</p>
<pre><code class="language-js"><span class="hljs-comment">// 如下代码上的四个按钮 点击事件</span>
<span class="hljs-keyword">var</span> b1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button1&#x27;</span>),
  b2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button2&#x27;</span>),
  b3 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button3&#x27;</span>),
  b4 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button4&#x27;</span>)
<span class="hljs-comment">/*
 bindEnv函数负责往按钮上面安装点击命令。点击按钮后，会调用
 函数
 */</span>
<span class="hljs-keyword">var</span> bindEnv = <span class="hljs-keyword">function</span> (<span class="hljs-params">button, func</span>) {
  button.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">func</span>()
  }
}
<span class="hljs-comment">// 现在我们来编写具体处理业务逻辑代码</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Todo1</span> = {
  <span class="hljs-attr">test1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是来做第一个测试的&#x27;</span>)
  },
}
<span class="hljs-comment">// 实现业务中的增删改操作</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Menu</span> = {
  <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是来处理一些增加操作的&#x27;</span>)
  },
  <span class="hljs-attr">del</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是来处理一些删除操作的&#x27;</span>)
  },
  <span class="hljs-attr">update</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是来处理一些更新操作的&#x27;</span>)
  },
}
<span class="hljs-comment">// 调用函数</span>
<span class="hljs-title function_">bindEnv</span>(b1, <span class="hljs-title class_">Todo1</span>.<span class="hljs-property">test1</span>)
<span class="hljs-comment">// 增加按钮</span>
<span class="hljs-title function_">bindEnv</span>(b2, <span class="hljs-title class_">Menu</span>.<span class="hljs-property">add</span>)
<span class="hljs-comment">// 删除按钮</span>
<span class="hljs-title function_">bindEnv</span>(b3, <span class="hljs-title class_">Menu</span>.<span class="hljs-property">del</span>)
<span class="hljs-comment">// 更改按钮</span>
<span class="hljs-title function_">bindEnv</span>(b4, <span class="hljs-title class_">Menu</span>.<span class="hljs-property">update</span>)
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> command1 = {
  <span class="hljs-attr">execute</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)
  },
}
<span class="hljs-keyword">var</span> command2 = {
  <span class="hljs-attr">execute</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)
  },
}
<span class="hljs-keyword">var</span> command3 = {
  <span class="hljs-attr">execute</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)
  },
}
<span class="hljs-comment">// 定义宏命令，command.add方法把子命令添加进宏命令对象，</span>
<span class="hljs-comment">// 当调用宏命令对象的execute方法时，会迭代这一组命令对象，</span>
<span class="hljs-comment">// 并且依次执行他们的execute方法。</span>
<span class="hljs-keyword">var</span> command = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">commandsList</span>: [],
    <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">command</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandsList</span>.<span class="hljs-title function_">push</span>(command)
    },
    <span class="hljs-attr">execute</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">for</span> (
        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, commands = <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandsList</span>.<span class="hljs-property">length</span>;
        i &lt; commands;
        i += <span class="hljs-number">1</span>
      ) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">commandsList</span>[i].<span class="hljs-title function_">execute</span>()
      }
    },
  }
}
<span class="hljs-comment">// 初始化宏命令</span>
<span class="hljs-keyword">var</span> c = <span class="hljs-title function_">command</span>() <span class="hljs-comment">// 这是门面模式</span>
c.<span class="hljs-title function_">add</span>(command1)
c.<span class="hljs-title function_">add</span>(command2)
c.<span class="hljs-title function_">add</span>(command3)
</code></pre>
<h2 id="备忘录模式">备忘录模式</h2>
<p>也叫缓存模式。在一个栈中保存多个状态。当需要返回前一个状态时，从栈中弹出一状态。直到栈为空。<br>
与缓存相关的算法有<a href="/jsPackages/data-footstone.html">fifo/lru/lfu</a>
常用于缓存频繁计算时。</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memo</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 同时支持有序、无序。</span>
    <span class="hljs-comment">// 复杂度支持1、n</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyList</span> = []
  }
  <span class="hljs-comment">// 保存状态</span>
  <span class="hljs-title function_">push</span>(<span class="hljs-params">key, state</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyList</span>.<span class="hljs-title function_">push</span>(key)
    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">KEY</span> = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(key)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyMap</span>.<span class="hljs-title function_">set</span>(<span class="hljs-variable constant_">KEY</span>, state)
  }
  <span class="hljs-comment">// 查看指定状态</span>
  <span class="hljs-title function_">peek</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyMap</span>.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(key))
  }
  <span class="hljs-comment">// 弹出最后一个状态</span>
  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> lastKey = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyList</span>.<span class="hljs-title function_">pop</span>()
    <span class="hljs-keyword">let</span> state = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">peek</span>(lastKey)
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">delState</span>(lastKey)
    <span class="hljs-keyword">return</span> state
  }
  <span class="hljs-comment">// 删除指定的状态</span>
  <span class="hljs-title function_">delState</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyList</span>.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item === key)
    <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyList</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyMap</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(key))
    }
  }
  <span class="hljs-comment">// 查看所有状态</span>
  <span class="hljs-title function_">allState</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// [[k, v], [k0, v0], ...]</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyList</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">r, c</span>) =&gt;</span> {
      r.<span class="hljs-title function_">push</span>([c, <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateKeyMap</span>.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(c))])
      <span class="hljs-keyword">return</span> r
    }, [])
  }
}
</code></pre>
<h2 id="状态模式">状态模式</h2>
<p>定义一个对象。这个对象里定义了很多状态及对应的方法（这种对应关系有点像策略模式），再暴露一个改变状态的接口，再暴露一个调用的接口。
每个状态下都有特定行为。</p>
<p>状态模式与其他模式的关系</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>关系</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>策略</td>
<td>结构相似，意图不同</td>
<td>策略模式选择算法，状态模式管理状态转换</td>
</tr>
<tr>
<td>命令</td>
<td>都可封装行为</td>
<td>命令封装操作，状态封装状态相关行为</td>
</tr>
<tr>
<td>享元</td>
<td>共享状态对象</td>
<td>享元共享对象，状态模式管理状态转换</td>
</tr>
<tr>
<td>单例</td>
<td>状态对象可共享</td>
<td>单例确保唯一实例，状态模式管理状态</td>
</tr>
<tr>
<td>职责链</td>
<td>-</td>
<td>职责链模式每个方法依次尝试。状态可以改变。职责链模式不能改变。</td>
</tr>
</tbody>
</table>
<pre><code class="language-js"><span class="hljs-comment">// 这个示例不对。</span>
<span class="hljs-comment">// 应该体现出多种状态中相同或不同方法名的不同逻辑。</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">user</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentState</span> = []
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">states</span> = {
      <span class="hljs-attr">move</span>: <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;move&#x27;</span>)
      },
      <span class="hljs-attr">stop</span>: <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stop&#x27;</span>)
      },
      <span class="hljs-attr">speak</span>: <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;speak&#x27;</span>)
      },
    }
  }
  <span class="hljs-title function_">changeStatus</span>(<span class="hljs-params">...state</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentState</span> = state
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
  }
  <span class="hljs-title function_">goAhead</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentState</span>.<span class="hljs-title function_">forEach</span>(
      <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">states</span>[item] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">states</span>[item]()
    )
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
  }
}
</code></pre>
<h2 id="访问者模式">访问者模式</h2>
<p>把数据与操作数据的方法分开。<br>
数据在被访问者里面。
操作数据在访问者里面。
因为把 2 者分开了，所以需要处理 n 个数据与 n 个操作数据的方法的逻辑。
当被访问者集合在一起后，可以优雅地遍历对象。
常用于数据与操作数据的逻辑分离。</p>
<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>) {
    <span class="hljs-keyword">return</span> visitor.<span class="hljs-title function_">visit</span>(<span class="hljs-variable language_">this</span>)
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> {
  <span class="hljs-attr">radius</span>: N
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">radius</span>) {
    <span class="hljs-variable language_">super</span>()
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = radius
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> {
  <span class="hljs-attr">width</span>: N
  <span class="hljs-attr">height</span>: N
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width: N, height: N</span>) {
    <span class="hljs-variable language_">super</span>()
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeCollection</span> {
  <span class="hljs-attr">shapes</span>: <span class="hljs-title class_">Shape</span>[]
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">shapes</span> = []
  }
  <span class="hljs-title function_">addShape</span>(<span class="hljs-params">ele</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">shapes</span>.<span class="hljs-title function_">push</span>(ele)
  }
  <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">shapes</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">shape</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> shape.<span class="hljs-title function_">accept</span>(visitor)
    })
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AreaVisitor</span> {
  <span class="hljs-title function_">visit</span>(<span class="hljs-params">ele</span>) {
    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>
    <span class="hljs-keyword">switch</span> (ele.<span class="hljs-property">constructor</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Rectangle</span>:
        res = ele.<span class="hljs-property">width</span> * ele.<span class="hljs-property">height</span>
        <span class="hljs-keyword">break</span>
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Circle</span>:
        res = ele.<span class="hljs-property">radius</span> ** <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>
        <span class="hljs-keyword">break</span>
    }
    <span class="hljs-keyword">return</span> res
  }
}

<span class="hljs-keyword">let</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>)
<span class="hljs-keyword">let</span> rectangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> shapeCollection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShapeCollection</span>()
shapeCollection.<span class="hljs-title function_">addShape</span>(circle)
shapeCollection.<span class="hljs-title function_">addShape</span>(rectangle)
<span class="hljs-keyword">let</span> visitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AreaVisitor</span>()
<span class="hljs-title function_">clog</span>(shapeCollection.<span class="hljs-title function_">accept</span>(visitor))
</code></pre>
<h2 id="中介模式">中介模式</h2>
<p>解耦对象与对象（数据与数据）之间关系。使二者间尽可能解耦。<br>
常用于多对多的关系。像发布订阅模式。</p>
<pre><code class="language-js"><span class="hljs-comment">// demo0</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Game</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  }
  <span class="hljs-title function_">addPlayer</span>(<span class="hljs-params">...ps</span>) {
    ps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerList</span>.<span class="hljs-title function_">set</span>(p.<span class="hljs-property">name</span>, p)
    })
  }
  <span class="hljs-title function_">removePlayer</span>(<span class="hljs-params">p</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerList</span>.<span class="hljs-title function_">delete</span>(p.<span class="hljs-property">name</span>)
  }
  <span class="hljs-title function_">operate</span>(<span class="hljs-params">source, target, operation</span>) {
    <span class="hljs-keyword">switch</span>(operation) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;...&#x27;</span>:
        <span class="hljs-comment">// source.fn0()</span>
        <span class="hljs-comment">// target.fn1()</span>
        <span class="hljs-keyword">break</span>
    }
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, ...rest</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name
  }
  <span class="hljs-title function_">fn0</span>(<span class="hljs-params"></span>) {...}
  <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) {...}
}
<span class="hljs-keyword">const</span> game = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Game</span>()
<span class="hljs-keyword">let</span> p0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&#x27;p0&#x27;</span>)
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&#x27;p1&#x27;</span>)
<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&#x27;p2&#x27;</span>)
game.<span class="hljs-title function_">addPlayer</span>(p0, p1, p2)
<span class="hljs-comment">// 某情况下触发了：</span>
game.<span class="hljs-title function_">operate</span>(p0, p1, <span class="hljs-string">&#x27;xxx&#x27;</span>)
</code></pre>
<h2 id="解释器模式">解释器模式</h2>
<p>解释器模式(Interpreter) : 定义一种文法的表示,并定义一种解释器, 通过这个解释器类解析对应的文法内容.</p>
<ol>
<li>利用解释器类解析文法中表示的想要的意图，解决并实现对应的需求.</li>
<li>将一些特定类型的问题，提供一种更简单的文法表示, 来解决对应的问题.</li>
<li>将一些重复出现的问题，用一种简单的语言来进行表达.</li>
</ol>
<h2 id="环形模式">环形模式</h2>
<p>这是我定义的模式。在读一些开源项目时发现常这么使用。<br>
有点像环形链表。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> o = {
  <span class="hljs-attr">k</span>: <span class="hljs-string">&#x27;v&#x27;</span>,
}
o.<span class="hljs-property">origin</span> = o
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> o
</code></pre>
<h2 id="回调模式">回调模式</h2>
<p>把一个方法 a 传入另一个方法 b。在某时刻是调用方法 a.<br>
在子组件改变父组件的数据时常用这种方法。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">cb</span>) =&gt; {
  <span class="hljs-comment">// 某时刻执行</span>
  <span class="hljs-keyword">if</span> (expression) {
    <span class="hljs-title function_">cb</span>()
  }
}
</code></pre>
<h2 id="惰性模式">惰性模式</h2>
<p>把懒函数整理为一种设计模式。
常用于需要经过复杂的判断后得到一个东西。</p>
<pre><code class="language-js"><span class="hljs-comment">// 定义</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-comment">// 若干环境判断</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    ...
  }
}
<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">let</span> fa = <span class="hljs-title function_">fn</span>()
<span class="hljs-title function_">fa</span>()
</code></pre>
<h2 id="沙箱模式">沙箱模式</h2>
<p>该模式提供了一个可用于模块运行的环境。yui 中就使用了此模式。<br>
从全量模块中取出指定的模块。<br>
书上写的太繁琐了，下面我整理的简单的。
常用于插件、扩展。</p>
<pre><code class="language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">let</span> allModules = {
  <span class="hljs-attr">a</span>: fn,
  <span class="hljs-attr">b</span>: fn,
  <span class="hljs-attr">c</span>: fn,
  <span class="hljs-attr">d</span>: fn,
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">sandbox</span> = (<span class="hljs-params">modulesName</span>) =&gt; {
  <span class="hljs-keyword">let</span> res = {}
  modulesName.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
    res[name] = allModules[name]
  })
  <span class="hljs-keyword">return</span> res
}
<span class="hljs-keyword">let</span> instance = <span class="hljs-title function_">sandbox</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>])

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> all <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./allModules&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">a</span>: all.<span class="hljs-property">a</span>
  <span class="hljs-attr">b</span>: all.<span class="hljs-property">b</span>
  <span class="hljs-attr">c</span>: all.<span class="hljs-property">c</span>
}
</code></pre>
<h2 id="链模式">链模式</h2>
<p>常用于链式调用。
vue3 就是使用了此模式。对 vue3 对象上执行了一个方法，并返回 vue3 对象。
分布式操作数组的方法支持此模式。<code>filter/map/reduce/forEach</code></p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">O</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {...}
  <span class="hljs-attr">a</span>: <span class="hljs-function">() =&gt;</span> {
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
  }
  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> {
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
  }
  <span class="hljs-attr">c</span>: <span class="hljs-function">() =&gt;</span> {
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
  }
}
<span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title function_">O</span>()
o.<span class="hljs-title function_">a</span>().<span class="hljs-title function_">b</span>().<span class="hljs-title function_">c</span>()
</code></pre>
<h2 id="依赖注入模式">依赖注入模式</h2>
<p>将创建对象的任务转移给其他 class，并直接使用依赖项的过程，被称为“依赖项注入”。
有三种类型的依赖注入：</p>
<ul>
<li>构造函数注入：依赖关系是通过 class 构造器提供的。</li>
<li>setter 注入：注入程序用客户端的 setter 方法注入依赖项。</li>
<li>接口注入：依赖项提供了一个注入方法，该方法将把依赖项注入到传递给它的任何客户端中。客户端必须实现一个接口，该接口的 setter 方法接收依赖。</li>
</ul>
<p>它是设计模式，同时又是一种机制：当应用程序的一些部件（即一些依赖）需要另一些部件时，利用依赖注入来创建被请求的部件，并将它们注入到需要它们的部件中。</p>
<p>在 Angular 中，依赖通常是服务，但是也可以是值，比如字符串或函数。应用的注入器（它是在启动期间自动创建的）会使用该服务或值的配置好的提供者来按需实例化这些依赖。各个不同的提供者可以为同一个服务提供不同的实现。</p>
<p>我常用的是高阶方法、回调方法，要么喂入变量。虽然变量包括实例，但是没有把实例作为参数提高认知高度。</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>{
    <span class="hljs-title class_">Weapon</span> weapon;
    <span class="hljs-comment">// weapon 与 Sword类紧密耦合</span>
    <span class="hljs-comment">// 这不是依赖注入模式</span>
    <span class="hljs-title class_">Player</span>(){
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">weapon</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sword</span>();
    }
    <span class="hljs-comment">// weapon 与 sword类紧密耦合. weapon可以是sword、gun等</span>
    <span class="hljs-comment">// 这是依赖注入模式</span>
    <span class="hljs-title class_">Player</span>(sword){
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">weapon</span> = sword
    }
    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span>(<span class="hljs-params"></span>) {
        weapon.<span class="hljs-title function_">attack</span>();
    }
}
</code></pre>
<p>使用依赖注入的优势</p>
<ul>
<li>帮助进行单元测试。</li>
<li>由于依赖关系的初始化是由注入器组件完成的，因此减少了样板代码。</li>
<li>扩展应用程序变得更加容易。</li>
<li>帮助实现松耦合，这在应用编程中很重要。</li>
</ul>
<h2 id="总结">总结</h2>
<p>在实际运行中常会用于多种设计模式，也会用到设计模式的变种。</p>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>