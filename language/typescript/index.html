<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&DiacriticalGrave;TypeScript&DiacriticalGrave;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="typescript"><code>TypeScript</code></h1>
<h2 id="overview">overview</h2>
<blockquote>
<p>简称 ts<br>
js 是强类型语言<br>
ts 比 js 更强大。已经有很多前端项目使用此语言了。<br>
ts 是静态类型检测器。比 flow 更强大。<br>
它就是强类型的 js。它的所有功能都是为了类型服务的。<br>
ts 把 interface/type 都叫做类型<br>
它是编写代码的一种方式。可以使用 js/也可以使用 ts.ts 没有宣传的那么重要。它只是为 js 赋予了强类型。还需要把 ts 文件转换为 js 文件。如果 js 未来支持强类型了。ts 也就无存在的意义了。<br>
从设计 （uml） 到代码比js平滑。</p>
</blockquote>
<h3 id="feature">feature</h3>
<ul>
<li>类型注解</li>
<li>类型推断</li>
<li>在开发过程中发现潜在问题（根据类型发现的）。</li>
</ul>
<h2 id="install">install</h2>
<p><code>npm i -g typescript</code><br>
该包是要 ts 语言的转译器。在命令行中使用<code>tsc</code>调用转译功能。这是一个命令行工具居然没有以<code>-cli</code>结尾。可能是不仅包括命令行工具。<br>
安装后可在命令行中使用<code>tsc</code>。</p>
<h2 id="usage">usage</h2>
<p>dome 详见<a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html">官网</a></p>
<pre><code class="language-ts"><span class="hljs-comment">// 单例模式</span>
<span class="hljs-comment">// define</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">Demo</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>()
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>
  }
}
<span class="hljs-comment">// usage</span>
<span class="hljs-title class_">Demo</span>.<span class="hljs-title function_">getInstance</span>() <span class="hljs-comment">// instance</span>
</code></pre>
<p>使用示例：</p>
<pre><code class="language-ts"><span class="hljs-comment">// 使用interface</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaintOptions</span>&lt;T&gt; {
  <span class="hljs-attr">shape</span>: <span class="hljs-built_in">string</span>;
  xPos?: <span class="hljs-built_in">number</span>;
  yPos?: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">resident</span>: { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };
  <span class="hljs-attr">age</span>: <span class="hljs-number">2</span>;
  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: T;
}
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">PaintOptions</span> &amp; B
<span class="hljs-keyword">let</span> a = <span class="hljs-title class_">PaintOptions</span>&lt;<span class="hljs-built_in">string</span>&gt;

<span class="hljs-comment">// 使用方法</span>
<span class="hljs-keyword">function</span> identity&lt;<span class="hljs-title class_">Type</span>&gt;(<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> {
  <span class="hljs-keyword">return</span> arg;
}
<span class="hljs-comment">// fn &amp; interface</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">fn</span>: I = <span class="hljs-function">() =&gt;</span> {...}

<span class="hljs-comment">// use class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GN</span>&lt;T&gt; {
    <span class="hljs-attr">value</span>: T,
    <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;
}
<span class="hljs-keyword">let</span> gn = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">GN</span>&lt;<span class="hljs-built_in">string</span>&gt;()
</code></pre>
<h3 id="使用命令行">使用命令行</h3>
<p>把 ts 转化为 js。</p>
<pre><code class="language-shell">tsc hello.ts
</code></pre>
<h2 id="编译器">编译器</h2>
<ul>
<li>babel</li>
<li>swc</li>
<li>sucrase</li>
</ul>
<h2 id="错误提示">错误提示</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>static type-checking</td>
<td>类型错误</td>
<td></td>
<td></td>
</tr>
<tr>
<td>non-exception failure</td>
<td>类型与期望值不同</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="数据类型">数据类型</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>number</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>array</td>
<td><code>[type]</code> / <code>type[]</code> / <code>Array&lt;type&gt;</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>any</td>
<td></td>
<td>当 ts 不能推断出数据类型时，使用 any 类型。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>function</td>
<td></td>
<td>可能与下面的 Function 有关</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>object</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>union</td>
<td></td>
<td>联合类型</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>type</td>
<td></td>
<td>类型别名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>interface</td>
<td></td>
<td>声明对象类型的另一种方式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>object</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>type assertions</td>
<td></td>
<td>类型断言</td>
<td><code>(param as type)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>literal</td>
<td></td>
<td>明确指定变量的值。初始化对象时 ts 会认为这是最后一次改变。以后不能再改变。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>null</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>undefined</td>
<td></td>
<td>也叫 void</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>enums</td>
<td></td>
<td>枚举。列出具体的可选的值。它是真实的对象。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bigint</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>symbol</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>unknown</td>
<td></td>
<td>代表 any 数据。与 any 类型相似。unknown 更安全。使用时需要类型断言。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>never</td>
<td></td>
<td>永远不会执行到的对象类型。当方法返回 never 时表示抛出一个错误、或打断执行方法。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Function</td>
<td></td>
<td></td>
<td>别的都是小写，为什么它是大写。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ReadonlyArray</td>
<td></td>
<td>使数组只读</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tuple</td>
<td></td>
<td>明确数组中对应下标的数据的类型</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>generic types</code></td>
<td></td>
<td>泛型</td>
<td>``</td>
<td></td>
<td></td>
</tr>
<tr>
<td>symbol</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="type--interface-不同"><a href="/language/typescript/type&amp;interface.html">type &amp; interface 不同</a></h3>
<h3 id="缩小类型范围">缩小类型范围</h3>
<ul>
<li>typeof 会返回 8 种结果<code>string / number / bigint / boolean / symbol / undefined / object / function</code>。其中<code>null</code>，它被认为是<code>object</code>。与 js 的基本数据类型相比。多了<code>function</code>。</li>
<li>真值判断。ts 把<code>0 / NaN / '' / 0n / null / undefined</code>认为是假值。</li>
<li>相等判断。使用<code>== / != / === / !==</code></li>
<li>使用<code>in</code>判断。如：<code>if (key in obj) {...}</code></li>
<li>实例判断 <code>intance instanceof Consturctor</code></li>
<li>变量的数据类型与赋的值的数据类型不同时，不能赋值。</li>
<li>分数据类型控制分支。<code>switch(p) {case 'k': ...</code></li>
<li>使用类型断言。如：<code>(params as number)</code></li>
<li>枚举值判断。</li>
</ul>
<h3 id="方法的类型">方法的类型</h3>
<pre><code class="language-ts"><span class="hljs-comment">// 定义方法的接口</span>
<span class="hljs-title class_">Interface</span> <span class="hljs-title class_">SeachFn</span> {
  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">p</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>) {
  <span class="hljs-title function_">p</span>(<span class="hljs-string">&#x27;str&#x27;</span>)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)
}
</code></pre>
<p>定义方法的类型。<br>
方法也是一个对象。即：方法可以有自己的属性。</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">DF</span> = {
  <span class="hljs-attr">desc</span>: <span class="hljs-built_in">string</span>
  (<span class="hljs-attr">p</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 这里使用 : 不是 =&gt;</span>
  <span class="hljs-comment">// construct signatures</span>
  <span class="hljs-keyword">new</span> (<span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>
}
</code></pre>
<p>方法与泛型结合使用</p>
<pre><code class="language-ts"><span class="hljs-comment">// defined</span>
这里指定会用到的泛型
这是使用指定的泛型
<span class="hljs-keyword">function</span> fn&lt;T&gt;(<span class="hljs-attr">arr</span>: T[]): T | <span class="hljs-literal">undefined</span> {
  <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>]
}
<span class="hljs-comment">// usage</span>
<span class="hljs-title function_">fn</span>([<span class="hljs-number">1</span>]) <span class="hljs-comment">// 未明确指定T</span>
<span class="hljs-comment">// or</span>
fn&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;([<span class="hljs-string">&#x27;s&#x27;</span>]) <span class="hljs-comment">// 明确指定T</span>
</code></pre>
<p>必须包含的属性或值</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> f&lt;<span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> { <span class="hljs-attr">k</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-attr">a</span>: <span class="hljs-title class_">Type</span>, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> {
  <span class="hljs-keyword">return</span> a
}
<span class="hljs-comment">// 在参数中尽量写简短的数据类型</span>
</code></pre>
<p>可选参数</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> (<span class="hljs-params">x?: <span class="hljs-built_in">string</span></span>) {...}
</code></pre>
<p>方法重载</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">a</span>: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">boolean</span> {
  ...
  <span class="hljs-keyword">return</span> ...
}
</code></pre>
<h3 id="对象的类型">对象的类型</h3>
<pre><code class="language-ts"><span class="hljs-comment">// 匿名</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">o: {k: <span class="hljs-built_in">string</span>}</span>) {...}
<span class="hljs-comment">// 明确</span>
<span class="hljs-keyword">interface</span> O
function f(o: O) {...}
</code></pre>
<p>属性修饰符</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> P {
  <span class="hljs-attr">one</span>: <span class="hljs-built_in">string</span>
  two?: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 可选属性</span>
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">three</span>: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 只读属性</span>
  [<span class="hljs-attr">k</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Type</span> <span class="hljs-comment">// index signatures 需要放在最后</span>
}
</code></pre>
<p>可以使用<code>extends</code>扩展出新的<code>interface</code></p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> A <span class="hljs-keyword">extends</span> B,C,D {...}
</code></pre>
<p>intersection Types</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> A {...}
<span class="hljs-keyword">interface</span> B {...}
<span class="hljs-keyword">type</span> T = A &amp; B
</code></pre>
<p>在对象中使用泛型</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;T&gt; {
  <span class="hljs-attr">k</span>: T
}
<span class="hljs-keyword">let</span> <span class="hljs-attr">box</span>: <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt;
</code></pre>
<p>只读数组</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a: ReadonlyArray&lt;<span class="hljs-built_in">string</span>&gt;</span>) {...}
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[]</span>) {...}
</code></pre>
<p>tuple</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> A = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, ...<span class="hljs-built_in">boolean</span>[]]
<span class="hljs-keyword">type</span> B = [<span class="hljs-built_in">string</span>, ...<span class="hljs-built_in">boolean</span>[], <span class="hljs-built_in">number</span>]
<span class="hljs-keyword">type</span> C = [...<span class="hljs-built_in">boolean</span>[], <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]
</code></pre>
<h3 id="泛型"><a href="/language/typescript/genericType.html">泛型</a></h3>
<h3 id="从类型创建类型">从类型创建类型</h3>
<p>从已经存在的类型中通过或过滤或添加等手段生成新的类型。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>keyof</td>
<td>从对象中取出指定 key 作为枚举值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>typeof</td>
<td>获取对象的数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ReturnType</td>
<td>返回方法类型的返回值的类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TypeName[key]</td>
<td>从已经定义的 type 中取出指定 key 对应的数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>conditional types</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>infer</td>
<td>不会</td>
<td></td>
<td></td>
</tr>
<tr>
<td>distributive conditional types</td>
<td>写一个像方法的 type“表达式”。经过若干运算（如：三目运算）得到一个类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mapped types</td>
<td>从已有的类型中取出 key 再赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>template literal types</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>操作字符串 key 的方法</td>
<td><code>Uppercase&lt;T&gt; / Lowercase&lt;T&gt; / Capitalize&lt;T&gt; / Uncapitalize&lt;T&gt; / </code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">type</span> P = keyof <span class="hljs-title class_">Point</span> <span class="hljs-comment">// &#x27;x&#x27; | &#x27;b&#x27;</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a&#x27;</span>
}
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Predicate</span> = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>
<span class="hljs-keyword">type</span> K = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-title class_">Predicate</span>&gt; <span class="hljs-comment">// boolean</span>
<span class="hljs-keyword">type</span> K = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> f&gt; <span class="hljs-comment">// string</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Age</span> = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&#x27;age&#x27;</span>] <span class="hljs-comment">// number</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&#x27;age&#x27;</span> | <span class="hljs-string">&#x27;name&#x27;</span>] <span class="hljs-comment">// number | string</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Person</span>[keyof <span class="hljs-title class_">Person</span>] <span class="hljs-comment">// number | string</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">live</span>(): <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">woof</span>(): <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span> <span class="hljs-comment">// number</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MessageOf</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">message</span>: <span class="hljs-built_in">unknown</span> } ? T[<span class="hljs-string">&#x27;message&#x27;</span>] : <span class="hljs-built_in">never</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Email</span> {
  <span class="hljs-attr">messge</span>: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> {
  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Email</span>&gt; <span class="hljs-comment">// string</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Dog</span>&gt; <span class="hljs-comment">// never</span>
<span class="hljs-comment">// 不会infer</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">ToArray</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? T[] : <span class="hljs-built_in">never</span>
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">ToArray</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; <span class="hljs-comment">// string[] | number []</span>
<span class="hljs-comment">// mapping</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionsFlags</span>&lt;T&gt; = {
  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-built_in">boolean</span>
}
<span class="hljs-keyword">type</span> A = {
  <span class="hljs-attr">a</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>
  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">OptionsFlags</span>&lt;A&gt; <span class="hljs-comment">// {a: boolean; b: boolean;}</span>
<span class="hljs-comment">// mapping modifiers</span>
<span class="hljs-keyword">type</span> C&lt;T&gt; = {
  -<span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Property</span>] <span class="hljs-comment">// 减去只读</span>
}
<span class="hljs-keyword">type</span> C&lt;T&gt; = {
  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T]+?: <span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Property</span>] <span class="hljs-comment">// 增加可选</span>
}
<span class="hljs-comment">// mapping as</span>
<span class="hljs-keyword">type</span> D&lt;T&gt; = {
  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-string">`get<span class="hljs-subst">${Property}</span>`</span>]: <span class="hljs-function">() =&gt;</span> T&lt;<span class="hljs-title class_">Property</span>&gt;
}
</code></pre>
<h2 id="enum-枚举">enum 枚举</h2>
<p>列出所有可选项。<br>
它是一个真实的对象。实现了 k/v 互相映射。<br>
init 后不能改变。<br>
（既然是处理映射关系了，还不能改变。map 对象也是处理映射关系的）</p>
<pre><code class="language-ts"><span class="hljs-keyword">enum</span> D {
  <span class="hljs-title class_">Up</span> = <span class="hljs-number">1</span>, <span class="hljs-comment">// 若有明确的值，则其后的值无明确值，则递增。</span>
  <span class="hljs-title class_">Down</span>,
  <span class="hljs-title class_">Left</span>,
  <span class="hljs-title class_">Right</span>,
}
</code></pre>
<ul>
<li>若是数字，则递增。</li>
<li>若非数字，则需要明确写出每个枚举值。</li>
<li>建议不使用异构枚举。（考虑和元组、interface、type）</li>
</ul>
<h3 id="const-枚举">const 枚举</h3>
<p>在编译阶段删除该对象，且不能访问该枚举对象，只能访问该枚举对象成员。常量枚举的成员只能是常量枚举表达式，不可以使用计算值</p>
<h2 id="class">class</h2>
<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">// demo</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">G</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">one</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;one&#x27;</span>;
  _two = <span class="hljs-number">0</span>;
  [<span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span> | (<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>) <span class="hljs-comment">// 布尔值或返回布尔值的方法</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name
  }
  f (<span class="hljs-attr">p</span>: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span> {...}
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">two</span>() {<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_two</span>}
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">two</span>(<span class="hljs-params">v</span>) {<span class="hljs-variable language_">this</span>.<span class="hljs-property">_two</span> = v} <span class="hljs-comment">// 若不设置set，则默认为readonly</span>
}
<span class="hljs-comment">// implements</span>
<span class="hljs-keyword">interface</span> P {
  <span class="hljs-title function_">a</span>(): <span class="hljs-built_in">void</span>;
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> P {
  <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {...}
}
<span class="hljs-comment">// 扩展</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {...}
  <span class="hljs-comment">// 重写</span>
  <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {...}
}
<span class="hljs-comment">// member visibility</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">G</span> {
  <span class="hljs-keyword">public</span> a () {...} <span class="hljs-comment">// 可被实例访问。默认为public</span>
  <span class="hljs-keyword">protected</span> b () {...} <span class="hljs-comment">// 受保护的，只能在本类内或子类内使用。可继承。</span>
  <span class="hljs-keyword">private</span> c = <span class="hljs-number">0</span> <span class="hljs-comment">// 只能在本类内使用</span>
  <span class="hljs-keyword">static</span> d = <span class="hljs-number">0</span> <span class="hljs-comment">//  只能在本类上或其后代类上使用。</span>
  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">e</span>(): <span class="hljs-built_in">string</span> <span class="hljs-comment">// 抽象方法</span>
  <span class="hljs-comment">// 被abstract修改的方法是抽象方法，有抽象方法的class是抽象类。抽象类不能被实例化，只能其他类继承。</span>
}
<span class="hljs-comment">// 抽象类。是类的可扩展模板。</span>
</code></pre>
<h2 id="modules">modules</h2>
<p>ems</p>
<pre><code class="language-ts"><span class="hljs-comment">// 输出无变化</span>
<span class="hljs-comment">// 输入</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { A, B } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../path.ts&#x27;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> A, <span class="hljs-keyword">type</span> B } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../path.ts&#x27;</span>
</code></pre>
<p>commonjs
需要添加<code>*.d.ts</code>文件，否则 tsc 不知道类型。</p>
<pre><code class="language-ts">modules.<span class="hljs-property">export</span> {...}
<span class="hljs-keyword">let</span> {a} = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;...&#x27;</span>)
</code></pre>
<h2 id="操作类的工具方法">操作类的工具方法</h2>
<p>都是大写开头。</p>
<pre><code class="language-ts"><span class="hljs-comment">// 通式</span>
<span class="hljs-title class_">Util</span>&lt;<span class="hljs-keyword">type</span>&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Partial&lt;Type&gt;</code></td>
<td>把所有 key 设置为可选类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Required&lt;Type&gt;</code></td>
<td>把所有 key 设置为必填类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Readonly&lt;Type&gt;</code></td>
<td>把所有 key 设置为只读类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Record&lt;Keys, Type&gt;</code></td>
<td>把指定的 key 设置为 type 类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Pick&lt;Type, Keys&gt;</code></td>
<td>从 type 中取出指定的 key</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Omit&lt;Type, Keys&gt;</code></td>
<td>从 type 中去掉指定的 key</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code></td>
<td>从指定的联合类型中取消指定的联合类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Extract&lt;Type, Union&gt;</code></td>
<td>取从 type/union 的交集</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>NonNullable&lt;Type&gt;</code></td>
<td>去掉 type 中的 null/undefined</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Parameters&lt;Type&gt;</code></td>
<td>取出指定方法类型中的参数</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ConstructorParameters&lt;Type&gt;</code></td>
<td>不会</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>RetureType&lt;Type&gt;</code></td>
<td>获取方法类型的返回的数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>InstanceType&lt;Type&gt;</code></td>
<td>不会</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ThisParameter&lt;Type&gt;</code></td>
<td>不会</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>OmitThisParameter&lt;Type&gt;</code></td>
<td>不会</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ThisType&lt;Type&gt;</code></td>
<td>不会</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Uppercase&lt;Type&gt;</code></td>
<td>返回全大写</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Lowercase&lt;Type&gt;</code></td>
<td>返回全小写</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Capitalize&lt;Type&gt;</code></td>
<td>首字段大写</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Uncapitalize&lt;Type&gt;</code></td>
<td>首字段小写</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="命名空间内部模块">命名空间（内部模块）</h2>
<p>把类型放在一个文件中统一管理。<br>
把类型全部放在一个文件中。使用时从这个文件中取出。
可以防止命名冲突。当类型非常多时可以考虑这个方法。</p>
<p>esm 的模块化是命名空间的同等解决方案。会 esm 的模块化，不会 ts 的 namespace 也可以。<br>
若重复，则合并。</p>
<pre><code class="language-ts"><span class="hljs-comment">// defined</span>
<span class="hljs-keyword">namespace</span> A {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}
}
<span class="hljs-comment">// 可嵌套</span>
<span class="hljs-keyword">namespace</span> A {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">namespace</span> B {
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> {}
  }
}
<span class="hljs-comment">// 引入</span>
<span class="hljs-comment">/// &lt;reference path=&quot;name.ts&quot; /&gt;</span>
<span class="hljs-comment">// usage</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {
  <span class="hljs-attr">k</span>: A.<span class="hljs-property">C</span>
}
</code></pre>
<h3 id="别名">别名</h3>
<pre><code class="language-ts"><span class="hljs-keyword">namespace</span> N {...}
<span class="hljs-keyword">import</span> newName = N.<span class="hljs-property">K</span>
<span class="hljs-keyword">let</span> k = <span class="hljs-keyword">new</span> <span class="hljs-title function_">newName</span>()
</code></pre>
<h3 id="外部命名空间">外部命名空间</h3>
<h2 id="declaration"><a href="/language/typescript/declaration.html">Declaration</a></h2>
<p><code>*.d.ts</code>文件</p>
<h2 id="使用-ts-写一个项目">使用 ts 写一个项目</h2>
<p>ts 是一种 js 的方言。以前使用 js 怎么写项目，现在使用 ts 就怎么写项目。区别在于写一些 ts 特有的东西。如：配置文件。<br>
<a href="/typescript/demo.html">demo for ts</a></p>
<h2 id="configuration"><a href="/language/typescript/config.html">configuration</a></h2>
<p>默认配置文件：<code>path/to/file.json</code>。
详见<a href="/typescript/config.html">配置文件</a></p>
<h2 id="命令行用法"><a href="/language/typescript/tscCli.html">命令行用法</a></h2>
<h2 id="变量类型">变量类型</h2>
<p>详见<a href="/typescript/contrast.html">ts&amp;js 比对</a></p>
<h2 id="principle">principle</h2>
<p>此包的处理逻辑。</p>
<h3 id="uml">uml</h3>
<pre><code>
</code></pre>
<h2 id="init-ts-project"><a href="/language/typescript/initTsProject.html">init ts project</a></h2>
<h2 id="init-ts--react-project"><a href="/language/typescript/initTsReactProject.html">init ts &amp; react project</a></h2>
<h2 id="ts--rollup"><a href="/builder/rollup/ts&amp;rollup.html">ts &amp; rollup</a></h2>
<h2 id="todo">todo</h2>
<h3 id="interface--type">interface &amp; type</h3>
<table>
<thead>
<tr>
<th>interface</th>
<th>type</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义数据结构</td>
<td>定义数据结构</td>
</tr>
<tr>
<td>混合类型<code>I &amp; I</code></td>
<td>混合类型<code>T &amp; T</code></td>
</tr>
<tr>
<td>可选属性<code>key?: type</code></td>
<td>可选属性<code>key?: type</code></td>
</tr>
<tr>
<td>索引类型<code>[key: type]</code></td>
<td>索引类型<code>[key: type]</code></td>
</tr>
<tr>
<td>用于类的 implements</td>
<td>用于类的 implements</td>
</tr>
<tr>
<td>-</td>
<td>定义类型的别名</td>
</tr>
<tr>
<td>扩展接口<code>interface A extends B</code></td>
<td>扩展类型<code>type A = B &amp; C</code></td>
</tr>
<tr>
<td>扩展类<code>interface A extends ClassName {...}</code></td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="dts文件如何工作"><code>*.d.ts</code>文件如何工作？</h3>
<ol>
<li><code>*.d.ts</code>是声明文件。声明 api/代码结构等。一般用于：在引用了外部 js 代码时需要用声明文件描述 api 等。一般由代码生成，不是手动编写的。</li>
<li>编写好<code>*.d.ts</code>后发布到<code>@types orgnizatio</code></li>
<li>使用<code>npm i -s @type/xxx</code>安装。</li>
<li>在<code>*.js</code>的同级编写<code>*.d.ts</code>。</li>
<li>使用<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>引入其他声明。</li>
<li>有此文件后可在编辑器中进行溯源。</li>
<li>写<code>*.js / *.d.ts</code>还不如写<code>*.ts</code>.</li>
</ol>
<h3 id="ts--js">ts &amp; js</h3>
<p>ts 就是为 js 增加了很多类型。但是又不承认，非说 ts 是 js 的超集。</p>
<ul>
<li>定义对象中的方法时使用<code>:</code></li>
<li>class 可以不实现全 interface.</li>
</ul>
<h3 id="如何写一个-ts">如何写一个 ts</h3>
<p>ts 团队融入了很多强类型语言的东西。如注解(java)、装饰器(java/python)、类型文件（c）。<br>
把 ts 语言解构后整理为 js 语言。</p>
<p>为什么我写不出来：</p>
<ul>
<li>不会这么多语言。</li>
<li>不会语法分析、词法分析（ast）。</li>
</ul>
<h3 id="ts-兼容-js-包">ts 兼容 js 包</h3>
<p>ts 出现以前 js 已经存在好多年了。行业中已经存在好多 js 包。ts 团队为了让 ts/vscode 兼容已经存在的 js 包。创建了在配置文件中设置<code>*.d.ts</code>文件的选项。还创建了<code>@types/*</code>的私有包，号召大家一起维护。</p>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>