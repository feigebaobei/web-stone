<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>TypeScript</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="typescript">TypeScript</h1>
<h2 id="overview">overview</h2>
<blockquote>
<p>简称 ts<br>
ts 是强类型语言 js 是弱类型语言<br>
ts 比 js 更强大。ts要求coder按ts的要求写代码，然后ts经过转化为js。看起来像是ts更强大的样子。已经有很多前端项目使用此语言了。<br>
ts就是js加上了类型的语言。
ts 是静态类型检测器。静态类型检测能力比 flow 更强大。<br>
它就是强类型的 js。它的所有功能都是为了类型服务的。<br>
ts 把 interface/type 都叫做类型<br>
它是编写代码的一种方式。可以使用 js/也可以使用 ts.ts 没有宣传的那么重要。它只是为 js 赋予了强类型。还需要把 ts 文件转换为 js 文件。如果 js 未来支持强类型了。ts 也就无存在的意义了。<br>
从设计 （uml） 到代码比 js 平滑。<br>
ts 的类型可以用于防御式编程</p>
</blockquote>
<h3 id="feature">feature</h3>
<ul>
<li>类型注解</li>
<li>类型推断</li>
<li>在开发过程中发现潜在问题（根据类型发现的）。</li>
<li>静态类型检测</li>
<li>类型提示（在 vscode 中）</li>
<li>命令行工具 tsc</li>
<li>可以用于类型检测，不能用于编写处理逻辑。</li>
</ul>
<h2 id="install">install</h2>
<p><code>npm i -g typescript</code><br>
该包是要 ts 语言的转译器。在命令行中使用<code>tsc</code>调用转译功能。这是一个命令行工具居然没有以<code>-cli</code>结尾。可能是不仅包括命令行工具。<br>
安装后可在命令行中使用<code>tsc</code>。</p>
<h2 id="usage">usage</h2>
<p>dome 详见<a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html">官网</a></p>
<pre><code class="language-ts"><span class="hljs-comment">// 单例模式</span>
<span class="hljs-comment">// define</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">Demo</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>()
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>
  }
}
<span class="hljs-comment">// usage</span>
<span class="hljs-title class_">Demo</span>.<span class="hljs-title function_">getInstance</span>() <span class="hljs-comment">// instance</span>
</code></pre>
<p>使用示例：</p>
<pre><code class="language-ts"><span class="hljs-comment">// 使用interface</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaintOptions</span>&lt;T&gt; {
  <span class="hljs-attr">shape</span>: <span class="hljs-built_in">string</span>;
  xPos?: <span class="hljs-built_in">number</span>;
  yPos?: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">resident</span>: { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };
  <span class="hljs-attr">age</span>: <span class="hljs-number">2</span>;
  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: T;
}
<span class="hljs-keyword">type</span> A&lt;T&gt; = <span class="hljs-title class_">PaintOptions</span>&lt;T&gt; &amp; B
<span class="hljs-keyword">let</span> a = <span class="hljs-title class_">PaintOptions</span>&lt;<span class="hljs-built_in">string</span>&gt;

<span class="hljs-comment">// 使用方法</span>
<span class="hljs-keyword">function</span> identity&lt;<span class="hljs-title class_">Type</span>&gt;(<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> {
  <span class="hljs-keyword">return</span> arg;
}
<span class="hljs-comment">// fn &amp; interface</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">fn</span>: I = <span class="hljs-function">() =&gt;</span> {...}

<span class="hljs-comment">// use class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GN</span>&lt;T&gt; {
    <span class="hljs-attr">value</span>: T,
    <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;
}
<span class="hljs-keyword">let</span> gn = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">GN</span>&lt;<span class="hljs-built_in">string</span>&gt;()
</code></pre>
<h3 id="使用命令行">使用命令行</h3>
<p>把 ts 转化为 js。</p>
<pre><code class="language-shell">tsc hello.ts
</code></pre>
<h2 id="编译器">编译器</h2>
<ul>
<li><a href="/babel/index.html">babel</a></li>
<li>swc</li>
<li>sucrase</li>
</ul>
<h2 id="错误提示">错误提示</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>static type-checking</td>
<td>类型错误</td>
<td></td>
<td></td>
</tr>
<tr>
<td>non-exception failure</td>
<td>类型与期望值不同</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="数据类型">数据类型</h2>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>number</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>any</td>
<td></td>
<td>当 ts 不能推断出数据类型时，使用 any 类型。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>union</td>
<td></td>
<td>联合类型</td>
<td>列出允许的数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>null</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>undefined</td>
<td></td>
<td>也叫 void</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>enums</td>
<td></td>
<td>枚举。列出具体的可选的值。它是真实的对象。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bigint</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>symbol</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>unknown</td>
<td></td>
<td>代表 any 数据。与 any 类型相似。unknown 比 any 更安全。使用时需要类型断言。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>never</td>
<td></td>
<td>永远不会执行到的对象类型。当方法返回 never 时表示抛出一个错误、或打断执行方法。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Function</td>
<td></td>
<td>它与<code>() =&gt; {}</code>不同。</td>
<td>ts中数据类型是Funtion.j中的数据类型是function</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ReadonlyArray</td>
<td></td>
<td>使数组只读</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tuple</td>
<td></td>
<td>明确数组中对应下标的数据的类型</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>generic types</code></td>
<td></td>
<td>泛型</td>
<td>``</td>
<td></td>
<td></td>
</tr>
<tr>
<td>object</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h3 id="使用示例">使用示例</h3>
<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;a&#x27;</span>
<span class="hljs-keyword">type</span> A = <span class="hljs-string">`start<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>`</span><span class="hljs-comment">// 指定字符串开头的类型。指定结尾，同理。</span>
<span class="hljs-keyword">let</span> d = <span class="hljs-string">&#x27;a&#x27;</span>         <span class="hljs-comment">// literal types</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {<span class="hljs-title function_">clog</span>(p)}
<span class="hljs-comment">// (p: string) =&gt; void</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Fn</span> <span class="hljs-comment">// todo</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Id</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Abc</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>
}
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeKing</span> {
  <span class="hljs-title class_">Circle</span>,
  <span class="hljs-title class_">Square</span> = <span class="hljs-string">&#x27;abc&#x27;</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Circle</span> {
  <span class="hljs-attr">kind</span>: <span class="hljs-title class_">ShapeKing</span>.<span class="hljs-property">Circle</span>
  <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span>
}
</code></pre>
<h3 id="类型范围缩小">类型范围缩小</h3>
<p>经常在项目中使用到。</p>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th>思路</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>等号判断</td>
<td><code>a === b </code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>in</td>
<td><code>key in obj</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>instanceof</td>
<td><code>it instanceof p</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>as 类型断言</td>
<td><code>param as T</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>断言unions</td>
<td><code>param === 'value'</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>穷举类型</td>
<td>使用switch-case根据数据类型分别处理</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h3 id="function">Function</h3>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> fn = <span class="hljs-function">(<span class="hljs-params">p: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>
<span class="hljs-keyword">type</span> D = {
  <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>
  (<span class="hljs-attr">p</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 注意这里使用 :</span>
}
<span class="hljs-keyword">type</span> F = {
  <span class="hljs-keyword">new</span> (<span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>): T <span class="hljs-comment">// 用于new命令调用</span>
}
<span class="hljs-comment">// 结合泛型一起使用</span>
<span class="hljs-keyword">function</span> fn&lt;T&gt;(<span class="hljs-attr">p</span>: T[]): T | <span class="hljs-literal">undefined</span> { <span class="hljs-keyword">return</span> p[<span class="hljs-number">0</span>] }
<span class="hljs-comment">// 指定泛型中必须要包含指定的类型</span>
<span class="hljs-keyword">function</span> f&lt;T <span class="hljs-keyword">extends</span> {<span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>}&gt;(<span class="hljs-attr">p</span>: T): T {...}
<span class="hljs-comment">// 可选参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x?: <span class="hljs-built_in">number</span></span>) {...}
<span class="hljs-comment">// 方法重载</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: T[]</span>): T {...}
</code></pre>
<h3 id="对象的类型">对象的类型</h3>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
}
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Man</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">string</span>
}
<span class="hljs-comment">// 是否有; 由编写格式决定</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Abc</span> {
  <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">b</span>: <span class="hljs-title class_">Person</span>
  c?: <span class="hljs-built_in">string</span>            <span class="hljs-comment">// 可选参数</span>
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">d</span>: <span class="hljs-built_in">boolean</span>   <span class="hljs-comment">// 只读参数</span>
  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>    <span class="hljs-comment">// 限制key的类型。它必须在最后</span>
}
<span class="hljs-keyword">interface</span> A <span class="hljs-keyword">extends</span> B {...}
<span class="hljs-keyword">interface</span> A <span class="hljs-keyword">extends</span> B, C, D {...} <span class="hljs-comment">// A接口同时有B/C/D的数据再增加新定义的数据</span>
<span class="hljs-keyword">interface</span> A &amp; B
</code></pre>
<h3 id="interface">interface</h3>
<ul>
<li>可以基于别的 interface 扩展（也被称为继承）。</li>
<li>类实现接口前，接口必须指定所有属性。类可以定义不在接口内的属性。</li>
<li>接口只能约束类的 public 成员。</li>
<li>接口不能约束构造函数</li>
<li>接口可以继承类。<code>interface A extends ClassName {}</code></li>
<li>可以声明合并。</li>
</ul>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>扩展</td>
<td><code>interface A extends B</code></td>
<td>基于B扩展A</td>
</tr>
<tr>
<td></td>
<td>交叉</td>
<td><code>type A = B &amp; C</code></td>
<td>A是B、C的交集</td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> A <span class="hljs-keyword">extends</span> B {
  <span class="hljs-attr">k</span>: <span class="hljs-built_in">number</span>
}
<span class="hljs-keyword">type</span> A = B &amp; C
<span class="hljs-comment">// 结合泛型</span>
<span class="hljs-keyword">interface</span> B&lt;T&gt; {
  <span class="hljs-comment">// 定义类型</span>
  <span class="hljs-attr">k</span>: T
}
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: B&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-comment">// 使用类型</span>
</code></pre>
<p>派生类中具有不同参数类型的重写方法</p>
<ul>
<li>在派生类中使用联合类型，然后再经过类型转换后调用基类的方法。</li>
<li>使用 2 个派生类分别定义相同方法。</li>
<li>只在派生类中定义。</li>
</ul>
<h3 id="泛型">泛型</h3>
<p>稍有一点抽象思维就能理解、使用泛型。
类型的变量</p>
<pre><code class="language-ts"><span class="hljs-comment">// 定义</span>
<span class="hljs-keyword">function</span> f&lt;T&gt;(<span class="hljs-attr">p</span>: T): T {...}
<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">mf</span>: &lt;<span class="hljs-built_in">string</span>&gt;<span class="hljs-function">(<span class="hljs-params">p: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span> = f
<span class="hljs-comment">// 使用interface定义后再使用</span>
<span class="hljs-keyword">interface</span> G {
  &lt;T&gt;(<span class="hljs-attr">p</span>: T): T
}
<span class="hljs-keyword">let</span> <span class="hljs-attr">f</span>: G = &lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {...}
<span class="hljs-comment">// class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T&gt; {
  <span class="hljs-attr">k</span>: T
}
</code></pre>
<h3 id="union--enum"><a href="/language/typescript/union&amp;enum.html">union &amp; enum</a></h3>
<h3 id="any--unknown--never">any &amp; unknown &amp; never</h3>
<table>
<thead>
<tr>
<th></th>
<th>any</th>
<th>unknown</th>
<th>never</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>任意类型</td>
<td>不知道类型</td>
<td>永不类型</td>
</tr>
<tr>
<td></td>
<td></td>
<td>所有基础类型的父类型</td>
<td></td>
</tr>
<tr>
<td></td>
<td>可以接收任意类型的值</td>
<td>可以接收任意类型的值。（因为父类型的缘故）</td>
<td>抛出异常的函数或永远不会返回的函数的返回值</td>
</tr>
<tr>
<td></td>
<td>不做类型检测</td>
<td>断言类型后才能使用</td>
<td></td>
</tr>
<tr>
<td></td>
<td>可以赋值给明确且匹配类型的变量</td>
<td>不可直接赋值给非 unknown 变量的值，加上类型断言才可以。</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="type--interface-不同"><a href="/language/typescript/type&amp;interface.html">type &amp; interface 不同</a></h3>
<h2 id="操作类型">操作类型</h2>
<p>都是大写开头。</p>
<pre><code class="language-ts"><span class="hljs-comment">// 通式</span>
<span class="hljs-title class_">Util</span>&lt;<span class="hljs-keyword">type</span>&gt;
</code></pre>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>说明</th>
<th>简写</th>
<th>说明</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>keyof ObjT</td>
<td>得到对象类型的key组成的union。没有valueof</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>typeof AnyT</td>
<td>得到指定变量的类型</td>
<td>这个好象js里的typeof</td>
<td></td>
</tr>
<tr>
<td>indexed access types</td>
<td></td>
<td>从对象类型中获得指定key的类型</td>
<td><code>type A = ObjT[&quot;key&quot;]</code></td>
<td></td>
</tr>
<tr>
<td>conditional types</td>
<td></td>
<td><code>type A = condition ? B : C</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Awaited&lt;T&gt;</code></td>
<td>解包Promise后的数据类型。用于then方法。</td>
<td><code>type B = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt; // type B = number</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Partial&lt;T&gt;</code></td>
<td>T类型的所有字段设置为可选字段</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Required&lt;T&gt;</code></td>
<td>T类型的所有字段设置为必填字段</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Readonly&lt;T&gt;</code></td>
<td>T类型的所有字段设置为只读字段</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Record&lt;Keys, T&gt;</code></td>
<td>设置一个对象类型的key类型为Keys，值的类型为T</td>
<td>`type C = 'ca'</td>
<td>'cb'; let a: Record(C, T); =&gt; a: {ca: T, cb: T}`</td>
</tr>
<tr>
<td></td>
<td><code>Pick&lt;T, Keys&gt;</code></td>
<td>从T类型中提取Keys的类型</td>
<td>`type T = Pick&lt;A, 'a'</td>
<td>'b'&gt;; =&gt; T: {a: xx, b: yy}`</td>
</tr>
<tr>
<td></td>
<td><code>Omit&lt;T, Keys&gt;</code></td>
<td>从T类型中删除Keys的类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code></td>
<td>从联合类型中删除指定成员</td>
<td><code>type A = Exclude&lt;'a' | 'b' | 'c', 'a'&gt;; =&gt; type A = 'b' | 'c'</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Extract&lt;T, Union&gt;</code></td>
<td>从T中取出联合类型中的类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>NonNullable&lt;T&gt;</code></td>
<td>排除T类型中的null/undefined</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Parameters&lt;T&gt;</code></td>
<td>返回T类型的参数，返回值是tuple类型。T类型是方法的类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>ConstructorParameters&lt;T&gt;</code></td>
<td>返回构造方法的参数。返回值是tuple类型。</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>ReturnType&lt;T&gt;</code></td>
<td>返回T类型的返回值的类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>InstanceType&lt;T&gt;</code></td>
<td>返回构造函数的类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>ThisParameterType&lt;T&gt;</code></td>
<td>返回this参数的类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>OmitThisParameter&lt;T&gt;</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>ThisType&lt;T&gt;</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>DeepPartial&lt;T&gt;</code></td>
<td>返回深度的t里的所有属性为可选的类型</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="class">class</h2>
<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> {
  <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> <span class="hljs-comment">// 先声明类型再使用</span>
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">_d</span>: <span class="hljs-built_in">boolean</span>
  <span class="hljs-comment">// [s: string]: boolean | ((s: string) =&gt; boolean); // 索引签名</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span></span>) <span class="hljs-comment">// 可以重载</span>
  {
    <span class="hljs-variable language_">super</span>()
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a || <span class="hljs-string">&#x27;str&#x27;</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = <span class="hljs-number">0</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_d</span> = <span class="hljs-literal">true</span>
  }
  <span class="hljs-title function_">f</span>(<span class="hljs-attr">p</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> {...}
  <span class="hljs-comment">// 存取修饰符</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">d</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_d</span>
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">d</span>(<span class="hljs-params">b: <span class="hljs-built_in">boolean</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_d</span> = b
  }
  <span class="hljs-comment">// 成员可见性</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) {...}      <span class="hljs-comment">// 默认值。可被任何方式访问</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">h</span>(<span class="hljs-params"></span>) {...}   <span class="hljs-comment">// 只能在当前类内部访问和其子类内部访问。</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">i</span>(<span class="hljs-params"></span>) {...}     <span class="hljs-comment">// 只能在当前类内部访问</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">k</span>(<span class="hljs-params"></span>) {...}      <span class="hljs-comment">// 静态方法。属于js范围。</span>
  # <span class="hljs-title function_">j</span>(<span class="hljs-params"></span>) {...}           <span class="hljs-comment">// 是static的简写</span>
}
<span class="hljs-comment">// class 实现 interface</span>
<span class="hljs-keyword">interface</span> T {
  <span class="hljs-title function_">a</span>(): <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> T {
  <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {...}
}
<span class="hljs-comment">// 可以继承内置的对象</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">m:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">super</span>(m)
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">MsgError</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)
  }
  <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`hi <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.message}</span>`</span>
  }
}
<span class="hljs-comment">// 泛型</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&lt;T&gt; {
  <span class="hljs-attr">a</span>: T
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">p: T</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = p
  }
}
<span class="hljs-comment">// 抽象类 不能实例化，可以被继承。</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">f</span>(): <span class="hljs-built_in">string</span>
}
</code></pre>
<p>这种限制只作用于<code>*.ts</code></p>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th>种类</th>
<th></th>
<th>当前类</th>
<th>后代类</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>公开访问</td>
<td>public</td>
<td>公开</td>
<td>v</td>
<td>v</td>
<td>v</td>
</tr>
<tr>
<td>只能在当前类内部访问和其子类内部访问</td>
<td>protected</td>
<td>受保护的</td>
<td>v</td>
<td>v</td>
<td>x</td>
</tr>
<tr>
<td>只能在类的内部访问</td>
<td>private</td>
<td>私有的</td>
<td>v</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>这是一个js语法。只能被当前类直接访问</td>
<td>static</td>
<td>静态的</td>
<td>-</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<p>三者都可以做为class的基础进行扩展。<br>
实际开发中使用interface更多些。</p>
<table>
<thead>
<tr>
<th></th>
<th>type</th>
<th>interface</th>
<th>abstract</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="modules">modules</h2>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> S = <span class="hljs-built_in">string</span>
<span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">a</span>: <span class="hljs-built_in">boolean</span>
}
<span class="hljs-keyword">export</span> { S, A }
<span class="hljs-keyword">import</span> { S, A } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file&#x27;</span>
</code></pre>
<h3 id="缩小类型范围">缩小类型范围</h3>
<ul>
<li>typeof 会返回 8 种结果<code>string / number / bigint / boolean / symbol / undefined / object / function</code>。其中<code>null</code>，它被认为是<code>object</code>。与 js 的基本数据类型相比。多了<code>function</code>。</li>
<li>真值判断。ts 把<code>0 / NaN / '' / 0n / null / undefined</code>认为是假值。</li>
<li>相等判断。使用<code>== / != / === / !==</code></li>
<li>使用<code>in</code>判断。如：<code>if (key in obj) {...}</code></li>
<li>实例判断 <code>intance instanceof Consturctor</code></li>
<li>变量的数据类型与赋的值的数据类型不同时，不能赋值。</li>
<li>分数据类型控制分支。<code>switch(p) {case 'k': ...</code></li>
<li>显示类型转换。</li>
<li>使用类型断言。如：<code>(params as number)</code>。优先使用以上方法。</li>
<li>枚举值判断。</li>
</ul>
<h3 id="方法的类型">方法的类型</h3>
<pre><code class="language-ts"><span class="hljs-comment">// 定义方法的接口</span>
<span class="hljs-title class_">Interface</span> <span class="hljs-title class_">SeachFn</span> {
  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">p</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>) {
  <span class="hljs-title function_">p</span>(<span class="hljs-string">&#x27;str&#x27;</span>)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)
}
</code></pre>
<p>定义方法的类型。<br>
方法也是一个对象。即：方法可以有自己的属性。</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">DF</span> = {
  <span class="hljs-attr">desc</span>: <span class="hljs-built_in">string</span>
  (<span class="hljs-attr">p</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 这里使用 : 不是 =&gt;</span>
  <span class="hljs-comment">// construct signatures</span>
  <span class="hljs-keyword">new</span> (<span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>
}
</code></pre>
<p>方法与泛型结合使用</p>
<pre><code class="language-ts"><span class="hljs-comment">// defined</span>
这里指定会用到的泛型
这是使用指定的泛型
<span class="hljs-keyword">function</span> fn&lt;T&gt;(<span class="hljs-attr">arr</span>: T[]): T | <span class="hljs-literal">undefined</span> {
  <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>]
}
<span class="hljs-comment">// usage</span>
<span class="hljs-title function_">fn</span>([<span class="hljs-number">1</span>]) <span class="hljs-comment">// 未明确指定T</span>
<span class="hljs-comment">// or</span>
fn&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;([<span class="hljs-string">&#x27;s&#x27;</span>]) <span class="hljs-comment">// 明确指定T</span>
</code></pre>
<p>必须包含的属性或值</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> f&lt;<span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> { <span class="hljs-attr">k</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-attr">a</span>: <span class="hljs-title class_">Type</span>, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> {
  <span class="hljs-keyword">return</span> a
}
<span class="hljs-comment">// 在参数中尽量写简短的数据类型</span>
</code></pre>
<p>可选参数</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> (<span class="hljs-params">x?: <span class="hljs-built_in">string</span></span>) {...}
</code></pre>
<p>方法重载</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-attr">a</span>: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">boolean</span> {
  ...
  <span class="hljs-keyword">return</span> ...
}
</code></pre>
<h3 id="对象的类型-1">对象的类型</h3>
<pre><code class="language-ts"><span class="hljs-comment">// 匿名</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">o: {k: <span class="hljs-built_in">string</span>}</span>) {...}
<span class="hljs-comment">// 明确</span>
<span class="hljs-keyword">interface</span> O
function f(o: O) {...}
</code></pre>
<p>属性修饰符</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> P {
  <span class="hljs-attr">one</span>: <span class="hljs-built_in">string</span>
  two?: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 可选属性</span>
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">three</span>: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 只读属性</span>
  [<span class="hljs-attr">k</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Type</span> <span class="hljs-comment">// index signatures 需要放在最后</span>
}
</code></pre>
<p>可以使用<code>extends</code>扩展出新的<code>interface</code></p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> A <span class="hljs-keyword">extends</span> B,C,D {...}
</code></pre>
<p>intersection Types</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> A {...}
<span class="hljs-keyword">interface</span> B {...}
<span class="hljs-keyword">type</span> T = A &amp; B
</code></pre>
<p>在对象中使用泛型</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;T&gt; {
  <span class="hljs-attr">k</span>: T
}
<span class="hljs-keyword">let</span> <span class="hljs-attr">box</span>: <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt;
</code></pre>
<p>只读数组</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a: ReadonlyArray&lt;<span class="hljs-built_in">string</span>&gt;</span>) {...}
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[]</span>) {...}
</code></pre>
<p>tuple</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> A = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, ...<span class="hljs-built_in">boolean</span>[]]
<span class="hljs-keyword">type</span> B = [<span class="hljs-built_in">string</span>, ...<span class="hljs-built_in">boolean</span>[], <span class="hljs-built_in">number</span>]
<span class="hljs-keyword">type</span> C = [...<span class="hljs-built_in">boolean</span>[], <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]
</code></pre>
<h3 id="泛型-1"><a href="/language/typescript/genericType.html">泛型</a></h3>
<h3 id="从类型创建类型">从类型创建类型</h3>
<p>从已经存在的类型中通过或过滤或添加等手段生成新的类型。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>keyof</td>
<td>从对象中取出指定 key 作为枚举值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>typeof</td>
<td>获取对象的数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ReturnType</td>
<td>返回方法类型的返回值的类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TypeName[key]</td>
<td>从已经定义的 type 中取出指定 key 对应的数据类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>conditional types</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>infer</td>
<td>不会</td>
<td></td>
<td></td>
</tr>
<tr>
<td>distributive conditional types</td>
<td>写一个像方法的 type“表达式”。经过若干运算（如：三目运算）得到一个类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mapped types</td>
<td>从已有的类型中取出 key 再赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>template literal types</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>操作字符串 key 的方法</td>
<td><code>Uppercase&lt;T&gt; / Lowercase&lt;T&gt; / Capitalize&lt;T&gt; / Uncapitalize&lt;T&gt; / </code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">type</span> P = keyof <span class="hljs-title class_">Point</span> <span class="hljs-comment">// &#x27;x&#x27; | &#x27;b&#x27;</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a&#x27;</span>
}
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Predicate</span> = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>
<span class="hljs-keyword">type</span> K = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-title class_">Predicate</span>&gt; <span class="hljs-comment">// boolean</span>
<span class="hljs-keyword">type</span> K = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> f&gt; <span class="hljs-comment">// string</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Age</span> = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&#x27;age&#x27;</span>] <span class="hljs-comment">// number</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&#x27;age&#x27;</span> | <span class="hljs-string">&#x27;name&#x27;</span>] <span class="hljs-comment">// number | string</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Person</span>[keyof <span class="hljs-title class_">Person</span>] <span class="hljs-comment">// number | string</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">live</span>(): <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">woof</span>(): <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span> <span class="hljs-comment">// number</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MessageOf</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">message</span>: <span class="hljs-built_in">unknown</span> } ? T[<span class="hljs-string">&#x27;message&#x27;</span>] : <span class="hljs-built_in">never</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Email</span> {
  <span class="hljs-attr">messge</span>: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> {
  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Email</span>&gt; <span class="hljs-comment">// string</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Dog</span>&gt; <span class="hljs-comment">// never</span>
<span class="hljs-comment">// 不会infer</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">ToArray</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? T[] : <span class="hljs-built_in">never</span>
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">ToArray</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; <span class="hljs-comment">// string[] | number []</span>
<span class="hljs-comment">// mapping</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionsFlags</span>&lt;T&gt; = {
  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-built_in">boolean</span>
}
<span class="hljs-keyword">type</span> A = {
  <span class="hljs-attr">a</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>
  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>
}
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">OptionsFlags</span>&lt;A&gt; <span class="hljs-comment">// {a: boolean; b: boolean;}</span>
<span class="hljs-comment">// mapping modifiers</span>
<span class="hljs-keyword">type</span> C&lt;T&gt; = {
  -<span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Property</span>] <span class="hljs-comment">// 减去只读</span>
}
<span class="hljs-keyword">type</span> C&lt;T&gt; = {
  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T]+?: <span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Property</span>] <span class="hljs-comment">// 增加可选</span>
}
<span class="hljs-comment">// mapping as</span>
<span class="hljs-keyword">type</span> D&lt;T&gt; = {
  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-string">`get<span class="hljs-subst">${Property}</span>`</span>]: <span class="hljs-function">() =&gt;</span> T&lt;<span class="hljs-title class_">Property</span>&gt;
}
</code></pre>
<h2 id="enum-枚举">enum 枚举</h2>
<p>列出所有可选项。<br>
它是一个真实的对象。实现了 k/v 互相映射。<br>
init 后不能改变。<br>
（既然是处理映射关系了，还不能改变。map 对象也是处理映射关系的）</p>
<pre><code class="language-ts"><span class="hljs-keyword">enum</span> D {
  <span class="hljs-title class_">Up</span> = <span class="hljs-number">1</span>, <span class="hljs-comment">// 若有明确的值，则其后的值无明确值时递增。</span>
  <span class="hljs-title class_">Down</span>,
  <span class="hljs-title class_">Left</span>,
  <span class="hljs-title class_">Right</span>,
}
</code></pre>
<ul>
<li>若是数字，则递增。</li>
<li>若非数字，则需要明确写出每个枚举值。</li>
<li>建议不使用异构枚举。（考虑和元组、interface、type）</li>
</ul>
<h3 id="const-枚举">const 枚举</h3>
<p>在编译阶段删除该对象，且不能访问该枚举对象，只能访问该枚举对象成员。常量枚举的成员只能是常量枚举表达式，不可以使用计算值</p>
<h2 id="class-1">class</h2>
<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">// demo</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">G</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">one</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;one&#x27;</span>;
  _two = <span class="hljs-number">0</span>;
  [<span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span> | (<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>) <span class="hljs-comment">// 布尔值或返回布尔值的方法</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name
  }
  f (<span class="hljs-attr">p</span>: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span> {...}
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">two</span>() {<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_two</span>}
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">two</span>(<span class="hljs-params">v</span>) {<span class="hljs-variable language_">this</span>.<span class="hljs-property">_two</span> = v} <span class="hljs-comment">// 若不设置set，则默认为readonly</span>
}
<span class="hljs-comment">// implements</span>
<span class="hljs-keyword">interface</span> P {
  <span class="hljs-title function_">a</span>(): <span class="hljs-built_in">void</span>;
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> P {
  <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {...}
}
<span class="hljs-comment">// 扩展</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {...}
  <span class="hljs-comment">// 重写</span>
  <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {...}
}
<span class="hljs-comment">// member visibility</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">G</span> {
  <span class="hljs-keyword">public</span> a () {...} <span class="hljs-comment">// 可被实例访问。默认为public</span>
  <span class="hljs-keyword">protected</span> b () {...} <span class="hljs-comment">// 受保护的，只能在本类内或子类内使用。可继承。</span>
  <span class="hljs-keyword">private</span> c = <span class="hljs-number">0</span> <span class="hljs-comment">// 只能在本类内使用</span>
  <span class="hljs-keyword">static</span> d = <span class="hljs-number">0</span> <span class="hljs-comment">//  只能在本类上或其后代类上使用。</span>
  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">e</span>(): <span class="hljs-built_in">string</span> <span class="hljs-comment">// 抽象方法</span>
  <span class="hljs-comment">// 被abstract修改的方法是抽象方法，有抽象方法的class是抽象类。抽象类不能被实例化，只能其他类继承。</span>
}
<span class="hljs-comment">// 抽象类。是类的可扩展模板。</span>
</code></pre>
<h2 id="modules-1">modules</h2>
<p>ems</p>
<pre><code class="language-ts"><span class="hljs-comment">// 输出无变化</span>
<span class="hljs-comment">// 输入</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { A, B } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../path.ts&#x27;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">type</span> A, <span class="hljs-keyword">type</span> B } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../path.ts&#x27;</span>
</code></pre>
<p>commonjs
需要添加<code>*.d.ts</code>文件，否则 tsc 不知道类型。</p>
<pre><code class="language-ts">modules.<span class="hljs-property">export</span> {...}
<span class="hljs-keyword">let</span> {a} = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;...&#x27;</span>)
</code></pre>
<h2 id="命名空间内部模块">命名空间（内部模块）</h2>
<p>把类型放在一个文件中统一管理。<br>
把类型全部放在一个文件中。使用时从这个文件中取出。
可以防止命名冲突。当类型非常多时可以考虑这个方法。</p>
<p>esm 的模块化是命名空间的同等解决方案。会 esm 的模块化，不会 ts 的 namespace 也可以。<br>
若重复，则合并。</p>
<pre><code class="language-ts"><span class="hljs-comment">// defined</span>
<span class="hljs-keyword">namespace</span> A {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}
}
<span class="hljs-comment">// 可嵌套</span>
<span class="hljs-keyword">namespace</span> A {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">namespace</span> B {
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> {}
  }
}
<span class="hljs-comment">// 引入</span>
<span class="hljs-comment">/// &lt;reference path=&quot;name.ts&quot; /&gt;</span>
<span class="hljs-comment">// usage</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {
  <span class="hljs-attr">k</span>: A.<span class="hljs-property">C</span>
}
</code></pre>
<h3 id="别名">别名</h3>
<pre><code class="language-ts"><span class="hljs-keyword">namespace</span> N {...}
<span class="hljs-keyword">import</span> newName = N.<span class="hljs-property">K</span>
<span class="hljs-keyword">let</span> k = <span class="hljs-keyword">new</span> <span class="hljs-title function_">newName</span>()
</code></pre>
<h3 id="外部命名空间">外部命名空间</h3>
<h2 id="declaration"><a href="/language/typescript/declaration.html">Declaration</a></h2>
<p><code>*.d.ts</code>文件</p>
<h2 id="使用-ts-写一个项目">使用 ts 写一个项目</h2>
<p>ts 是一种 js 的方言。以前使用 js 怎么写项目，现在使用 ts 就怎么写项目。区别在于写一些 ts 特有的东西。如：配置文件。<br>
<a href="/typescript/demo.html">demo for ts</a></p>
<h2 id="configuration"><a href="/language/typescript/config.html">configuration</a></h2>
<p>默认配置文件：<code>path/to/file.json</code>。
详见<a href="/language/typescript/config.html">配置文件</a></p>
<h2 id="命令行用法"><a href="/language/typescript/tscCli.html">命令行用法</a></h2>
<h2 id="变量类型">变量类型</h2>
<p>详见<a href="/typescript/contrast.html">ts&amp;js 比对</a></p>
<h2 id="principle">principle</h2>
<p>此包的处理逻辑。</p>
<h3 id="uml">uml</h3>
<pre><code>
</code></pre>
<h2 id="init-ts-project"><a href="/language/typescript/initTsProject.html">init ts project</a></h2>
<h2 id="init-ts--react-project"><a href="/language/typescript/initTsReactProject.html">init ts &amp; react project</a></h2>
<h2 id="ts--rollup"><a href="/builder/rollup/ts&amp;rollup.html">ts &amp; rollup</a></h2>
<h2 id="类型断言的不足">类型断言的不足</h2>
<p>或称为 ts 的不足。</p>
<ul>
<li>不能明确定义所有变量的类型。(ts 允许存在 any/unknown/never 就是佐证。)</li>
<li>然后有类型断言。类型断言只能做到代码静态检测时类型是否满足运行逻辑，不能防止实际运行时具体的值不满足运行逻辑的情况。</li>
</ul>
<h2 id="todo">todo</h2>
<h3 id="interface--type">interface &amp; type</h3>
<table>
<thead>
<tr>
<th>interface</th>
<th>type</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义数据结构</td>
<td>定义数据结构</td>
</tr>
<tr>
<td>混合类型<code>I &amp; I</code></td>
<td>混合类型<code>T &amp; T</code></td>
</tr>
<tr>
<td>可选属性<code>key?: type</code></td>
<td>可选属性<code>key?: type</code></td>
</tr>
<tr>
<td>索引类型<code>[key: type]</code></td>
<td>索引类型<code>[key: type]</code></td>
</tr>
<tr>
<td>用于类的 implements</td>
<td>用于类的 implements</td>
</tr>
<tr>
<td>-</td>
<td>定义类型的别名</td>
</tr>
<tr>
<td>扩展接口<code>interface A extends B</code></td>
<td>扩展类型<code>type A = B &amp; C</code></td>
</tr>
<tr>
<td>扩展类<code>interface A extends ClassName {...}</code></td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="dts文件如何工作"><code>*.d.ts</code>文件如何工作？</h3>
<ol>
<li><code>*.d.ts</code>是声明文件。声明 api/代码结构等。一般用于：在引用了外部 js 代码时需要用声明文件描述 api 等。一般由代码生成，不是手动编写的。</li>
<li>编写好<code>*.d.ts</code>后发布到<code>@types orgnizatio</code></li>
<li>使用<code>npm i -s @type/xxx</code>安装。</li>
<li>在<code>*.js</code>的同级编写<code>*.d.ts</code>。</li>
<li>使用<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>引入其他声明。</li>
<li>有此文件后可在编辑器中进行溯源。</li>
<li>写<code>*.js / *.d.ts</code>还不如写<code>*.ts</code>.</li>
</ol>
<h3 id="ts--js">ts &amp; js</h3>
<p>ts 就是为 js 增加了很多类型。但是又不承认，非说 ts 是 js 的超集。</p>
<ul>
<li>定义对象中的方法时使用<code>:</code></li>
<li>class 可以不实现全 interface.</li>
</ul>
<h3 id="如何写一个-ts">如何写一个 ts</h3>
<p>ts 团队融入了很多强类型语言的东西。如注解(java)、装饰器(java/python)、类型文件（c）。<br>
把 ts 语言解构后整理为 js 语言。</p>
<p>为什么我写不出来：</p>
<ul>
<li>不会这么多语言。</li>
<li>不会语法分析、词法分析（ast）。</li>
</ul>
<h3 id="ts-兼容-js-包">ts 兼容 js 包</h3>
<p>ts 出现以前 js 已经存在好多年了。行业中已经存在好多 js 包。ts 团队为了让 ts/vscode 兼容已经存在的 js 包。创建了在配置文件中设置<code>*.d.ts</code>文件的选项。还创建了<code>@types/*</code>的私有包，号召大家一起维护。</p>
<h2 id="todo-1">todo</h2>
<p>修改或覆盖属性的值的类型</p>
<pre><code>type ValueOf&lt;T&gt; = T[keyof T]

interface B extends Omit&lt;A, 'list'&gt; {
    list: Omit&lt;ValueOf&lt;A['list']&gt;, 'sex'&gt; &amp; {
        sex: string
    }[]
}
</code></pre>
<h3 id="object--object--">Object &amp; object &amp; {}</h3>
<table>
<thead>
<tr>
<th></th>
<th>Object</th>
<th>object</th>
<th>{}</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Object 类</td>
<td>网友说无”原始值“（好像是 Object 的原型链上的值），非原始类型（undefined, null, boolean, number, bigint, string, symbol）</td>
<td>没有属性的 object</td>
</tr>
<tr>
<td></td>
<td></td>
<td>ts 创造了一个与原始类型相当的 object 类型。</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="重载">重载</h2>
<pre><code class="language-ts"><span class="hljs-comment">// 方法重载</span>
<span class="hljs-comment">// 先签名，就是定义类型</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span>, myName: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Message</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params">value: MessageType, readRecordCount: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Message</span>[]
<span class="hljs-comment">// 再实现，</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params">value: <span class="hljs-built_in">any</span>, value2: <span class="hljs-built_in">any</span></span>) {
  <span class="hljs-keyword">if</span> (xxx) {
    <span class="hljs-keyword">return</span> [...]
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> ...
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-comment">// 构造器重载</span>
  <span class="hljs-comment">// 先签名</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">p1: N, p2: N</span>)
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">p: O</span>)
  <span class="hljs-comment">// 再实现</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">paramObjOrWidth: A, height: N = <span class="hljs-number">0</span></span>) {...}
  <span class="hljs-comment">// 属性重载</span>
  <span class="hljs-comment">// 先签名</span>
  <span class="hljs-title function_">remove</span>(<span class="hljs-attr">v</span>: N): N
  <span class="hljs-title function_">remove</span>(<span class="hljs-attr">v</span>: O): O
  <span class="hljs-comment">// 再实现</span>
  <span class="hljs-title function_">remove</span>(<span class="hljs-attr">value</span>: A): A {
    <span class="hljs-keyword">return</span> ...
  }
  <span class="hljs-comment">// 先签名</span>
  <span class="hljs-attr">key</span>: N
  <span class="hljs-attr">key</span>: B
  <span class="hljs-attr">key</span>: A
  <span class="hljs-comment">// 再实现</span>
  key = <span class="hljs-number">0</span>
}
</code></pre>
<h2 id="ts-的不足">ts 的不足</h2>
<ul>
<li>允许出来类型断言。</li>
<li>允许出来 any 类型。</li>
<li>有时过于严格，有时可忽略类型错误。
<ul>
<li>var as unknown as T</li>
</ul>
</li>
<li>静态类型分析，不知道真实的数据传递。
<ul>
<li>@input() data: T</li>
</ul>
</li>
<li>不能按业务逻辑的数据流处理数据的类型。它以能识别的为起点。有可能起点就是错的。</li>
<li>从“模块”的开头开始定义数据类型。模块之间调用关系有时可以连接起来，有时不行。若正常连接则正常判断数据的类型，否则就成断点。数据类型从断点处再次开始判断类型。
<ul>
<li>如方法调用，可以连接起来。</li>
<li>如ag的模块之间传值，不可以连接起来。</li>
</ul>
</li>
<li>很明显的类型相等不能使用，需要经过处理后才能使用。代码的运行逻辑相等，必须要换编写方式才能不报类型错误。
<ul>
<li><code>{params: {...obj}}</code></li>
</ul>
</li>
<li>需要coder判断。
<ul>
<li>若this.comp?.type存在，则this.comp?.props应该是一定存在。所有写为<code>this.comp!.props</code></li>
</ul>
</li>
<li>无法与<code>Object.create(prototype,propertiesObject)</code>正常合作。识别不了这里的属性。</li>
<li>ts只管该对象是否能调用此属性，不管此属性在该对象上还是在该对象的原型链上。</li>
<li>属性的值的类型还不能与原型链上的值的类型不同。class都能继承了，类型却不能继承。（有解决它的方法）js支持属性屏蔽，但是ts的类型不支持属性屏蔽。还吹牛说ts是js的超集。ts就是js加上了类型的语言。</li>
</ul>
<p>基于以上原因，ts 不能使问题在开发阶段暴露。会增加开发阶段的开发者心智负担。</p>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>