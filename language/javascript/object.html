<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Object</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="object">Object</h1>
<ul>
<li>基础类型之一。</li>
</ul>
<pre><code>{...}
new Object(any)
</code></pre>
<p><code>Object.length</code><br>
<code>Object.prototype</code>是原型对象<br>
<code>Object.assign(target, ...source)</code><br>
把 source 上的属性复制到 target 上，并返回 target.</p>
<p><code>Object.create(proto, [propertiesObject])</code><br>
按指定的原型对象 proto、新对象的属性返回新对象。<br>
新对象的<code>__proto__</code>属性指向原型对象。<br>
默认情况下，属性是不可写（即不可重新赋值，若其值为引用类型数据，则可以修改引用类型数据的值）、可枚举和可配置的。即：</p>
<pre><code class="language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto, {
  <span class="hljs-attr">key</span>: {
    <span class="hljs-attr">value</span>: xxx,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  },
})
</code></pre>
<p><code>Object.defineProperty(obj, prop, descriptor)</code><br>
obj 目标对象
prop 目标对象的属性
descriptor { // 数据描述符
value:
writable:
enumerable:
configurable:
}
修改或定义 obj 的 prop 属性。返回该对象。</p>
<pre><code>// demo
let o = {}
Object.defineProperty(o, 'a', {
    value: 0,
    writable: true,
    enumerable: true,
    configurable: true,
})
Object.defineProperty(o, 'b', {
    enumerable: true,
    configurable: true,
    get() {
        return this.a
    },
    set(v) {
        this.a = v
    }
})
</code></pre>
<p><code>Object.defineProperties(object, props)</code><br>
object 目标对象
props: {
configurable
enumerable
writable
value
get: function() {}
set: function(v) {}
}
在一个对象上定义新的属性或修改现有属性，并返回该对象。</p>
<pre><code>var obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
  // etc. etc.
});
</code></pre>
<p><code>Object.entries(obj)</code><br>
obj
返回目标对象上可枚举的属性的键值对组成的数组。</p>
<p><code>Object.getOwnPropertyDescriptor(obj, prop)</code><br>
obj,
prop
返回指定对象的指定属性的属性描述符对象</p>
<pre><code>{
    value,
    writable
    get
    set
    configuration
    enumerable
}
</code></pre>
<p><code>Object.getOwnPropertyNames(obj)</code><br>
返回指定对象自身拥有的非<code>symbol</code>/非不可枚举（非<code>enumerable: false</code>）属性名组成的数组。</p>
<p><code>Object.getOwnPropertySymbols(obj)</code><br>
obj
返回指定对象自身的全部<code>Symbol</code>属性值组成的数组。</p>
<p><code>Object.getPrototypeOf(obj)</code><br>
返回原型对象</p>
<p><code>Object.setPrototypeOf(obj, prototype)</code><br>
调用给定对象的原型对象。</p>
<p><code>Object.is(v0, v1)</code><br>
返回是否是同一个值。<br>
<code>+0</code>和<code>-0</code>不是同一个值。</p>
<ul>
<li>两个值都是 undefined</li>
<li>两个值都是 null</li>
<li>两个值都是 true 或者都是 false</li>
<li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li>
<li>两个值指向同一个对象</li>
<li>两个值都是数字并且
<ul>
<li>都是正零 +0</li>
<li>都是负零 -0</li>
<li>都是 NaN</li>
<li>都是除零和 NaN 外的其它同一个数字</li>
</ul>
</li>
</ul>
<p><code>Object.freeze(obj)</code><br>
obj 目标对象
不可修改（value/writable/enumerable/configuration）、不能删除已有属性、不能修改该对象的原型
返回被冻结的对象
属性描述符会改变为：</p>
<pre><code>{
    configurable: false
    enumerable: true
    value: 1
    writable: false
}
</code></pre>
<p>数组的原型链中有<code>Object</code>，所以数组可以被冻结。
freeze 是浅冻结。</p>
<pre><code>// 深冻结
function deepFreeze(obj) {
    let propNames = Object.getOwnPropertyNames(obj)
    propNames.forEach(function(name) {
        let value = obj[name]
        if (typeof value === 'object' &amp;&amp; value !== null) {
            deepFreeze(value)
        }
    })
    return Object.freeze(obj)
}
</code></pre>
<p><code>Object.isFrozen(obj)</code><br>
返回是冻结
不可扩展的对象也是冻结的。</p>
<p><code>Object.preventExtensions(obj)</code><br>
返回不可扩展的对象
obj 对象上的属性描述符不会改变。</p>
<p><code>Object.isExtensible(obj)</code><br>
返回是否可扩展（即：是否可添加新属性）</p>
<p><code>Object.keys(obj)</code><br>
返回由指定对象的可枚举对象的属性组成的数组。</p>
<p><code>Object.values(obj)</code><br>
返回指定对象上可枚举属性值组成的数组。</p>
<p><code>Object.seal(obj)</code><br>
不可改变已有属性，把对象的所有属性设置为不可配置。
不可添加新属性。
返回操作后的对象。</p>
<p><code>Object.isSealed(obj)</code><br>
返回是否密封</p>
<p><code>Object#toString()</code><br>
返回对象的字符串形式</p>
<p><code>Object#toLocaleString()</code><br>
返回当前对象的本地化客串形式。</p>
<p><code>Object#valueOf()</code><br>
返回对象的原始值</p>
<p><code>Object#hasOwnProperty(prop)</code><br>
自身是否拥有指定属性</p>
<p><code>Object#isPrototypeOf(obj)</code><br>
<code>a.isPrototypeOf(b)</code><br>
返回 a 是否在 b 对象的原型链中</p>
<p><code>Object#propertyIsNumberable(prop)</code><br>
返回指定属性是否可枚举</p>
<h2 id="固定对象的方法">固定对象的方法</h2>
<table>
<thead>
<tr>
<th></th>
<th>Object.preventExtensions(obj)</th>
<th>Object.freeze(obj)</th>
<th>Object.seal(obj)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>不可扩展</td>
<td>冻结</td>
<td>密封</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>不能添加新属性</td>
<td>不能添加新属性。不可修改。</td>
<td>不可配置：不改变属性描述符。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="描述符">描述符</h2>
<table>
<thead>
<tr>
<th></th>
<th>configurable</th>
<th>enumerable</th>
<th>value</th>
<th>writable</th>
<th>get</th>
<th>set</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据描述符</td>
<td>v</td>
<td>v</td>
<td>v</td>
<td>v</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>存取描述符</td>
<td>v</td>
<td>v</td>
<td>x</td>
<td>x</td>
<td>v</td>
<td>v</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>默认值</th>
<th>用于</th>
</tr>
</thead>
<tbody>
<tr>
<td>configurable</td>
<td>是否可以删除。除 value/wriable 外的属性是否可以被修改</td>
<td>false</td>
<td>用于</td>
</tr>
<tr>
<td>enumerable</td>
<td>是否可枚举</td>
<td>false</td>
<td><code>for...in</code>/<code>Object.keys()</code></td>
</tr>
<tr>
<td>value</td>
<td>当前值</td>
<td>undefined</td>
<td></td>
</tr>
<tr>
<td>writable</td>
<td>是否可修改</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>get</td>
<td>属性的 getter 方法</td>
<td>undefined</td>
<td></td>
</tr>
<tr>
<td>set</td>
<td>属性的 setter 方法</td>
<td>undefined</td>
<td></td>
</tr>
</tbody>
</table>

            
            
        </body>
        </html>