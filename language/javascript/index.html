<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>javascript</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="javascript">javascript</h1>
<ul>
<li>(缩写：JS)是一门完备的 动态编程语言。当应用于 HTML 文档时，可为网站提供动态交互特性。由布兰登·艾克（ Brendan Eich，Mozilla 项目、Mozilla 基金会和 Mozilla 公司的联合创始人）发明。</li>
<li>它是一个面向对象的语言。它比 java 中的对象更纯粹。js 在 es5 后的有<code>class</code>，也不能说 js 中有了类。<code>class</code>的本质还是对象（<code>Object</code>）。</li>
<li>没有类，所以没有继承。有引用，没有类，引用是通过原型链实现引用。</li>
</ul>
<h1 id="引擎">引擎</h1>
<ul>
<li><a href="/language/javascript/v8.html">V8</a></li>
<li><a href="/language/javascript/javascriptCore.html">JavascriptCore</a></li>
</ul>
<h1 id="名词说明">名词说明</h1>
<p><strong>动态编程语言</strong><br>
是指可在运行阶段时执行那些在编译阶段执行的操作的编程语言。比如，在 JavaScript 中， 我们可以在程序运行时改变变量的类型，或者为一个对象增加一个新属性或者方法。<br>
<strong>对象的属性</strong><br>
对象是复杂数据类型（亦称：引用数据类型）。对象的每个 key 对应的值可以是简单数据类型也可以是复杂数据类型。作者把每个 key 对应的值都称为属性值，不论是简单数据类型还是复杂数据类型。<br>
<strong>原型对象上的方法</strong><br>
prop#method。如：<code>Promise#then</code>。</p>
<h1 id="数据类型">数据类型</h1>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Null</li>
<li>undefined</li>
<li>Object</li>
<li>Symbol</li>
<li>BigInt</li>
</ul>
<p>typeof 命令返回数据类型</p>
<h1 id="变量">变量</h1>
<h2 id="var--let--const">var &amp; let &amp; const</h2>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th>是否可以变量提升</th>
<th>作用域</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>y</td>
<td>函数级作用域</td>
<td>可多次声明</td>
<td>可多次赋值</td>
</tr>
<tr>
<td>let</td>
<td>n</td>
<td>块级作用域</td>
<td>不可多次声明</td>
<td>可多次赋值</td>
</tr>
<tr>
<td>const</td>
<td>n</td>
<td>块级作用域</td>
<td>不可多次声明</td>
<td>只能赋值一次</td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="声明--定义">声明 &amp; 定义</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>声明</td>
<td>提出变量名</td>
<td><code>var a</code></td>
</tr>
<tr>
<td>初始化</td>
<td>第一次赋值</td>
<td><code>a = 's'</code></td>
</tr>
<tr>
<td>定义</td>
<td>声明 + 初始化</td>
<td><code>var n = 0</code></td>
</tr>
</tbody>
</table>
<h2 id="变量提升">变量提升</h2>
<p>function、var 都会触发变量提升。<br>
先提升 function，再提升 var。且存在变量覆盖。</p>
<h1 id="事件"><a href="/language/javascript/event.html">事件</a></h1>
<h1 id="原型链-ppt">原型链 <a href="/confuse/jsPrototypeChain.pptx">ppt</a></h1>
<p>使用对象的<code>[[prototype]]</code>属性原型链上源的对象。
原型链中的对象使用<code>[[prototype]]</code>属性“串联”起彼此。
一条链中不能有分支。
原型链的下游对象可以访问原型链的上游对象的属性。</p>
<h2 id="new-的过程做了什么">new 的过程做了什么</h2>
<ol>
<li>var a = Object.create(Object)</li>
<li>a[[prototype]] = Foo.prototype<br>
// or<br>
// a.<strong>proto</strong> = Foo.prototype</li>
<li>Foo.call(a)</li>
<li>先创建一个实例，再把实例添加到原型链中。</li>
</ol>
<h1 id="继承"><a href="/language/javascript/inherit.html">继承</a></h1>
<h1 id="作用域链">作用域链</h1>
<p>js 在宏观上使用函数作用域，同时支持块级作用域。<br>
函数作用域。。。。<br>
块级作用域，只有<code>let</code>、<code>const</code>。</p>
<h2 id="this">this</h2>
<p>this 指向运行时（不是定义时）的上下文环境变量。</p>
<h3 id="abc">abc</h3>
<p>即<code>apply / bind / call</code>。<code>abc</code>是作者起的名字。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>执行时间</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>apply</td>
<td>fn.apply(otherThis, arrOfArgs)</td>
<td>立即执行</td>
<td>数组</td>
</tr>
<tr>
<td>call</td>
<td>fn.call(otherThis, arg0, arg1, ...)</td>
<td>立即执行</td>
<td>多个参数</td>
</tr>
<tr>
<td>bind</td>
<td>fn.bind(otherThis, arg0, arg1, ...)</td>
<td>返回一个方法</td>
<td>执行 bind 的参数追加上执行返回的方法时的参数</td>
</tr>
</tbody>
</table>
<pre><code class="language-js"><span class="hljs-comment">// 待测试</span>
<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mockBind</span> = <span class="hljs-function">(<span class="hljs-params">otherthis, ...args</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span>
  <span class="hljs-keyword">let</span> fBound = <span class="hljs-keyword">function</span> (<span class="hljs-params">...otherArgs</span>) {
    self.<span class="hljs-title function_">call</span>(otherthis, ...args, ...otherArgs)
  }
  <span class="hljs-keyword">let</span> <span class="hljs-title class_">Ft</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {}
  <span class="hljs-title class_">Ft</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
  fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ft</span>()
  <span class="hljs-keyword">return</span> fBound
}
</code></pre>
<h1 id="constructor--class">constructor &amp; class</h1>
<h2 id="constructor">constructor</h2>
<p>（特指构造方法）<br>
es5 前的产物。es6 以后一般不用。<br>
<code>inst instanceof ClassName</code></p>
<h2 id="class">class</h2>
<p>与构造函数很像。（不是构造函数的语法糖。）<br>
不能变量提升，遵守是块级作用域规则。<br>
class 可以结合<code>decorator</code>使用，构造函数不能使用<code>decorator</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> {
    <span class="hljs-title function_">constructor</span> (...params) { <span class="hljs-comment">// 可省略</span>
        <span class="hljs-comment">// super()</span>
        <span class="hljs-comment">// ...</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = params[<span class="hljs-number">0</span>] <span class="hljs-comment">// 会在实例对象上设置属性a</span>
    }
    t () {                 <span class="hljs-comment">// 会在实例对象的原型链上的上游对象class ClassName上创建t属性。t属性的值是一个方法。方法中的this遵守作用域规则。执行`instance.t()`时this指向instance对象。</span>
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>
    }
    <span class="hljs-comment">// 设置存取描述符会使此属性放在实例对象上。</span>
    get k () {...}
    set k (s) {...}
}
</code></pre>
<p>上述代码可(大致)转换为构造函数代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ClassName</span> (...params) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = params[<span class="hljs-number">0</span>]
}
<span class="hljs-title class_">ClassName</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">t</span> = funtion () {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>
}
<span class="hljs-comment">// 若要使用class则构造者是class ClassName.</span>
<span class="hljs-comment">// 若要使用构造器则构造者是方法ClassName</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
    <span class="hljs-title function_">constructor</span> () {...} <span class="hljs-comment">// 可省略</span>
    get p () {...}       <span class="hljs-comment">// 使用存取描述符</span>
    set p (v) {...}
    [methodName] () {}   <span class="hljs-comment">// 使用属性表达式</span>
    <span class="hljs-keyword">static</span> s () {}       <span class="hljs-comment">// 静态属性</span>
    <span class="hljs-keyword">static</span> sa = <span class="hljs-number">0</span>       <span class="hljs-comment">// 静态属性</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> {     <span class="hljs-comment">// 类A继承类B</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">super</span>()
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>静态方法的本质是定义在构造方法上的方法。所以有人理解为不使用实例化就能使用的方法。也有人理解为不能在实例上使用，只能在类上使用的方法。<br>
如果把静态方法的本质写出来，则如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ClassName</span> () {...}
<span class="hljs-title class_">ClassName</span>.<span class="hljs-property">staticFn</span> () {...}
</code></pre>
<p>为什么可以这样写？
<code>funtion</code>的原型链上游中有<code>Object</code>对象。该对象支持设置属性。静态方法就是为一个是 funtion 的对象设置了一个属性，该属性值是一个方法。</p>
<h3 id="构造函数--class--普通函数">构造函数 &amp; class &amp; 普通函数</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>构造函数</td>
<td>操作 this</td>
<td>不返回对象。与<code>new</code>操作符一起使用，则会返回一个实例。</td>
</tr>
<tr>
<td>class</td>
<td>操作 this</td>
<td>不返回对象。与<code>new</code>操作符一起使用，则会返回一个实例。</td>
</tr>
<tr>
<td>普通函数</td>
<td>任意逻辑</td>
<td>返回或不返回一个对象</td>
</tr>
</tbody>
</table>
<h1 id="proxy--reflect">proxy &amp; reflect</h1>
<h2 id="proxy">proxy</h2>
<p>proxy 让代理模式更容易实现。
常用于做：保护/预检/代理等。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> o = {
    <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;s&#x27;</span>,
    <span class="hljs-attr">_b</span>: <span class="hljs-number">1</span>
}
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(o, {
    <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">target, propKey, receiver</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (propKey.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;_&#x27;</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;私有方法不能被外部访问&#x27;</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> target[propKey]
        }
    },
    <span class="hljs-attr">set</span>: (target, propKey, value, receiver) {
        target[propKey] = value
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 在严格模式下，set时必须返回true，否则会报错。</span>
    }
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">a</span>)    <span class="hljs-comment">// &#x27;s&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">_b</span>)   <span class="hljs-comment">// 报错</span>
</code></pre>
<p>this 指向 handler。因为 this 指向运行时上下文环境。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> { proxy, revoke } = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(target, handler)
proxy.<span class="hljs-property">key</span> = <span class="hljs-string">&#x27;str&#x27;</span>
proxy.<span class="hljs-property">key</span> <span class="hljs-comment">// &#x27;str&#x27;</span>
<span class="hljs-title function_">revoke</span>() <span class="hljs-comment">// 取消代理</span>
proxy.<span class="hljs-property">key</span> <span class="hljs-comment">// 报错</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)
<span class="hljs-attr">target</span>: <span class="hljs-title class_">Object</span>,
<span class="hljs-attr">handler</span>: 控制对象。
    {
        <span class="hljs-title function_">get</span>(target, propKey, receiver) <span class="hljs-comment">// receiver 读操作所在的Proxy对象</span>
        <span class="hljs-title function_">set</span>(target, propKey, value, receiver)
        <span class="hljs-title function_">has</span>(target, propKey)
        <span class="hljs-title function_">deleteProperty</span>(target, propKey)
        <span class="hljs-title function_">ownKeys</span>(target)
        <span class="hljs-title function_">getOwnPropertyDescription</span>(target, propKey)
        <span class="hljs-title function_">defineProperty</span>(target, propKey, propDesc)
        <span class="hljs-title function_">preventExtensions</span>(target)
        <span class="hljs-title function_">getPrototypeOf</span>(target)
        <span class="hljs-title function_">isExtensible</span>(target)
        <span class="hljs-title function_">setPrototypeOf</span>(target, proto)
        <span class="hljs-title function_">apply</span>(target, object, args)
        <span class="hljs-title function_">construct</span>(target, args)
    }
</code></pre>
<h2 id="reflect">reflect</h2>
<ul>
<li>更接近语言本质。</li>
<li>当前操作<code>Object</code>的方法同时存在于<code>Object</code>、<code>Reflect</code>。未来会只在<code>Reflect</code>上存在。</li>
<li>Reflect 与 Proxy 的方法一一对应。</li>
<li>Reflect 可保证原生方法被执行，Proxy 可保证原生方法不被执行，执行的是代理对象的方法。</li>
</ul>
<pre><code>Reflect.get(target, propKey, receiver)
Reflect.set(target, propKey, value, receiver)
Reflect.apply(target, thisArg, arrArgs)
Reflect.construct(target, arrArgs)
Reflect.defineProperty(target, propKey, value, desc)
Reflect.deleteProperty(target, propKey)
Reflect.has(target, propKey)
Reflect.ownKeys(target)
Reflect.isExtensible(target)
Reflect.preventExtensions(target)
Reflect.getOwnPropertyDescriptor(target, propKey)
Reflect.getPrototypeOf(target)
Reflect.setPrototypeOf(target, prototype)
</code></pre>
<h2 id="demo-for-观察者模式">demo for 观察者模式</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> queuedObservers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()
<span class="hljs-keyword">let</span> handler = {
  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">target, key, value, receiver</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)
    queuedObservers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> <span class="hljs-title function_">observer</span>())
    <span class="hljs-keyword">return</span> result
  },
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">observable</span> = (<span class="hljs-params">obj</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, handler)
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">observe</span> = (<span class="hljs-params">fn</span>) =&gt; queuedObservers.<span class="hljs-title function_">add</span>(fn)

<span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;s&#x27;</span> }
<span class="hljs-keyword">let</span> observedObj = <span class="hljs-title function_">observable</span>(obj)
<span class="hljs-keyword">let</span> <span class="hljs-title function_">print</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;print&#x27;</span>)
<span class="hljs-title function_">observe</span>(print)
observedObj.<span class="hljs-property">a</span> = <span class="hljs-number">0</span>

<span class="hljs-comment">// 我整理的代码</span>
<span class="hljs-keyword">let</span> clog = <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">o</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">proxyObj</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(o, {
      <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">target, key, receiver</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> target[key]
      },
      <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">target, key, value, receiver</span>) =&gt;</span> {
        target[key] = value
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observerList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">v, k</span>) =&gt;</span> {
          <span class="hljs-title function_">k</span>(target)
        })
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      },
    })
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observerList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  }
  <span class="hljs-title function_">addObserver</span>(<span class="hljs-params">fn</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observerList</span>.<span class="hljs-title function_">set</span>(fn, <span class="hljs-title class_">Symbol</span>())
  }
  <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">fn</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observerList</span>.<span class="hljs-title function_">delete</span>(fn)
  }
  <span class="hljs-title function_">set</span>(<span class="hljs-params">k, v</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">proxyObj</span>[k] = v
  }
  <span class="hljs-title function_">get</span>(<span class="hljs-params">k</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">proxyObj</span>[k]
  }
}
<span class="hljs-keyword">let</span> origin = {}
<span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observable</span>(origin)
<span class="hljs-keyword">let</span> <span class="hljs-title function_">a</span> = (<span class="hljs-params">p</span>) =&gt; {
  <span class="hljs-title function_">clog</span>(<span class="hljs-string">&#x27;a fn&#x27;</span>, p)
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">b</span> = (<span class="hljs-params">p</span>) =&gt; {
  <span class="hljs-title function_">clog</span>(<span class="hljs-string">&#x27;b fn&#x27;</span>, p)
}
o.<span class="hljs-title function_">addObserver</span>(a)
o.<span class="hljs-title function_">addObserver</span>(b)
o.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>)
o.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;k1&#x27;</span>, <span class="hljs-string">&#x27;v1&#x27;</span>)
<span class="hljs-title function_">clog</span>(o.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;k&#x27;</span>))
</code></pre>
<h1 id="宏任务--微任务">宏任务 &amp; 微任务</h1>
<h2 id="宏任务由宿主发起">宏任务，由宿主发起。</h2>
<p>script 可理解为外层代码触发</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>postMessage</li>
<li>MessageChannel</li>
<li>setImmediate (node 环境)</li>
</ul>
<h2 id="微任务由-js-引擎发起">微任务，由 js 引擎发起。</h2>
<ul>
<li>Promise</li>
<li>MutationObserver</li>
<li>process.nextTick （node 环境）</li>
</ul>
<h2 id="promise">promise</h2>
<p>promise 的参数是一个接收<code>resolve</code>/<code>reject</code>方法的方法。<br>
一个 promise 对象有三个状态。初始状态是<code>pendding</code>，当执行<code>resolve</code>方法时改变为<code>fulfilled</code>状态，当执行<code>reject</code>方法时改变为<code>rejected</code>状态。二个方法都不执行，则一直是<code>pendding</code>状态。<code>resolve</code>状态触发 promise 对象的<code>then</code>方法。<code>reject</code>状态触发 promise 对象的<code>catch</code>方法。<br>
在定义时开始执行。</p>
<h3 id="promise-的属性">promise 的属性</h3>
<pre><code class="language-js"><span class="hljs-title class_">Promise</span>#<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">reslt</span>) =&gt;</span> {})
<span class="hljs-title class_">Promise</span>#<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {})
<span class="hljs-title class_">Promise</span>#<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {})    <span class="hljs-comment">// 不返回东西。即使写了返回东西的代码也不返回。回调方法中无参数。</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(arrP)    <span class="hljs-comment">// 这种写法的都是静态属性。若arrP都是fulfilled状态则执行then方法，参数是一个数组。若arrP中有一个rejected状态则立即执行catch，参数是一个值。</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(arrP)   <span class="hljs-comment">// 返回最先改变状态的promise对象，状态由该对象决定。</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(arrP) <span class="hljs-comment">// 当arrP都改变状态后返回结果。结果是由{status: &#x27;fulfilled&#x27; | &#x27;rejected&#x27;, value / reason}组成的数组。总是触发then方法。</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(arrP)        <span class="hljs-comment">// arrP中只要有一个状态为fulfilled则返回该值，触发then()。若全为rejected则返回AggregateError对象，触发catch()。</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>()
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">try</span>()            <span class="hljs-comment">// 正在开发。</span>
</code></pre>
<h3 id="模拟-allsettled">模拟 allSettled</h3>
<pre><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mockAllSettled</span> = <span class="hljs-function">(<span class="hljs-params">arrP</span>) =&gt;</span> {
  <span class="hljs-comment">// 每个p都触发检查方法。</span>
  <span class="hljs-comment">// 检查方法判断是否返回结果</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> len = arrP.<span class="hljs-property">length</span>
    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len)
    res.<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>)
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-keyword">if</span> (res.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !!item)) {
        <span class="hljs-title function_">s</span>(res)
      }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      arrP[i]
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">subRes</span>) =&gt;</span> {
          res[i] = {
            <span class="hljs-attr">value</span>: subRes,
            <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,
          }
        })
        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
          res[i] = {
            <span class="hljs-attr">reason</span>: e,
            <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>,
          }
        })
        .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-title function_">f</span>()
        })
    }
  })
}
</code></pre>
<h3 id="使用-promise-封装-ajax">使用 promise 封装 ajax</h3>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params">url, method</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">s, j</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> handler = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">return</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {
          <span class="hljs-title function_">s</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>)
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">j</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>))
        }
      }
    }
    <span class="hljs-keyword">let</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()
    client.<span class="hljs-title function_">open</span>(method.<span class="hljs-title function_">toUpperCase</span>(), url)
    client.<span class="hljs-property">onreadystatechange</span> = handler
    client.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;json&#x27;</span>
    client.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Accept&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>)
    client.<span class="hljs-title function_">send</span>()
  })
}
</code></pre>
<h3 id="判断-promise-对象">判断 promise 对象</h3>
<pre><code>function isPromise(obj) {
  return 'function' == typeof obj.then;
}
</code></pre>
<h3 id="回调方法转换为-promise">回调方法转换为 promise</h3>
<pre><code class="language-js"><span class="hljs-comment">// callback</span>
<span class="hljs-comment">// let fn = (params, cb) =&gt; {...}</span>
<span class="hljs-comment">// callback: (err, res) =&gt; err ? reject(err) : resolve(res)</span>

<span class="hljs-keyword">let</span> <span class="hljs-title function_">cbToP</span> = (<span class="hljs-params">fn, ...params</span>) =&gt;
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">s, j</span>) =&gt;</span> {
    <span class="hljs-title function_">fn</span>(...params, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> err ? <span class="hljs-title function_">j</span>(err) : <span class="hljs-title function_">s</span>(res)
    })
  })
<span class="hljs-keyword">let</span> callbackToPromise = cbToP
</code></pre>
<h3 id="全局的事件">全局的事件</h3>
<pre><code class="language-js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(
  <span class="hljs-string">&#x27;rejectionhandled&#x27;</span>,
  <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise rejected; reason: &#x27;</span> + event.<span class="hljs-property">reason</span>)
  },
  <span class="hljs-literal">false</span>
)
<span class="hljs-variable language_">window</span>.<span class="hljs-property">onunhandledrejection</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`UNHANDLED PROMISE REJECTION: <span class="hljs-subst">${event.reason}</span>`</span>)
}
</code></pre>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th>rejectionhandled</th>
<th>unhandledrejection</th>
</tr>
</thead>
<tbody>
<tr>
<td>环境</td>
<td>window/worker</td>
<td>window/worker</td>
</tr>
<tr>
<td></td>
<td>当 Promise 被 reject 且执行 reject 处理器的时候，会触发</td>
<td>当 Promise 被 reject 且没有 reject 处理器的时候，会触发</td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h3 id="promise--ts">promise &amp; ts</h3>
<pre><code>let p = new Promise&lt;T&gt;((s, j) =&gt; {...})
</code></pre>
<h2 id="eventloop-异步--同步">eventLoop (异步 &amp; 同步)</h2>
<p>所有 js 代码按执行时序可分为三部分：同步代码/宏任务/微任务。<br>
代码从上到下执行。遇到同步代码则依次序执行。遇到宏任务不执行，放入宏任务队列。遇到微任务不执行，入入微任务队列。执行完所有同步代码后执行一个宏任务队列中的宏任务，然后执行完所有微任务。再执行宏任务队列中的一个宏任务，再执行所有微任务。直到宏任务队列为空/微任务队列为空。<br>
因宏任务是宿主环境的，微任务是 js 语言的。所以宏任务执行一个，微任务执行一堆。</p>
<table>
<thead>
<tr>
<th></th>
<th>i/o</th>
<th>timings</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>ram</td>
<td>ns</td>
<td>sync</td>
<td></td>
</tr>
<tr>
<td>disk</td>
<td>1ms</td>
<td>async/sync</td>
<td></td>
</tr>
<tr>
<td>network</td>
<td>100ms-2000ms</td>
<td>async</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="symbol">Symbol</h1>
<p>内置了<code>Symbol.iterator</code>属性<br>
用于表示独一无二的值</p>
<pre><code class="language-js"><span class="hljs-comment">// 用法</span>
<span class="hljs-title class_">Symbol</span>(p?: string)
<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;string&#x27;</span>)
<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;string&#x27;</span>)

<span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;str&#x27;</span>) <span class="hljs-comment">// symbol =&gt; string</span>
<span class="hljs-title class_">String</span>(s) <span class="hljs-comment">// &#x27;Symbol(str)&#x27;</span>
<span class="hljs-comment">// symbol不能转化为number</span>

</code></pre>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Symbol#description</td>
<td>返回描述</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Symbol.for(desc)</td>
<td>若存在相同的 desc 则返回已经存在的 symbol，否则新建一个 symbol 再返回</td>
<td>全局惟一，与在哪个 module 无关。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Symbol.keyFor(desc)</td>
<td>返回一个已登记的 symbol 的 desc</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<p>js 内置了很多 symbol 的属性。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="generator--iterator">Generator &amp; Iterator</h1>
<h2 id="iterator">Iterator</h2>
<p>它是一个遍历器。
<code>[Symbol.iterator]</code>是遍历器接口。
有 iterator 接口的对象就是可遍历对象。
可遍历对象都有<code>[Symbol.iterator]</code>属性。
遍历器接口是一个方法。该方法返回遍历器对象（至少包含<code>next</code>属性的对象）。
next 属性值是一个方法。该方法返回一个包含当前对象信息的对象。如：</p>
<pre><code>{
    value: any, // 当前值,
    done: boolean, // 是否结束
}
</code></pre>
<p>内置 iterator 接口的对象有 Array/Set/Map/String/TypedArray/...。
也可以自定义 iterator 接口，如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {}
obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">if</span> (t++ &lt; <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">value</span>: t,
          <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">value</span>: <span class="hljs-number">8</span>,
          <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>,
        }
      }
    },
  }
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> obj) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;v&#x27;</span>, v)
}
</code></pre>
<p>主要使用<code>for...of</code>对接 iterator 接口。</p>
<h3 id="iterator-的作用有三个">Iterator 的作用有三个：</h3>
<p>一是为各种数据结构，提供一个统一的、简便的访问接口；
二是使得数据结构的成员能够按某种次序排列；
三是 Iterator 接口主要供 for...of 消费。</p>
<pre><code>for (let ele of set)
for (let [k, v] of map)
</code></pre>
<h3 id="遍历器对象">遍历器对象</h3>
<pre><code class="language-js">{
    <span class="hljs-title function_">next</span>() =&gt; any  <span class="hljs-comment">// 必须要有此属性。</span>
    <span class="hljs-attr">return</span>: any    <span class="hljs-comment">// 完成遍历前清理或释放资源</span>
    <span class="hljs-attr">throw</span>: error
}
</code></pre>
<h3 id="触发-iterator-接口的方法">触发 iterator 接口的方法</h3>
<ul>
<li>解构赋值</li>
<li>扩展运算符<code>...</code></li>
<li><code>yield *</code></li>
<li>遍历结构，如<code>for...of / Array.from / Map() / Set() / WeakMap() / WeakSet() / Promise.all() / Promise.race()</code></li>
</ul>
<h3 id="为-obj-设置-iterator-接口">为 obj 设置 iterator 接口</h3>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> o = {
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: a[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>].<span class="hljs-title function_">bind</span>(a),
}
</code></pre>
<p>不建议这么做。使用专有的可遍历数据结构处理 iterator 更好。<code>o.a = a</code>.</p>
<h2 id="generator">Generator</h2>
<p>Generator 函数</p>
<ul>
<li>是一个状态机，封装了多个内部状态。</li>
<li>会返回一个 generator 对象（不是遍历器对象），(至少包含<code>next</code>属性，可以包含<code>throw</code>/<code>return</code>属性的对象)。从定义角度认为 generator 对象包括 iterartor 对象。</li>
<li><code>function</code>关键字与函数名之间有一个星号<code>*</code>.</li>
<li>调用<code>next()</code>时执行到下一个<code>yield</code>。当调用<code>throw()</code>时，把<code>done</code>的属性值改为<code>true</code>，遍历结束。当调用<code>return(v)</code>时，把<code>value</code>的属性值为<code>v</code>，<code>done</code>的属性值改为<code>true</code>，遍历结束。</li>
<li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态。<code>generator</code>方法和<code>yield</code>可互相嵌套。
每个<code>yield</code>都定义一个状态。yield 后面的值是该状态的值。</li>
<li>是分段执行的，yield 表达式是暂停执行的标记，而<code>next()</code>可以恢复执行。</li>
<li>可以用于定义 iterator 接口。</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 开关机</span>
<span class="hljs-keyword">function</span>* <span class="hljs-title function_">helloWorldGenerator</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> t = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">yield</span> (t = !t)
  }
}
<span class="hljs-keyword">var</span> hw = <span class="hljs-title function_">helloWorldGenerator</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hw.<span class="hljs-title function_">next</span>())
<span class="hljs-comment">// 多执行几次</span>
<span class="hljs-comment">// {value: false, done: false}</span>
<span class="hljs-comment">// {value: true, done: false}</span>
<span class="hljs-comment">// {value: false, done: false}</span>

<span class="hljs-comment">// 生成fibonacci数列</span>
<span class="hljs-keyword">function</span>* <span class="hljs-title function_">getFibonacci</span>(<span class="hljs-params">num = <span class="hljs-number">10</span></span>) {
  <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> [pre, cur] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
  <span class="hljs-keyword">while</span> (t++ &lt; num) {
    <span class="hljs-keyword">yield</span> cur
    <span class="hljs-keyword">let</span> q = cur
    cur = q + pre
    pre = q
  }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getFibArr</span>(<span class="hljs-params">num = <span class="hljs-number">10</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">getFibonacci</span>(num))
}
<span class="hljs-comment">// 平化数组</span>
<span class="hljs-keyword">function</span>* <span class="hljs-title function_">faltmizeArr</span>(<span class="hljs-params">arr, isDeepFirst = <span class="hljs-literal">true</span></span>) {
  <span class="hljs-keyword">if</span> (isDeepFirst) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ele <span class="hljs-keyword">of</span> arr) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(ele)) {
        <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">faltmizeArr</span>(ele)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">yield</span> ele
      }
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">let</span> s = []
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ele <span class="hljs-keyword">of</span> arr) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(ele)) {
        s.<span class="hljs-title function_">push</span>(...ele)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">yield</span> ele
      }
    }
    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">faltmizeArr</span>(s, isDeepFirst)
    }
  }
}
</code></pre>
<h3 id="generatorreturn">Generator#return</h3>
<h3 id="generatorthrow">Generator#throw</h3>
<p>generator 方法的实例可执行<code>throw()</code>。然后在 generator 方法中 catch 一次错误，若再执行实例的<code>throw()</code>，则 generator 方法不 catch，则实例所在环境 catch.</p>
<h3 id="协程">协程</h3>
<p>&quot;协程&quot;（coroutine），意思是多个线程互相协作，完成异步任务。过程如下：</p>
<ol>
<li>协程 A 开始执行。</li>
<li>协程 A 执行到一半，进入暂停，执行权转移到协程 B。</li>
<li>（一段时间后）协程 B 交还执行权。</li>
<li>协程 A 恢复执行。</li>
</ol>
<h3 id="co-模块">co 模块</h3>
<p>详见<a href="/confuse/co.html">co</a></p>
<p>整个过程和<code>web worker</code>的工作过程很像。</p>
<h3 id="流式处理">流式处理</h3>
<h3 id="co-源码">co 源码</h3>
<h2 id="async--await">async &amp; await</h2>
<p>是 es7 的内容。
基于<code>co</code>模块处理的。
<code>async/await</code>是<code>generator/yield</code>的语法糖，本质是<code>generator/yield/co</code>。
<code>generator/yield/co</code>的具有的功能在<code>async/await</code>中都有。</p>
<h3 id="async-原理">async 原理</h3>
<pre><code>async function fn(args) {
  // ...
}
// 等同于
function fn(args) {
  return spawn(function* () {
    // ...
  });
}
function spawn(genF) {
  return new Promise(function(resolve, reject) {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch(e) {
        return reject(e);
      }
      if(next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(function(v) {
        step(function() { return gen.next(v); });
      }, function(e) {
        step(function() { return gen.throw(e); });
      });
    }
    step(function() { return gen.next(undefined); });
  });
}
</code></pre>
<h3 id="async--promise">async &amp; promise</h3>
<table>
<thead>
<tr>
<th></th>
<th>async</th>
<th>promise</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>基于 promise.</td>
<td>js 的底层语法</td>
<td></td>
</tr>
<tr>
<td></td>
<td>生成于 es7</td>
<td>生成于 es6</td>
<td></td>
</tr>
<tr>
<td></td>
<td>由内部 promise 决定状态</td>
<td>由 s/j 决定状态</td>
<td></td>
</tr>
<tr>
<td></td>
<td>语法糖</td>
<td>更本质</td>
<td></td>
</tr>
<tr>
<td></td>
<td>需要与 try/catch 结合使用才能处理错误</td>
<td>可使用 then/catch 处理错误</td>
<td>因此我更喜欢 promise</td>
</tr>
<tr>
<td></td>
<td>若能保证返回 fulfilled 状态。可以使用 async/await</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="decorator">decorator</h1>
<ul>
<li>可以用于装饰类、类的属性。不可用于装饰方法。因为方法会被变量提升。类、类的属性不会提升。</li>
<li>当前仍再更新。</li>
<li>装饰器是一个方法。参数有 3 个 target:被装饰的对象（类或类的方法），name:被装饰的属性名，descriptor:属性描述符对象。</li>
<li>需要增强已有功能时使用。如本地验证用户登录后再执行某项功能。</li>
<li>有点像高阶函数、代理。</li>
<li>修饰什么就应该返回一个什么。</li>
<li>编译时运行。</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// no.1</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">testable</span>(<span class="hljs-params">target</span>) {
    <span class="hljs-comment">// target.isTestable = true</span>
    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isTestable</span> = <span class="hljs-literal">true</span>
    <span class="hljs-comment">// 修饰class时，操作的是原型对象。</span>
}
@testable
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {...}
<span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>() <span class="hljs-comment">// 使用被装饰过的类</span>
<span class="hljs-comment">// no.2</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span> (target, name, description) {
  <span class="hljs-comment">// target     class</span>
  <span class="hljs-comment">// name       class的属性名</span>
    <span class="hljs-comment">// description: {</span>
    <span class="hljs-comment">//     value,</span>
    <span class="hljs-comment">//     enumerable,</span>
    <span class="hljs-comment">//     configurable,</span>
    <span class="hljs-comment">//     writable</span>
    <span class="hljs-comment">// }</span>
    description.<span class="hljs-property">wriable</span> = <span class="hljs-literal">false</span>
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span> {
    @readonly
    <span class="hljs-title function_">skills</span>(<span class="hljs-params"></span>) {...}
}
<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title function_">P</span>()
p.<span class="hljs-property">skills</span> = <span class="hljs-function">() =&gt;</span> {...} <span class="hljs-comment">// 不可被重新赋值</span>
<span class="hljs-comment">// no.3</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span> (target, name, descriptor) {
    <span class="hljs-keyword">let</span> oldValue = descriptor.<span class="hljs-property">value</span>
    descriptor.<span class="hljs-property">value</span> = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`args: <span class="hljs-subst">${args}</span>`</span>)
        <span class="hljs-keyword">return</span> oldValue.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args)
    }
    <span class="hljs-keyword">return</span> descriptor
}
<span class="hljs-comment">// 也可以多接收几个参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span> (a, b, c, d) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, descriptor</span>) {
    <span class="hljs-comment">// 使用a,b,c,d</span>
    <span class="hljs-keyword">return</span> ...
  }
}
@<span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {...}
</code></pre>
<p>常用包</p>
<ul>
<li>core-decorators.js</li>
<li>Trait</li>
</ul>
<p>装饰器的种类</p>
<ul>
<li>类</li>
<li>类的属性（public, private, and static）</li>
<li>类的方法（public, private, and static）</li>
<li>属性存取器（accessor）（public, private, and static）</li>
</ul>
<h2 id="应用">应用</h2>
<ul>
<li>身份认证</li>
<li>日志记录</li>
<li>数据（参数）合理性检查</li>
<li>缓存装饰器</li>
</ul>
<h2 id="常用的修饰器库">常用的修饰器库</h2>
<ul>
<li><a href="https://github.com/CocktailJS/traits-decorator">traits-decorator</a></li>
<li><a href="https://github.com/postaljs/postal.js">postal</a></li>
<li><a href="https://github.com/jayphelps/core-decorators.js">core-decorator</a></li>
</ul>
<h1 id="位运算">位运算</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>and</td>
<td>与</td>
<td>判断 2 个二进制数每个对应的位上是否都为 1,则该位为 1</td>
<td></td>
</tr>
<tr>
<td><code>|</code></td>
<td>or</td>
<td>或</td>
<td>判断 2 个二进制数每个对应的位上是否至少有一位为 1,则该位为 1</td>
<td></td>
</tr>
<tr>
<td><code>^</code></td>
<td>xor</td>
<td>异或</td>
<td>判断 2 个二进制数每个对应的位上是否只有一位为 1,则该位为 1 对应位上是否不同。若是则为 1，否则为 0。</td>
<td></td>
</tr>
<tr>
<td><code>~</code></td>
<td>not</td>
<td>取反</td>
<td>每一位都取反</td>
<td></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td></td>
<td>右移</td>
<td>右边移出的去掉。左边以最左则的值填充。</td>
<td></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td></td>
<td>左移</td>
<td>（0）当移动位数大于 32 时。使用 x%32。 左边溢出的去掉。右边使用 0 补齐。</td>
<td></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td></td>
<td>无符号右移（0）</td>
<td>右边移出的去掉。左边以 0 填充。</td>
<td></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;=</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>^=</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>|=</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>demo</p>
<p>|          |         |
| -------- | ------- | -------- | --- |
| 判断奇偶 | <code>x&amp;1</code>   |
| 左移一位 | &lt;=&gt; *2 | 右移一位 | /2  |</p>
<p>0 与任意数^ 结果是任意数。任意与自身异或都是 0<br>
|右移一位| 得到整数部分|
|~~| 得到 number 型(得到整数部分,包括符号.)|</p>
<ul>
<li>是否为奇数 <code>let isOdd = n =&gt; !!(n &amp; 1)</code></li>
<li>位运算，是否为偶数 <code>let isEven = n =&gt; !isOdd(n)</code></li>
<li>乘以 2^n <code>1 &lt;&lt; n</code></li>
<li>n 底</li>
<li>m 2 的幂</li>
</ul>
<h1 id="worker"><a href="/language/javascript/webWorker.html">worker</a></h1>
<h1 id="线程">线程</h1>
<p>js 是单线程语言。但是它的宿主环境——browser 支持多线程。<br>
当遇到大量计算时可以使用<code>web worker</code>处理。主<code>worker</code>创建一个子<code>worker</code>，再让子 worker 处理大量计算，主 worker 会交出数据的控制权给子 worker。得到计算结果后把由子 workern 以消息<code>message</code>的形式给主 worker。</p>
<h2 id="协程-1">协程</h2>
<h1 id="xhr"><a href="/language/javascript/xhr.html">xhr</a></h1>
<h1 id="动画">动画</h1>
<p>一般与 canvas 结合工作。</p>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>requestAnimationFrame(cb) =&gt; number</code></td>
<td>在下次更新动画时调用，即在重绘前调用。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cancelAnimationFrame(id: number) =&gt; void</code></td>
<td>取消更新动画时的回调。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>requestIdleCallback(cb: (IdleDeadline) =&gt; void, opt ?= {timeout: number}) =&gt; number</code></td>
<td>在浏览器的空闲时间执行回调方法。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cancelIdleCallback(id: number) =&gt; void</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<pre><code class="language-ts"><span class="hljs-title class_">IdleDeadline</span> {
  <span class="hljs-attr">didTimeout</span>: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 执行回调方法时是否超过指定时间。此时一定设置了timeout</span>
  <span class="hljs-title function_">timeRemaining</span>(): nubmer <span class="hljs-comment">// 返回一个时间DOMHighResTimeStamp, 并且是浮点类型的数值，它用来表示当前闲置周期的预估剩余毫秒数。如果 idle period 已经结束，则它的值是 0。你的回调函数 (传给 requestIdleCallback 的函数) 可以重复的访问这个属性用来判断当前线程的闲置时间是否可以在结束前执行更多的任务。</span>
}
</code></pre>
<h1 id="js-操作-dom">js 操作 dom</h1>
<h1 id="window-中常用的对象">window 中常用的对象</h1>
<ul>
<li><a href="/language/javascript/url.html">URL</a></li>
<li><a href="/language/javascript/blob.html">blob</a></li>
<li><a href="/language/javascript/file.html">file</a></li>
<li><a href="/language/javascript/title.html">title</a></li>
<li><a href="/language/javascript/title.html">title</a></li>
<li><a href="/language/javascript/title.html">title</a></li>
</ul>
<h1 id="bom--js">BOM &amp; js</h1>
<ul>
<li>
<p>BOM Broser Object Model 浏览器对象模型</p>
<ul>
<li>window
<ul>
<li>DOM (document object model) 文档对象
<ul>
<li>...</li>
</ul>
</li>
<li>frames</li>
<li>navigator 各浏览器多有差异</li>
<li><a href="/browser/history.html">history</a></li>
<li>location</li>
<li>screen</li>
</ul>
</li>
<li>xxx</li>
<li>xxx</li>
<li>xxx</li>
</ul>
</li>
<li>
<p>js 本地对象</p>
<ul>
<li><a href="/language/javascript/object.html">Object</a></li>
<li><a href="/language/javascript/string.html">String</a></li>
<li><a href="/language/javascript/array.html">Array</a></li>
<li><a href="/language/javascript/date.html">Date</a></li>
<li><a href="/language/javascript/number.html">Number</a></li>
<li><a href="/regexp/index.html">RegExp</a></li>
<li><a href="/language/javascript/function.html">Function</a></li>
<li>Boolean</li>
<li>Error</li>
<li><a href="/language/javascript/symbol.html">symbol</a></li>
<li>null</li>
<li><a href="/language/javascript/undefined.html">undefined</a></li>
<li><a href="/language/javascript/bigint.html">bigint</a></li>
<li><a href="/language/javascript/set.html">set</a></li>
<li><a href="/language/javascript/map.html">map</a></li>
<li><a href="/language/javascript/url.html">url</a></li>
<li><a href="/language/javascript/typedArray.html">typedArray</a></li>
</ul>
</li>
<li>
<p>js 内置对象</p>
<ul>
<li><a href="/language/javascript/math.html">Math</a></li>
<li><a href="/language/javascript/json.html">JSON</a></li>
</ul>
</li>
<li>
<p>js 宿主对象</p>
<ul>
<li>BOM
<ul>
<li><a href="/language/javascript/fetch.html">fetch</a></li>
</ul>
</li>
<li>DOM</li>
</ul>
</li>
<li>
<p>xxxxx</p>
<ul>
<li><a href="/language/javascript/permission.html">permission</a></li>
<li><a href="/language/javascript/clipboard.html">clipboard</a></li>
<li><a href="/language/javascript/dataTransfer.html">dataTransfer</a></li>
<li><a href="/language/javascript/event.html">event</a></li>
</ul>
</li>
</ul>
<h1 id="模块化"><a href="/language/javascript/modularity.html">模块化</a></h1>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>-</th>
<th>全称</th>
<th>代表</th>
<th>加载方式</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>commonjs (cjs)</td>
<td></td>
<td>nodejs</td>
<td>同步加载</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>amd</td>
<td>asynchronous module definition</td>
<td>require.js</td>
<td>异步加载</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cmd</td>
<td>common module definition</td>
<td>sea.js</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>umd</td>
<td>universion module definition</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>es6</td>
<td>-</td>
<td>在 js 语言层面上实现了模块化。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>iife</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>system</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h1 id="函数式编程"><a href="/language/javascript/functionalProgramming.html">函数式编程</a></h1>
<h1 id="低层">低层</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>web interfaces</td>
<td>Javascript 暴露给 web APP 的接口，也就是 ES 定义的接口。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>web IDL (web interface definition language)</td>
<td>用来定义 Web interfaces 的语言，其通过一种规范实现了 JS engine(V8)和 Web core(Blink)之间的低耦合绑定.</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="es-版本"><a href="/language/javascript/version.html">es 版本</a></h2>
<ul>
<li>es4</li>
<li>es5</li>
<li>es6</li>
<li>es7</li>
<li>es8</li>
<li>es8</li>
<li>es8</li>
</ul>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>