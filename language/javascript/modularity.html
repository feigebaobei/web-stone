<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>&#x6a21;&#x5757;&#x5316;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="模块化">模块化</h1>
<p>应该说清这 6 种规范。</p>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>-</th>
<th>全称</th>
<th>代表</th>
<th>加载方式</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>amd</td>
<td>asynchronous module definition</td>
<td>require.js</td>
<td>异步加载</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cmd</td>
<td>common module definition</td>
<td>sea.js</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>umd</td>
<td>universion module definition</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>commonjs (cjs)</td>
<td></td>
<td>nodejs</td>
<td>同步加载</td>
<td>2009</td>
<td></td>
<td></td>
</tr>
<tr>
<td>esm</td>
<td>es6 module</td>
<td>在 js 语言层面上实现了模块化。</td>
<td>2015</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>iife</td>
<td>immediately invoked function expression</td>
<td>jquery</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>system</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="amd">amd</h2>
<ul>
<li>异步加载，不阻塞页面的加载，能并行加载多个模块，但不能按需加载，必须提前加载所需依赖。然后运行。</li>
<li>用于浏览器环境。</li>
<li>需要开发者明确该包的依赖项。</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 定义模块</span>
<span class="hljs-title function_">define</span>(id?: <span class="hljs-title class_">String</span>, dependencies?: <span class="hljs-title class_">String</span>[], <span class="hljs-attr">factory</span>: <span class="hljs-title class_">Function</span>|<span class="hljs-title class_">Object</span>);
<span class="hljs-comment">//     模块 id       依赖其它模块                   回调函数</span>
<span class="hljs-comment">// 若factory不为function，则为该模块的导出值。</span>
<span class="hljs-comment">// 引入模块</span>
<span class="hljs-built_in">require</span>([<span class="hljs-variable language_">module</span>], callback)
<span class="hljs-comment">// 需要引入的模块    回调函数</span>
<span class="hljs-comment">// 回调函数会在前面的模块都加载成功后再执行。</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;module&#x27;</span>], <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {
  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">fn</span>(p)
})
</code></pre>
<h3 id="usage">usage</h3>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- data-main属性得值为入口文件得路径 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">&quot;./index.js&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./path/to/require.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>requirejs 定义了三个变量：</p>
<ul>
<li>define</li>
<li>require</li>
<li>requirejs === require</li>
</ul>
<p>可以使用于浏览器环境、node 环境、……</p>
<pre><code class="language-js"><span class="hljs-comment">// 在其他模块导入该模块时，拿到的数据即为该模块的第三个参数的值。</span>
</code></pre>
<h2 id="cmd">cmd</h2>
<p>amd：定义时加载。cmd:执行时加载。<br>
在定义之初声明所有依赖。可以在任意时机动态引入模块。<br>
可以按需加载。<br>
由阿里的玉伯提出。</p>
<pre><code class="language-js"><span class="hljs-title function_">define</span>(<span class="hljs-attr">factory</span>: string | object | <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) =&gt;</span> {})
<span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) {...})
</code></pre>
<h3 id="seajs">sea.js</h3>
<h4 id="api">api</h4>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>`define(factory: string</td>
<td>object</td>
<td>(requrie, exports, module) =&gt; {})`</td>
<td>定义模块</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>define.cmd</code></td>
<td>该属性是一个空对象。用于判断当前页面是否有cmd模块加载器。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>require()</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="umd">umd</h2>
<ul>
<li>通用模块定义规范</li>
<li>使同一个代码块在 commonjs/cmd/amd 中都可运行。即：可以在浏览器端、服务端（node 环境）、app 端运行。</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// demo 示意</span>
;(<span class="hljs-function">(<span class="hljs-params">root, factory</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="hljs-property">amd</span>) {
    <span class="hljs-comment">// amd</span>
    <span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;jquery&#x27;</span>], factory)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;objects&#x27;</span>) {
    <span class="hljs-comment">// commonjs</span>
    <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>)
    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">factory</span>($)
  } <span class="hljs-keyword">else</span> {
    root.<span class="hljs-property">testModule</span> = <span class="hljs-title function_">factory</span>(root.<span class="hljs-property">jQuery</span>)
  }
})(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">$</span>) =&gt;</span> {
  <span class="hljs-comment">// todo</span>
})
</code></pre>
<p>它在定义模块的时候回检测当前使用环境和模块的定义方式，将各种模块化定义方式转化为同样一种写法。
它会把若干种 js 规范统一为一种（当前环境支持的）。</p>
<p>有优先 node 环境的（判断 exports 是否存在），也有优先 amd 环境的（判断 define 是否存在），最后都是使用 window/global 兜底。</p>
<h2 id="commonjs">commonjs</h2>
<ul>
<li>node.js 模块化的模块方案。在 esm 出现前出现。</li>
<li>每个文件就是一个模块</li>
<li>每一个模块都有一个<code>module</code>对象。该对象有个属性是：<code>exports</code>/<code>require</code></li>
<li>使用这种规范的代表： node。node 把每一个文件都做为一个模块。加载模块使用 require，该方法<strong>读取一个文件并执行</strong>，最后返回这个模块内部的 exports 对象。返回的是值，不是值的地址。</li>
<li>使用 <code>module.exports/exports</code> 和 <code>require</code> 抛出和引入。</li>
<li><code>module.exports</code>使用方法：<code>module.exports = {k: (p) =&gt; {...}, var, var2}</code></li>
<li><code>exports</code>的使用方法：<code>exports = {v1, v2, v3}</code></li>
<li><code>module.exports</code>是对象。<code>exports</code> 指向 <code>module.exports</code>。所以<code>module.exports</code>可以抛出变量、对象。<code>exports</code>只能抛出对象。</li>
<li>commonjs 是同步加载的。</li>
</ul>
<h2 id="esm">esm</h2>
<ul>
<li>es6 及以后的 module 规范</li>
<li>输出 <code>export</code> / <code>export default</code></li>
<li>引入 <code>import</code></li>
</ul>
<table>
<thead>
<tr>
<th>export</th>
<th>export default</th>
<th>import</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>只能输出对象</td>
<td>输出任意</td>
<td>引入</td>
<td></td>
<td></td>
</tr>
<tr>
<td>输出</td>
<td>输出默认对象</td>
<td>引入</td>
<td></td>
<td></td>
</tr>
<tr>
<td>可执行多次</td>
<td>只能执行一次</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>export a; export b;</code></td>
<td><code>export default {...}</code></td>
<td><code>import {...} from ...</code> 或 <code>import default from ...</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>现代浏览器已经支持<code>esm</code></p>
<pre><code>&lt;script type=&quot;module&quot;&gt;
import v from '...'
// ...
&lt;/script&gt;
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> defaultExport <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mn&#x27;</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> all <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mn&#x27;</span>
<span class="hljs-keyword">import</span> {<span class="hljs-keyword">export</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mn&#x27;</span>
<span class="hljs-keyword">import</span> {<span class="hljs-keyword">export</span> <span class="hljs-keyword">as</span> alias} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mn&#x27;</span>
<span class="hljs-keyword">import</span> {export1, export2} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mn&#x27;</span>
<span class="hljs-keyword">import</span> {export1, export2 <span class="hljs-keyword">as</span> alias} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mn&#x27;</span>
<span class="hljs-keyword">import</span> defaultExport, {export1, export2} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mn&#x27;</span>
<span class="hljs-keyword">import</span> defaultExport, * <span class="hljs-keyword">as</span> all <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mn&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;mn&#x27;</span> <span class="hljs-comment">// 仅加载模块，不导入任何内容。程序中的第一个此类导入将执行模块的主体。</span>
</code></pre>
<h2 id="iife">iife</h2>
<ul>
<li>立即执行函数</li>
<li>定义后立即执行的函数。</li>
</ul>
<pre><code class="language-js">vat <span class="hljs-variable language_">global</span> = {};
(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) {
    <span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;string&#x27;</span>
    <span class="hljs-variable language_">global</span>.<span class="hljs-property">b</span> = <span class="hljs-number">0</span>
})(<span class="hljs-variable language_">global</span>)
</code></pre>
<p>ts 的<code>enum</code>类型就是使用 iife.</p>
<pre><code class="language-js"><span class="hljs-comment">// 写法</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {}())
(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {})()
<span class="hljs-comment">// 块级作用域写法</span>
{
    <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {}
}
</code></pre>
<h2 id="system">system</h2>
<h2 id="es-module-和-commonjs">ES module 和 commonJS</h2>
<p>| | ES module | commonJS | | |
| - | | | - | - |
| | <code>*.mjs</code> | <code>*.cjs</code> | | |
| | 客户端运行 | 服务端运行 | | |
| | <code>import / export</code> | <code>require / module.exports</code> | | |
| | 若在 package.json 中设置 type：module，则为 esm 规范。 | 否则为 cjs 规范。 | | |
| 互相引用 | <code>import all form 'name'</code> | <code>(async () =&gt; {await import('./file.mjs')})()</code> | | |
| | 只能整体引入后再解构使用。 | | | |
| 同时支持 2 种规范 | <code>exports: {require: &quot;./index.js&quot;, import: &quot;./esm/index.js&quot;}</code> | | | |</p>
<h3 id="es-module-和-commonjs-循环引用问题">ES module 和 commonJS 循环引用问题</h3>
<p>因 esm、commonjs 对待文件(模式)的方式不同。</p>
<table>
<thead>
<tr>
<th>esm</th>
<th>commonjs</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>在内存中缓存该文件，再使用到该的地方指向文件。</td>
<td>执行该模块后返回一个对象。</td>
<td></td>
</tr>
<tr>
<td>进入文件后把文件在 Module Map 中标记为 fetching。解析完成为获取该文件的 Module Record.</td>
<td>执行了多少返回多少</td>
<td></td>
</tr>
<tr>
<td>循环引用不出问题</td>
<td>循环引用可能出问题</td>
<td></td>
</tr>
<tr>
<td>动态只读</td>
<td>复制后返回</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="解决-commonjs-的循环引用问题">解决 commonjs 的循环引用问题</h3>
<ol>
<li>利用变量提升+commonjs 的执行顺序。在模块的最后使用<code>var</code>定义引入的模块。</li>
<li>利用 js 的异步机制。在 setTimeout 中使用引入模块。</li>
</ol>
<h2 id="demo-for-import--export">demo for import &amp; export</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { key } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file.js&#x27;</span>
<span class="hljs-keyword">import</span> def <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file.js&#x27;</span>
<span class="hljs-keyword">import</span> { key <span class="hljs-keyword">as</span> alias } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file.js&#x27;</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file.js&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./file.js&#x27;</span> <span class="hljs-comment">// 整个模块仅为副作用（中性词，无贬义含义）而导入，而不导入模块中的任何内容（接口）。 这将运行模块中的全局代码，但实际上不导入任何值。</span>
<span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./file.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">{<span class="hljs-keyword">default</span>: def, key}</span>) =&gt;</span> {...})

<span class="hljs-keyword">export</span> {key}
<span class="hljs-keyword">export</span> {key <span class="hljs-keyword">as</span> alias}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> key = <span class="hljs-string">&#x27;str&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> key

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CONSTANT</span> = <span class="hljs-number">42</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> variable = <span class="hljs-number">42</span>;
<span class="hljs-comment">// only reading is exposed</span>
<span class="hljs-comment">// it&#x27;s not possible to modify the variable from outside</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fun&#x27;</span>);
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Super</span> {
  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;method&#x27;</span>);
  }
}
<span class="hljs-keyword">let</span> a, b, other;
<span class="hljs-keyword">export</span> { a, b, other <span class="hljs-keyword">as</span> c };
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-title function_">more</span>();
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> xxx                   <span class="hljs-comment">// 把xxx中的非default全部导出</span>
<span class="hljs-keyword">export</span> {<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> alias} <span class="hljs-keyword">from</span> xxx  <span class="hljs-comment">// 把xxx中的default以alias导出</span>
</code></pre>
<h2 id="moduleexports--exports--export--export-defaut">module.exports &amp; exports &amp; export &amp; export defaut</h2>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>module.exports</th>
<th>exports</th>
<th>export</th>
<th>export default</th>
</tr>
</thead>
<tbody>
<tr>
<td>node.js 中的语法。用来导出对象用法。</td>
<td>node.js 中的语法。用来导出对象用法。</td>
<td>es6 的语法</td>
<td>es6 的语法</td>
</tr>
<tr>
<td>module.exports = {}</td>
<td>exports={}</td>
<td>export {var0, var1}</td>
<td>export default any</td>
</tr>
<tr>
<td>let t = require 'xxx'</td>
<td>let t = require 'xxx'</td>
<td>import {a, b as c} from 'map'</td>
<td>import a from 'map'</td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="指明包规范">指明包规范</h2>
<pre><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;module&quot;</span>
<span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span> <span class="hljs-comment">// 默认</span>
</code></pre>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>