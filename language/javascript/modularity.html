<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x6a21;&#x5757;&#x5316;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="模块化">模块化</h1>
<p>应该说清这 6 种规范。</p>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>-</th>
<th>全称</th>
<th>代表</th>
<th>加载方式</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>amd</td>
<td>asynchronous module definition</td>
<td>require.js</td>
<td>异步加载</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cmd</td>
<td>common module definition</td>
<td>sea.js</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>umd</td>
<td>universion module definition</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>commonjs (cjs)</td>
<td></td>
<td>nodejs</td>
<td>同步加载</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>esm</td>
<td>es6 module</td>
<td>在 js 语言层面上实现了模块化。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>iife</td>
<td>immediately invoked function expression</td>
<td>jquery</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>system</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="amd">amd</h2>
<p>异步加载，不阻塞页面的加载，能并行加载多个模块，但不能按需加载，必须提前加载所需依赖。<br>
用于浏览器环境。</p>
<pre><code class="language-js"><span class="hljs-comment">// 定义模块</span>
<span class="hljs-title function_">define</span>(id?: <span class="hljs-title class_">String</span>, dependencies?: <span class="hljs-title class_">String</span>[], <span class="hljs-attr">factory</span>: <span class="hljs-title class_">Function</span>|<span class="hljs-title class_">Object</span>);
<span class="hljs-comment">//     模块 id       依赖其它模块                   回调函数</span>
<span class="hljs-comment">// 若factory不为function，则为该模块的导出值。</span>
<span class="hljs-comment">// 引入模块</span>
<span class="hljs-built_in">require</span>([<span class="hljs-variable language_">module</span>], callback)
<span class="hljs-comment">// 需要引入的模块    回调函数</span>
<span class="hljs-comment">// 回调函数会在前面的模块都加载成功后再执行。</span>
</code></pre>
<pre><code>require(['module'], function (module) {
    module.fn(p)
})
</code></pre>
<h3 id="usage">usage</h3>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- data-main属性得值为入口文件得路径 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">&quot;./index.js&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./path/to/require.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>requirejs 定义了三个变量：</p>
<ul>
<li>define</li>
<li>require</li>
<li>requirejs === require</li>
</ul>
<p>可以使用于浏览器环境、node 环境、……</p>
<pre><code class="language-js"><span class="hljs-comment">// 在其他模块导入该模块时，拿到的数据即为该模块的第三个参数的值。</span>
</code></pre>
<h2 id="cmd">cmd</h2>
<p>amd：定义时加载。cmd:执行时加载。<br>
在定义之初声明所有依赖。可以在任意时机动态引入模块。<br>
可以按需加载。<br>
由阿里的玉伯提出。</p>
<pre><code class="language-js"><span class="hljs-title function_">define</span>(<span class="hljs-attr">factory</span>: string | object | <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) =&gt;</span> {})



<span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) {...})

</code></pre>
<h3 id="seajs">sea.js</h3>
<h4 id="api">api</h4>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>`define(factory: string</td>
<td>object</td>
<td>(requrie, exports, module) =&gt; {})`</td>
<td>定义模块</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>define.cmd</code></td>
<td>该属性是一个空对象。用于判断当前页面是否有cmd模块加载器。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>require()</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="umd">umd</h2>
<p>通用模块定义规范
使同一个代码块在 commonjs/cmd/amd 中都可运行。可以统一浏览器端、服务端（node环境）、app 端。</p>
<pre><code>((root, factory) =&gt; {
    if (typeof define === 'function' &amp;&amp; define.amd) {
        // amd
        define(['jquery'], factory)
    } else if (typeof exports === 'objects') {
        // commonjs
        var $ = require('jquery')
        module.exports = factory($)
    } else {
        root.testModule = factory(root.jQuery)
    }
})(this, ($) =&gt; {
    // todo
})
</code></pre>
<p>它在定义模块的时候回检测当前使用环境和模块的定义方式，将各种模块化定义方式转化为同样一种写法。
它会把若干种 js 规范统一为一种（当前环境支持的）。</p>
<p>有优先node环境的（判断exports是否存在），也有优先amd环境的（判断define是否存在），最后都是使用window/global兜底。</p>
<h2 id="commonjs">commonjs</h2>
<p>每一个模块都有一个<code>module</code>对象。该对象有个属性是：<code>exports</code>/<code>require</code><br>
使用这种规范的代表： node。node 把每一个文件都做为一个模块。加载模块使用 require，该方法<strong>读取一个文件并执行</strong>，最后返回这个模块内部的 exports 对象。返回的是值，不是值的地址。<br>
使用 <code>module.exports/exports</code> 和 <code>require</code> 抛出和引入。<br>
<code>module.exports</code>使用方法：<code>module.exports = {k: (p) =&gt; {...}, var, var2}</code><br>
<code>exports</code>的使用方法：<code>exports = {v1, v2, v3}</code>
<code>module.exports</code>是对象。<code>exports</code> 指向 <code>module.exports</code>。所以<code>module.exports</code>可以抛出变量、对象。<code>exports</code>只能抛出对象。<br>
commonjs 是同步加载的。</p>
<h2 id="esm">esm</h2>
<p>es6 及以后的 module 规范<br>
输出 export / export default<br>
引入 import</p>
<table>
<thead>
<tr>
<th>export</th>
<th>export default</th>
<th>import</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>只能输出对象</td>
<td>输出任意</td>
<td>引入</td>
<td></td>
<td></td>
</tr>
<tr>
<td>输出</td>
<td>输出默认对象</td>
<td>引入</td>
<td></td>
<td></td>
</tr>
<tr>
<td>可执行多次</td>
<td>只能执行一次</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>export a; export b;</code></td>
<td><code>export default {...}</code></td>
<td><code>import {...} from ...</code> 或 <code>import default from ...</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>现代浏览器已经支持<code>esm</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>&lt;script type=&quot;module&quot;&gt;
import v from '...'
// ...
&lt;/script&gt;
</code></pre>
<h2 id="iife">iife</h2>
<p>立即执行函数<br>
定义后立即执行的函数。</p>
<pre><code>vat global = {};
(function(global) {
    global.a = 'string'
    global.b = 0
})(global)
</code></pre>
<p>ts 的<code>enum</code>类型就是使用 iife.</p>
<pre><code class="language-js"><span class="hljs-comment">// 写法</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {}())
(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {})()
<span class="hljs-comment">// 块级作用域写法</span>
{
    <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {}
}
</code></pre>
<h2 id="system">system</h2>
<p>在<code>*.html</code>文件中以<code>&lt;script&gt;</code>的方式引入。</p>
<pre><code>&lt;script src=&quot;./first.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="es-module-和-commonjs">ES module 和 commonJS</h2>
<p>| | ES module | commonJS | | |
| - | | | - | - |
| | <code>*.mjs</code> | <code>*.cjs</code> | | |
| | 客户端运行 | 服务端运行 | | |
| | <code>import / export</code> | <code>require / module.exports</code> | | |
| | 若在 package.json 中设置 type：module，则为 esm 规范。 | 否则为 cjs 规范。 | | |
| 互相引用 | <code>import all form 'name'</code> | <code>(async () =&gt; {await import('./file.mjs')})()</code> | | |
| | 只能整体引入后再解构使用。 | | | |
| 同时支持 2 种规范 | <code>exports: {require: &quot;./index.js&quot;, import: &quot;./esm/index.js&quot;}</code> | | | |</p>
<h3 id="es-module-和-commonjs-循环引用问题">ES module 和 commonJS 循环引用问题</h3>
<p>因 esm、commonjs 对待文件(模式)的方式不同。</p>
<table>
<thead>
<tr>
<th>esm</th>
<th>commonjs</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>在内存中缓存该文件，再使用到该的地方指向文件。</td>
<td>执行该模块后返回一个对象。</td>
<td></td>
</tr>
<tr>
<td>进入文件后把文件在 Module Map 中标记为 fetching。解析完成为获取该文件的 Module Record.</td>
<td>执行了多少返回多少</td>
<td></td>
</tr>
<tr>
<td>循环引用不出问题</td>
<td>循环引用可能出问题</td>
<td></td>
</tr>
<tr>
<td>动态只读</td>
<td>复制后返回</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="解决-commonjs-的循环引用问题">解决 commonjs 的循环引用问题</h3>
<ol>
<li>利用变量提升+commonjs 的执行顺序。在模块的最后使用<code>var</code>定义引入的模块。</li>
<li>利用 js 的异步机制。在 setTimeout 中使用引入模块。</li>
</ol>
<h2 id="demo-for-import--export">demo for import &amp; export</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { key } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file.js&#x27;</span>
<span class="hljs-keyword">import</span> def <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file.js&#x27;</span>
<span class="hljs-keyword">import</span> { key <span class="hljs-keyword">as</span> alias } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file.js&#x27;</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./file.js&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./file.js&#x27;</span> <span class="hljs-comment">// 整个模块仅为副作用（中性词，无贬义含义）而导入，而不导入模块中的任何内容（接口）。 这将运行模块中的全局代码，但实际上不导入任何值。</span>
<span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./file.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">{<span class="hljs-keyword">default</span>: def, key}</span>) =&gt;</span> {...})

<span class="hljs-keyword">export</span> {key}
<span class="hljs-keyword">export</span> {key <span class="hljs-keyword">as</span> alias}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> key = <span class="hljs-string">&#x27;str&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> key

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CONSTANT</span> = <span class="hljs-number">42</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> variable = <span class="hljs-number">42</span>;
<span class="hljs-comment">// only reading is exposed</span>
<span class="hljs-comment">// it&#x27;s not possible to modify the variable from outside</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fun&#x27;</span>);
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Super</span> {
  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;method&#x27;</span>);
  }
}
<span class="hljs-keyword">let</span> a, b, other;
<span class="hljs-keyword">export</span> { a, b, other <span class="hljs-keyword">as</span> c };
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-title function_">more</span>();
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> xxx                   <span class="hljs-comment">// 把xxx中的非default全部导出</span>
<span class="hljs-keyword">export</span> {<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> alias} <span class="hljs-keyword">from</span> xxx  <span class="hljs-comment">// 把xxx中的default以alias导出</span>
</code></pre>
<h2 id="moduleexports--exports--export--export-defaut">module.exports &amp; exports &amp; export &amp; export defaut</h2>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>module.exports</th>
<th>exports</th>
<th>export</th>
<th>export default</th>
</tr>
</thead>
<tbody>
<tr>
<td>node.js 中的语法。用来导出对象用法。</td>
<td>node.js 中的语法。用来导出对象用法。</td>
<td>es6 的语法</td>
<td>es6 的语法</td>
</tr>
<tr>
<td>module.exports = {}</td>
<td>exports={}</td>
<td>export {var0, var1}</td>
<td>export default any</td>
</tr>
<tr>
<td>let t = require 'xxx'</td>
<td>let t = require 'xxx'</td>
<td>import {a, b as c} from 'map'</td>
<td>import a from 'map'</td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="指明包规范">指明包规范</h2>
<pre><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;module&quot;</span>
<span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span> <span class="hljs-comment">// 默认</span>
</code></pre>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>