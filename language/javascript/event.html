<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Event &#x5bf9;&#x8c61;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="event-对象">Event 对象</h1>
<p>创建一个新的事件对象 Event。<br>
这是合成事件。</p>
<pre><code class="language-js">event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(typeArg, eventInit);
typeArg string
eventInit {
    bubbles?: boolean <span class="hljs-comment">// 是否冒泡</span>
    cancelable?: boolean <span class="hljs-comment">// 是否可取消</span>
    composed?: boolean <span class="hljs-comment">// 是否可以穿过 Shadow DOM 和常规 DOM 之间的隔阂进行冒泡。</span>
}
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// demo</span>
<span class="hljs-keyword">let</span> ev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;look&#x27;</span>, {
  <span class="hljs-comment">// 定义</span>
  <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">false</span>,
})
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-comment">// 绑定</span>
  <span class="hljs-title function_">clog</span>(e)
})
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">dispatchEvent</span>(ev) <span class="hljs-comment">// 触发</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-title class_">Event</span>: {
  <span class="hljs-attr">bubbles</span>: boolean
  <span class="hljs-attr">cancelBubble</span>: boolean
  <span class="hljs-attr">cancelable</span>: boolean
  <span class="hljs-attr">composed</span>: boolean
  <span class="hljs-attr">currentTarget</span>: boolean
  <span class="hljs-attr">deepPath</span>: boolean <span class="hljs-comment">// 一个由事件流所经过的 DOM 节点组成的数组。</span>
  <span class="hljs-attr">defaultPrevented</span>: boolean <span class="hljs-comment">// 是否取消了事件的默认行为</span>
  <span class="hljs-comment">// 事件流正被处理到了哪个阶段。</span>
  <span class="hljs-comment">// 事件的明确（explicit）原始目标（Mozilla 专有属性）。</span>
  <span class="hljs-comment">// 重设目标前的事件原始目标（Mozilla 专有属性）。</span>
  <span class="hljs-attr">eventPhase</span>: <span class="hljs-attr">explicitOriginalTarget</span>: <span class="hljs-attr">originalTarget</span>: <span class="hljs-attr">returnValue</span>: <span class="hljs-attr">srcElement</span>: <span class="hljs-attr">target</span>: <span class="hljs-attr">timeStamp</span>: ms
  <span class="hljs-attr">type</span>: 事件的类型
  <span class="hljs-attr">isTrusted</span>: 是否由浏览器发起
  <span class="hljs-title function_">createEvent</span>()
  <span class="hljs-title function_">composedPath</span>() <span class="hljs-comment">// 原始事件目标的完整路径。由事件目标到根元素的路径上的元素组成的数组。</span>
  <span class="hljs-title function_">initEvent</span>()
  <span class="hljs-title function_">preventDefault</span>()
  <span class="hljs-title function_">stopImmediatePropagation</span>()
  <span class="hljs-title function_">stopPropagation</span>()
}
</code></pre>
<h1 id="customevent-对象">CustomEvent 对象</h1>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&#x27;second&#x27;</span>, { <span class="hljs-attr">detail</span>: <span class="hljs-string">&#x27;params&#x27;</span> })
<span class="hljs-comment">// detail 可以是任务数据、方法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">eventHandler</span>(<span class="hljs-params">e</span>) {
  <span class="hljs-title function_">clog</span>(e.<span class="hljs-property">detail</span>)
}
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;second&#x27;</span>, eventHandler)
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">dispatchEvent</span>(ev) <span class="hljs-comment">// 触发事件</span>
</code></pre>
<h1 id="绑定--解绑">绑定 &amp; 解绑</h1>
<p>| 绑定                                  | 解绑                                     |
| ------------------------------------- | ---------------------------------------- | ------- |
| <code>dom.onclick = fn</code>                    | <code>dom.onclick = null</code>                     | 带 on   |
| <code>dom.addEventListener(eventName, fn)</code> | <code>dom.removeEventListener(eventName, fn)</code> | 不带 on |
| <code>dom.attachEvent(eventName, fn)</code>      | <code>dom.detachEvent(eventName, fn)</code>         | 带 on   |</p>
<h1 id="事件流">事件流</h1>
<ul>
<li>捕获阶段</li>
<li>当前目标阶段</li>
<li>冒泡阶段</li>
</ul>
<p>ie 使用事件冒泡<br>
非 ie 使用事件捕获<br>
现代浏览器 先使用执行捕获阶段，再执行冒泡阶段。</p>
<h1 id="addeventlistener">addEventListener</h1>
<pre><code class="language-js">dom.<span class="hljs-title function_">addEventListener</span>(type, listener[, <span class="hljs-attr">options</span>: {
    <span class="hljs-attr">capture</span>: <span class="hljs-literal">false</span>      <span class="hljs-comment">// 是否在捕获阶段触发</span>
    <span class="hljs-attr">once</span>: <span class="hljs-literal">false</span>         <span class="hljs-comment">// 是否可执行多次</span>
    <span class="hljs-attr">passive</span>: boolean    <span class="hljs-comment">// 是否可取消默认行为。即：是否可执行preventDefault.</span>
    <span class="hljs-attr">signal</span>: <span class="hljs-title class_">AbortSignal</span> <span class="hljs-comment">// 当AbortSignal的abort()方法被调用时，监听器被移除。</span>
} | useCapture])
</code></pre>
<p>listener 是 EventListener 对象。</p>
<table>
<thead>
<tr>
<th>EventListener</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>handleEvent()</td>
<td>在事件被解决时调用的方法。</td>
<td>可用于在未调用前重置方法。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="removeeventlistener">removeEventListener</h1>
<pre><code class="language-js">dom.<span class="hljs-title function_">removeEventListener</span>(type, listener[, <span class="hljs-attr">options</span>: {
    <span class="hljs-attr">capture</span>: <span class="hljs-literal">false</span>
} | useCapture]) -&gt; <span class="hljs-literal">undefined</span>
</code></pre>
<p>drag 事件</p>
<p>keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。</p>
<p>keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。 按下 Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发 keypress 事件。</p>
<p>keyup：当用户释放键盘上的键时触发。</p>
<table>
<thead>
<tr>
<th>dom 的事件属性名（因 html 不区分大小写，所以全是小写）</th>
<th>说明</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>onclick</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ondbclick</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onkeyup</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onchange</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onfocus</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onblur</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onmouseover</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onmouseout</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onload</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onunload</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onsubmit</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>onreset</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="绑定事件">绑定事件</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fn()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 这里是字符串 有() --&gt;</span>
</code></pre>
<pre><code class="language-js">dom.<span class="hljs-property">onclick</span> = fn
<span class="hljs-comment">// 这里是方法     无()</span>
</code></pre>
<h1 id="onclick--addeventlistener">onclick &amp; addEventListener</h1>
<table>
<thead>
<tr>
<th></th>
<th>以 onclick 为例</th>
<th>addEventListener</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>由 click 事件触发</td>
<td>由指定事件触发</td>
</tr>
<tr>
<td>多次绑定</td>
<td>同一时间指向唯一的对象。若多次绑定，则覆盖以前绑定的。</td>
<td>若多次绑定，则不覆盖。</td>
</tr>
<tr>
<td>事件触发时</td>
<td>最后一次绑定的方法生效</td>
<td>所有绑定的方法都生效</td>
</tr>
<tr>
<td>触发阶段</td>
<td>不知道</td>
<td>可以指定</td>
</tr>
</tbody>
</table>
<h1 id="eventcomposed">event.composed</h1>
<p>composed 是 true，那么事件就能穿过边界。否则它仅能在 shadow DOM 内部捕获。
大部分事件都是 composed: true：
blur，focus，focusin，focusout，
click，dblclick，
mousedown，mouseup mousemove，mouseout，mouseover，
wheel，
beforeinput，input，keydown，keyup。
所有触摸事件（touch events）及指针事件（pointer events）都是 composed: true。</p>
<p>但也有些事件是 composed: false 的：
mouseenter，mouseleave（它们根本不会冒泡），
load，unload，abort，error，
select，
slotchange。
这些事件仅能在事件目标所在的同一 DOM 中的元素上捕获，</p>
<h1 id="extendableevent">ExtendableEvent</h1>
<p>创建一个 ExtendableEvent 对象。
service workers 中使用到了它。</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ExtendableEvent</span>(<span class="hljs-attr">type</span>: string[, <span class="hljs-attr">options</span>: object])
</code></pre>
<p>type 事件名
options 定义在 ExtendableEvent 对象上的自定义属性。</p>
<h2 id="extendableeventwaituntilpromise">ExtendableEvent.waitUntil(promise)</h2>
<p>方法告诉事件分发器该事件仍在进行。这个方法也可以用于检测进行的任务是否成功。在服务工作线程中，这个方法告诉浏览器事件一直进行，直至 promise 解决，浏览器不应该在事件中的异步操作完成之前终止服务工作线程。<br>
<strong>无返回</strong><br>
在 install 事件、actives 事件中使用，会让工作线程保持在 installing / activing 阶段。</p>
<h1 id="mouseover--mouseout--mouseenter--mouseleave">mouseover &amp; mouseout &amp; mouseenter &amp; mouseleave</h1>
<table>
<thead>
<tr>
<th></th>
<th>mouseover</th>
<th>mouseout</th>
<th>mouseenter</th>
<th>mouseleave</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>悬浮上</td>
<td>移出</td>
<td>进入</td>
<td>移出</td>
<td></td>
</tr>
<tr>
<td>冒泡</td>
<td>v 当前元素及其子元素触发</td>
<td>v</td>
<td>x, 当前元素触发</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="书写形式">书写形式</h1>
<table>
<thead>
<tr>
<th></th>
<th>demo</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>html</td>
<td><code>&lt;button onclick=&quot;clickH(...p)&quot;&gt;str&lt;/button&gt;</code></td>
<td>onclick 全是小写，因 html 是不区分大小写的语言。</td>
<td>其值写<code>()</code></td>
<td></td>
</tr>
<tr>
<td>js</td>
<td><code>dom.onclick=clickH(...p)</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>js</td>
<td><code>dom.addEventListener('click', clickH, false)</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>jq</td>
<td><code>${'#bt'}.click(() =&gt; {...})</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue</td>
<td><code>&lt;button @click=&quot;clickH(...p)&quot;&gt;</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue</td>
<td><code>h('button', {onClick: clickH})</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>react</td>
<td><code>&lt;button onClick={btClickHandler}&gt; string &lt;/button&gt;</code></td>
<td>驼峰命名法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>angular</td>
<td><code>&lt;button (click)=&quot;clickH(...p)&quot;&gt;str&lt;/button&gt;</code></td>
<td></td>
<td></td>
<td>angular 的写法与 html 的写法很接近。</td>
</tr>
</tbody>
</table>
<h2 id="selectionchange">selectionchange</h2>
<p>在当前 Document 的 Selection 改变时触发。</p>
<pre><code>addEventListener(&quot;selectionchange&quot;, (event) =&gt; {});
onselectionchange = (event) =&gt; {};

// addEventListener 版本
document.addEventListener(&quot;selectionchange&quot;, () =&gt; {
  console.log(document.getSelection());
});
// onselectionchange 版本
document.onselectionchange = () =&gt; {
  console.log(document.getSelection());
};
</code></pre>
<p>我发现在 focus 时也会触发此事件。</p>
<p><code>window.getSelection()</code>可以得到 Selection 对象。</p>
<pre><code>var selObj = window.getSelection();
var range = selObj.getRangeAt(0); // Range对象。
</code></pre>
<p>api</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>anchorNode</td>
<td>选区起点所在节点</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>anchorOffset</td>
<td>选区起点在 anchorNode 的偏移量</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>focusNode</td>
<td>选区终点所在的节点</td>
<td>只读</td>
<td></td>
<td></td>
</tr>
<tr>
<td>focusOffset</td>
<td>选区终点在 focusNode 的偏移量</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>isCollapsed</td>
<td>选区的起点、终点，是否在同一个位置</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>rangeCount</td>
<td>选区包含的连续范围的数量</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>getRangeAt()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>collapse()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>extend()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>modify()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>collapseToStart()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>collapseToEnd()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>selectAllChildren()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>addRange()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>removeRange()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>removeAllRanges()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>deleteFromDocument()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>toString()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>containsNode()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>