<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&DiacriticalGrave;vite&DiacriticalGrave;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="vite"><code>vite</code></h1>
<h2 id="overview">overview</h2>
<blockquote>
<p>一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，
套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。
强大的导入功能。
node v14.18.0+<br>
它是一个工具集。把一些常用的工具放在一起了。（像不像门面模式）构建功能大部分是基于rollup(esbuild)的。而且面向现代浏览器。<br>
它运行的快，原来是因为基于esbuild、做了很少工作、面向现代浏览。能不干的事儿，全不干了。</p>
</blockquote>
<h3 id="feature">feature</h3>
<ul>
<li>开发服务器</li>
<li>构建命令</li>
<li>默认以<code>&lt;root&gt;/index.html</code>为主入口。</li>
<li>在index.html中以<code>&lt;script type=&quot;module&quot; src=&quot;...&quot; /&gt;</code>和<code>&lt;link href=&quot;...&quot;&gt;</code>处理js/css。vite会处理js/css的引入工作。</li>
<li>可以实现多入口（即多页面）。</li>
<li>使用 Vite 开发和使用一个静态文件服务器并没有太大区别。然而，Vite 还通过原生 ESM 导入提供了许多主要用于打包场景的增强功能。</li>
<li>内部使用esbuild把要cjs/umd转换为esm（该过程叫预构建）。</li>
<li>已内置支持ts</li>
</ul>
<h2 id="install">install</h2>
<p>一般不用明确安装。<br>
<code>npm i vite -g</code></p>
<h2 id="usage">usage</h2>
<pre><code class="language-shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化一个项目</span>
npm init vite@latest
npm create vite@latest # cteate 是 init 的别名
yarn create vite
pnpm create vite
</code></pre>
<h2 id="功能">功能</h2>
<ul>
<li>提供一个类似静态文件服务器的功能。</li>
<li>vite对原生esm导入做了很多增强功能。
<ul>
<li>使用esbuild完成预构建（cjs/umd =&gt; esm）</li>
<li>重写导入为合法url</li>
<li>依赖是强缓存的。</li>
</ul>
</li>
<li>内置支持ts。不做类型检查。</li>
<li>esbuild做了
<ul>
<li>jsx / tsx</li>
<li>预构建（cjs/umd =&gt; esm）</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="设置esbuild配置项">设置esbuild配置项</h3>
<pre><code class="language-js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> {defineConfig} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
    <span class="hljs-attr">esbuild</span>: {
        <span class="hljs-attr">jsxFactory</span>: <span class="hljs-string">&#x27;h&#x27;</span>,
        <span class="hljs-attr">jsxFragment</span>: <span class="hljs-string">&#x27;fragment&#x27;</span>
    }
})
</code></pre>
<h3 id="css">css</h3>
<ul>
<li>导入的css文件会插入到style标签中。</li>
<li><code>@import</code>内联和变基</li>
<li>postcss。需要项目中使用<code>postcss.config.js</code>配置文件。应用于已导入的css.</li>
<li>以<code>.module.css</code>为后缀的css文件被认为是css moudes 文件。</li>
<li>需要安装预处理器</li>
<li>禁用css注入页面<code>import styles from './foo.css?inline'</code></li>
<li>导入静态资源<code>import imgUrl from './img.png'; document.querySelect(#id).src = imgUrl;</code></li>
<li>导入json<code>import json from './foo.json</code></li>
<li>
<h2 id="glob导入-importmetaglobparams">glob导入 <code>import.meta.glob(params)</code></h2>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 懒加载，动态导入实现。</span>
<span class="hljs-keyword">const</span> modules = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>) 
=&gt;
<span class="hljs-keyword">const</span> modules = {
    <span class="hljs-comment">// 以路径为key，值是返回Promise的方法</span>
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>),
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>)
}
<span class="hljs-comment">// 使用modules对象的key访问相应的模块</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> path <span class="hljs-keyword">in</span> modules) {
    modules[path]().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">mod</span>) =&gt;</span> {...})
}
<span class="hljs-comment">// 导入所有模块</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, {<span class="hljs-attr">eager</span>: <span class="hljs-literal">true</span>})
=&gt;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> __glob__0_0 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> __glob__0_1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>
<span class="hljs-keyword">const</span> m = {
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: __glob__0_0,
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: __glob__0_1,
}
<span class="hljs-comment">// 以字符串形式导入资源</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, {<span class="hljs-keyword">as</span> : <span class="hljs-string">&#x27;raw&#x27;</span>})
=&gt;
<span class="hljs-keyword">const</span> m = {
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: <span class="hljs-string">&#x27;export default &quot;foo&quot;\n&#x27;</span>,
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: <span class="hljs-string">&#x27;export default &quot;bar&quot;\n&#x27;</span>
}
<span class="hljs-comment">// 若as: &#x27;url&#x27;，则把资源作为url加载。</span>
<span class="hljs-comment">// 多个匹配</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>([<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, <span class="hljs-string">&#x27;./a/*.js&#x27;</span>])
<span class="hljs-comment">// 排除</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>([<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, <span class="hljs-string">&#x27;!**/bar.js&#x27;</span>])
<span class="hljs-comment">// 具名导入</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, {<span class="hljs-attr">import</span>: <span class="hljs-string">&#x27;setup&#x27;</span>})
=&gt;
<span class="hljs-keyword">const</span> m = {
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">setup</span>),
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">setup</span>)
}
<span class="hljs-comment">// import: &#x27;setup&#x27;, eager: true 会执行tree-shaking</span>
<span class="hljs-comment">// import: &#x27;default&#x27; 会加载默认导出</span>
<span class="hljs-comment">// 自定义查询</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, {
    <span class="hljs-attr">query</span>: {<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span>}
})
=&gt;
<span class="hljs-keyword">const</span> m = {
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/foo.js?foo=bar&amp;bar=true&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">setup</span>) <span class="hljs-comment">// 没有使用具名导入。为什么只导入setup呢？</span>
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/bar.js?foo=bar&amp;bar=true&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">setup</span>) <span class="hljs-comment">// 没有使用具名导入。为什么只导入setup呢？</span>
}
<span class="hljs-comment">// 动态导入</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">await</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">`./dir/<span class="hljs-subst">${file}</span>.js`</span>)
</code></pre>
<h3 id="web-worker">web worker</h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>))
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>), {
  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;module&#x27;</span>
})
<span class="hljs-comment">// worker 脚本将在生产构建中编译成单独的 chunk。</span>
<span class="hljs-comment">// 可以在导入请求上添加 ?worker 或 ?sharedworker 查询参数来直接导入一个 web worker 脚本。</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyWorker</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./worker?worker&#x27;</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWorker</span>()
<span class="hljs-comment">// 想将 worker 内联为 base64 字符串，请添加 inline 查询参数：</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyWorker</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./worker?worker&amp;inline&#x27;</span>
<span class="hljs-comment">// 添加 url 这个 query.会将一个 URL 的形式读取该 worker</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyWorker</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./worker?worker&amp;url&#x27;</span>
</code></pre>
<h3 id="异步-chunk-加载优化">异步 Chunk 加载优化</h3>
<p>会把多个chunk中共用的chunk一起打包。</p>
<h2 id="插件">插件</h2>
<p>vite的插件是基于rollup的插件，只是增加一个vite的特有配置项。可以用于服务器。</p>
<pre><code class="language-js"><span class="hljs-comment">// 添加插件</span>
npm add -D @vitejs/plugin-legacy

<span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> legacy <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-legacy&#x27;</span>
<span class="hljs-keyword">import</span> image <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@rollup/plugin-image&#x27;</span>
<span class="hljs-keyword">import</span> {defineConfig} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
    <span class="hljs-attr">plugins</span>: [ <span class="hljs-comment">// 可以接受多个插件。若无效则不使用。</span>
        <span class="hljs-title function_">legacy</span>({
            <span class="hljs-attr">targets</span>: [<span class="hljs-string">&#x27;defaults&#x27;</span>, <span class="hljs-string">&#x27;not IE 11&#x27;</span>]
        }),
        {
            ...<span class="hljs-title function_">image</span>(),
            <span class="hljs-attr">enforce</span>: <span class="hljs-string">&#x27;pre&#x27;</span> <span class="hljs-comment">// 使用此字段明确指定本插件与vite core plugins的执行顺序。</span>
            <span class="hljs-comment">// pre </span>
            <span class="hljs-comment">// default 默认post</span>
            <span class="hljs-comment">// post </span>
            <span class="hljs-attr">apply</span>: <span class="hljs-string">&#x27;build&#x27;</span> <span class="hljs-comment">// 明确在哪个期间执行，默认2个期间都执行。</span>
            <span class="hljs-comment">// build</span>
            <span class="hljs-comment">// serve</span>
        }
    ]
})
</code></pre>
<h3 id="发现插件">发现插件</h3>
<p><a href="https://vite-rollup-plugins.patak.dev/">vite rollup plugins 的网站</a></p>
<h3 id="插件api">插件api</h3>
<h4 id="习惯">习惯</h4>
<p>推荐使用rollup的命名习惯。</p>
<ul>
<li>以<code>rollup-plugin-</code>开头</li>
<li>包括<code>rollup-plugin vite-plugin</code>关键字。</li>
</ul>
<p>若只对vite开发的插件。</p>
<ul>
<li>以<code>vite-plugin-</code>开头</li>
<li>包括<code>vite-plugin</code>关键字。
<ul>
<li>也可以以特定框架说明<code>vite-plugin-vue-</code> / <code>vite-plugin-react-</code> / <code>vite-plugin-svelte-</code></li>
</ul>
</li>
</ul>
<h4 id="插件的配置">插件的配置</h4>
<p>一般这样使用插件</p>
<pre><code class="language-js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> {defineConfig} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>
<span class="hljs-keyword">import</span> {framework} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-frame-work&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
    <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">framework</span>()]
})
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myPlugin</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> virtualModuleId = <span class="hljs-string">&#x27;virtual:my-module&#x27;</span>
    <span class="hljs-keyword">const</span> resolvedVirtualModuleId = <span class="hljs-string">&#x27;\0&#x27;</span> + virtualModuleId
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;plugin-name&#x27;</span>,
        <span class="hljs-title function_">transform</span>(<span class="hljs-params">src, id</span>) {
            <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(id)) {
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">code</span>: <span class="hljs-title function_">fn</span>(src),
                    <span class="hljs-attr">map</span>: <span class="hljs-literal">null</span>
                }
            }
        },
        <span class="hljs-title function_">load</span>(<span class="hljs-params">id</span>) {
            <span class="hljs-keyword">if</span>(id === resolvedVirtualModuleId) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">`export const msg = &#x27;from virtual module&#x27;`</span>
            }
        }
    }
}
</code></pre>
<h5 id="virtual-modules-convention">virtual modules convention</h5>
<p>把打包时的信息给源文件，用于esm语法导入。</p>
<h4 id="钩子">钩子</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>options</td>
<td>在服务端调用一次</td>
<td></td>
<td></td>
</tr>
<tr>
<td>buildStart</td>
<td>在服务端调用一次</td>
<td></td>
<td></td>
</tr>
<tr>
<td>resolveId</td>
<td>每交进入模块时调用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>load</td>
<td>每交进入模块时调用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>transform</td>
<td>每交进入模块时调用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>buildEnd</td>
<td>当服务器关闭时调用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>closeBundle</td>
<td>当服务器关闭时调用</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="vite的钩子">vite的钩子</h4>
<p>不会作用于rollup</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>config</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>configResolved</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>configureServer</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>configurePreviewServer</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>transformIndexHtml</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>handleHotUpdate</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="插件的顺序">插件的顺序</h4>
<ul>
<li>alias</li>
<li>使用enforce: 'pre'的插件</li>
<li>vite core 插件</li>
<li>未设置enforce的插件</li>
<li>vite build 插件</li>
<li>使用enforce: 'post'的插件</li>
<li>打包后的插件（minify / manifest / reporting）</li>
</ul>
<h2 id="依赖预构建">依赖预构建</h2>
<ul>
<li>兼容cjs/umd</li>
<li>把多个esm依赖关系的内部模块转换为单个模块。</li>
<li>自动依赖搜寻
<ol>
<li>从缓存中找</li>
<li>从node_modules中找</li>
</ol>
</li>
<li>在一库多包中，自动侦测不在node_modules中的依赖项。</li>
<li>vite使用强缓存。<code>max-age=31536000,immutable</code></li>
<li>文件系统缓存。当下列一个改变时重新运行预构建
<ul>
<li>package.json中的dependencies</li>
<li>lockfile</li>
<li>vite.config.js</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="静态资源">静态资源</h2>
<p>通过在导入时的url中设置qs.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>引入静态资源。</td>
<td>在开发环境使用相对链接。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>在生产环境使用绝对链接。（从根路径开始）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?url</td>
<td>导入一个url</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?raw</td>
<td>导入字符串</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?worker / ?sharedworker</td>
<td>导入为web worker</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?inline</td>
<td>导入为base64字符串</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="poblic目录">poblic目录</h3>
<ul>
<li>不会被源码引用（例如 robots.txt）</li>
<li>必须保持原有文件名（没有经过 hash）</li>
<li>...或者你压根不想引入该资源，只是想得到其 URL。<code>&lt;root&gt;/public</code></li>
</ul>
<h3 id="new-urlurl-importmetaurl">new URL(url, import.meta.url)</h3>
<p>import.meta.url中esm的原生功能。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> imgUrl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./img.png&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">mete</span>.<span class="hljs-property">url</span>).<span class="hljs-property">href</span>
img.<span class="hljs-property">src</span> = imgUrl <span class="hljs-comment">// 使用</span>
</code></pre>
<h2 id="构建生产版本">构建生产版本</h2>
<h3 id="公共基础路径">公共基础路径</h3>
<p>如果你需要在嵌套的公共路径下部署项目，只需指定 base 配置项。<br>
结果：在css中使用url() / html文件中的引用 都是基于引配置项的。
以命令行方式设置base。</p>
<pre><code class="language-shell">vite build --base=/my/public/path/。
</code></pre>
<h3 id="自定义构建">自定义构建</h3>
<pre><code class="language-js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: { <span class="hljs-comment">// 调整低层rollup选项</span>
      <span class="hljs-comment">// https://rollupjs.org/guide/en/#big-list-of-options</span>
    },
    <span class="hljs-attr">watch</span>: {...} <span class="hljs-comment">// 文件变化时重新构建</span>
    <span class="hljs-attr">rollupOptions</span>: { <span class="hljs-comment">// 多入口打包</span>
      <span class="hljs-attr">input</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;index.html&#x27;</span>),
        <span class="hljs-attr">nested</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;nested/index.html&#x27;</span>)
      }
    }
    <span class="hljs-attr">lib</span>: { <span class="hljs-comment">// 当这个库要进行发布构建</span>
        <span class="hljs-attr">entry</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;lib/main.js&#x27;</span>),
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MyLib&#x27;</span>,
        <span class="hljs-comment">// the proper extensions will be added</span>
        <span class="hljs-attr">fileName</span>: <span class="hljs-string">&#x27;my-lib&#x27;</span>
    }
  }
})
</code></pre>
<h2 id="部署静态站点">部署静态站点</h2>
<pre><code>{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;preview&quot;: &quot;vite preview --port 8080&quot;
  }
}
</code></pre>
<h2 id="环境变量和模式">环境变量和模式</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">MODE</span>        <span class="hljs-comment">// 应用运行的模式</span>
<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>    <span class="hljs-comment">// 基本url.  base</span>
<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">PROD</span>        <span class="hljs-comment">// 是否是生产环境</span>
<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">DEV</span>         <span class="hljs-comment">// 是否是开发环境</span>
<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">SSR</span>         <span class="hljs-comment">// 是否运行在server上</span>
</code></pre>
<h3 id="env文件"><code>.env</code>文件</h3>
<pre><code>.env                # 所有情况下都会加载
.env.local          # 所有情况下都会加载，但会被 git 忽略
.env.[mode]         # 只在指定模式下加载
.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略
</code></pre>
<p>mode是此环境文件的名称。</p>
<p>常用的环境变量名称</p>
<pre><code>.env
.env.production
.env.test
.env.development
</code></pre>
<pre><code># 定义
# 必须以VITE_开头。否则不会被vite处理。
VITE_SOME_KEY=123
# $必须被转义
VITE_KEY2=a\$b
</code></pre>
<p>使用环境变量</p>
<pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_SOME_KEY</span>)
</code></pre>
<p>使用环境文件</p>
<pre><code class="language-shell">vite build --mode development
</code></pre>
<h3 id="环境文件--类型">环境文件 &amp; 类型</h3>
<p><code>env.d.ts</code></p>
<pre><code class="language-ts"><span class="hljs-comment">/// &lt;reference types=&quot;vite/client&quot;&gt;</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImportMetaEnv</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">VITE_APP_TITLE</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImportMeta</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">env</span>: <span class="hljs-title class_">ImportMetaEnv</span>
}
</code></pre>
<h2 id="服务端渲染">服务端渲染</h2>
<p>示例项目</p>
<ul>
<li><a href="https://github.com/vitejs/vite/tree/main/playground/ssr-vue">vue3</a></li>
<li><a href="https://github.com/vitejs/vite/tree/main/playground/ssr-react">react</a></li>
</ul>
<h2 id="后端集成">后端集成</h2>
<pre><code class="language-js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">build</span>: {
    <span class="hljs-comment">// 在 outDir 中生成 manifest.json</span>
    <span class="hljs-attr">manifest</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-comment">// 覆盖默认的 .html 入口</span>
      <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;/path/to/main.js&#x27;</span>
    }
  }
})
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 如果是在开发环境中 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:5173/@vite/client&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:5173/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>执行<code>vite build</code>后，会生成 <a href="/browser/manifestJson.html"><code>manifest.json</code></a> 文件</p>
<pre><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;main.js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;assets/main.4889e940.js&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;src&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;main.js&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;isEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;dynamicImports&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;views/foo.js&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;assets/main.b82dbe22.css&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;assets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;assets/asset.0ab0f9cd.png&quot;</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;views/foo.js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;assets/foo.869aea0d.js&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;src&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;views/foo.js&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;isDynamicEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;imports&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;_shared.83069a53.js&quot;</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;_shared.83069a53.js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;assets/shared.83069a53.js&quot;</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 id="configuration">configuration</h2>
<p>默认配置文件：<code>vite.config.js</code>。<br>
它是被node.js使用。</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(<span class="hljs-function">(<span class="hljs-params">{ command, mode, ssrBuild }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (command === <span class="hljs-string">&#x27;serve&#x27;</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">// dev 独有配置</span>
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// command === &#x27;build&#x27;</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">// build 独有配置</span>
    }
  }
})
<span class="hljs-comment">// 异步配置 // js中总是优先异步。</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(<span class="hljs-keyword">async</span> ({ command, mode }) =&gt; {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunction</span>()
  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// vite 配置</span>
  }
})
<span class="hljs-comment">// 可以引用环境变量后使用。</span>
<span class="hljs-keyword">import</span> { defineConfig, loadEnv } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key</th>
<th>说明</th>
<th>类型</th>
<th>默认值</th>
<th>其他枚举值</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>共享配置</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>root</td>
<td>项目根目录</td>
<td>string</td>
<td>processs.cwd()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>base</td>
<td>基础路径。（类似html中base标签）</td>
<td>string</td>
<td><code>'/'</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>mode</td>
<td>模式</td>
<td>string</td>
<td>'development'</td>
<td>'production'</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>define</td>
<td>定义全局常量替换方式</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>plugins</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>publicDir</td>
<td>静态资源服务的文件夹</td>
<td></td>
<td>'public'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>cacheDir</td>
<td>存储缓存文件的目录。此目录下会存储预打包的依赖项或 vite 生成的某些缓存文件</td>
<td></td>
<td>'node_modules/.vite'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>resovle.alias</td>
<td>将会被传递到 @rollup/plugin-alias 作为 entries 的选项</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>resovle.dedupe</td>
<td>如果你在你的应用程序中有相同依赖的副本（比如 monorepos），请使用此选项强制 Vite 始终将列出的依赖项解析为同一副本（从项目根目录）。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>resovle.conditions</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>resovle.mainFields</td>
<td>在解析包的入口点时尝试的字段列表。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>resovle.extensions</td>
<td>导入时想要省略的扩展名列表。</td>
<td></td>
<td>['.mjs', '.js', '.ts', '.jsx', '.tsx', '.json']</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>resovle.preserveSymlinks</td>
<td>是否通过原始文件路径</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>css.modules</td>
<td>配置 CSS modules 的行为。选项将被传递给 postcss-modules</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>css.postcss</td>
<td>内联的 PostCSS 配置</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>css.preprocessorOptions</td>
<td>指定传递给 CSS 预处理器的选项。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>css.devSourcemap</td>
<td>在开发过程中是否启用 sourcemap。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>json.namedExports</td>
<td>是否支持从 .json 文件中进行按名导入。</td>
<td></td>
<td>true</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>json.stringify</td>
<td>若设置为 true，导入的 JSON 会被转换为 export default JSON.parse(&quot;...&quot;)，这样会比转译成对象字面量性能更好，尤其是当 JSON 文件较大的时候。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>esbuild</td>
<td>传递给esbuild的配置项</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>assetsInclude</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>logLevel</td>
<td>调整控制台输出的级别，默认为 'info'。</td>
<td></td>
<td></td>
<td>'info'</td>
<td>'warn'</td>
<td>'error'</td>
</tr>
<tr>
<td></td>
<td>clearScreen</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>envDir</td>
<td>用于加载 .env 文件的目录</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>envPrefix</td>
<td>以 envPrefix 开头的环境变量会通过 import.meta.env 暴露在你的客户端源码中。</td>
<td></td>
<td>'VITE_'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>appType</td>
<td></td>
<td></td>
<td></td>
<td>'spa'</td>
<td>'mpa'</td>
<td>'custom'</td>
</tr>
<tr>
<td>服务器选项</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.host</td>
<td>指定服务器应该监听哪个 IP 地址。</td>
<td></td>
<td>'localhost'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.port</td>
<td>指定开发服务器端口。</td>
<td></td>
<td>5173</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.strictPort</td>
<td>设为 true 时若端口已被占用则会直接退出，而不是尝试下一个可用端口。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.https</td>
<td>启用 TLS + HTTP/2</td>
<td>boolean</td>
<td>https.ServerOptions</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.open</td>
<td>在开发服务器启动时自动在浏览器中打开应用程序。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.proxy</td>
<td>为开发服务器配置自定义代理规则。与vue2的代理很像。</td>
<td>{ key: options }</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.cors</td>
<td>为开发服务器配置 CORS</td>
<td>boolean / CorsOptions</td>
<td>默认启用并允许任何源</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.headers</td>
<td>指定服务器响应的 header。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.hmr</td>
<td>禁用或配置 HMR 连接</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.watch</td>
<td>传递给 chokidar 的文件系统监听器选项。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.middlewareMode</td>
<td>以中间件模式创建 Vite 服务器。（不含 HTTP 服务器）</td>
<td></td>
<td></td>
<td>'ssr'</td>
<td>'html'</td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.base</td>
<td>在 HTTP 请求中预留此文件夹，用于代理 Vite 作为子文件夹时使用。应该以 / 字符开始和结束。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.fs.strict</td>
<td>限制为工作区 root 路径以外的文件的访问。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.fs.allow</td>
<td>限制哪些文件可以通过 /@fs/ 路径提供服务。当 server.fs.strict 设置为 true 时，访问这个目录列表外的文件将会返回 403 结果。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.fs.deny</td>
<td>用于限制 Vite 开发服务器提供敏感文件的黑名单。</td>
<td></td>
<td>['.env', '.env.<em>', '</em>.{pem,crt}']</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>server.origin</td>
<td>用于定义开发调试阶段生成资产的 origin。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>构建选项</td>
<td></td>
<td>与服务器选项差不多</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.target</td>
<td>设置最终构建的浏览器兼容目标。</td>
<td></td>
<td>'modules'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.polyfillModulePreload</td>
<td>用于决定是否自动注入 module preload 的 polyfill.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.outDir</td>
<td>指定输出路径（相对于 项目根目录).</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.assetsDir</td>
<td>指定生成静态资源的存放路径（相对于 build.outDir）。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.assetsInlineLimit</td>
<td>小于此阈值的导入或引用资源将内联为 base64 编码，</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.cssCodeSplit</td>
<td>启用/禁用 CSS 代码拆分。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.cssTarget</td>
<td>此选项允许用户为 CSS 的压缩设置一个不同的浏览器 target，</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.sourcemap</td>
<td>构建后是否生成 source map 文件</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.rollupOptions</td>
<td>自定义底层的 Rollup 打包配置。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.commonjsOptions</td>
<td>传递给 @rollup/plugin-commonjs 插件的选项。</td>
<td>这都要用一个配置项。要是再多几个插件，是不是会再多几个配置项呀。vue团队真是神坑</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.dynamicImportVarsOptions</td>
<td>传递给 @rollup/plugin-dynamic-import-vars 的选项。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.lib</td>
<td>构建为库</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.manifest</td>
<td>当设置为 true，构建后将会生成 manifest.json 文件，</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.ssrManifest</td>
<td>构建也将生成 SSR 的 manifest 文件，</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.ssr</td>
<td>生成面向 SSR 的构建</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.minify</td>
<td>设置为 false 可以禁用最小化混淆</td>
<td>boolean 、 'terser' 、 'esbuild'</td>
<td>'esbuild'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.terserOptions</td>
<td>传递给 Terser 的更多 minify 选项。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.write</td>
<td>设置为 false 来禁用将构建后的文件写入磁盘。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.emptyOutDir</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.reportCompressedSize</td>
<td>启用/禁用 gzip 压缩大小报告。</td>
<td>boolean</td>
<td>true</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.chunkSizeWarningLimit</td>
<td>规定触发警告的 chunk 大小。(kbs)</td>
<td>number</td>
<td>500</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>build.watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>预览选项</td>
<td>与上面的差不多</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>preview.host</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>preview.port</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>preview.strictPort</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>preview.https</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>preview.open</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>preview.proxy</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>preview.cors</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>依赖优先选项</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>optimizeDeps.entries</td>
<td>默认情况下，Vite 会抓取你的 index.html 来检测需要预构建的依赖项（忽略了node_modules、build.outDir、<code>__tests__</code> 和 coverage）。如果指定了 build.rollupOptions.input，Vite 将转而去抓取这些入口点。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>optimizeDeps.exclude</td>
<td>在预构建中强制排除的依赖项。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>optimizeDeps.include</td>
<td>使用此选项可强制预构建链接的包。</td>
<td>string[]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>optimizeDeps.esbuildOptions</td>
<td>在部署扫描和优化过程中传递给 esbuild 的选项。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>optimizeDeps.force</td>
<td>设置为 true 可以强制依赖预构建，而忽略之前已经缓存过的、已经优化过的依赖。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ssr选项</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ssr.external</td>
<td>要为 SSR 强制外部化的依赖。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ssr.noExternal</td>
<td>列出的是防止被 SSR 外部化依赖项。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ssr.target</td>
<td>SSR 服务器的构建目标。</td>
<td>'node' / 'webworker'</td>
<td>'node'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ssr.format</td>
<td>SSR 服务器的构建语法格式。</td>
<td>'esm' / 'cjs'</td>
<td>'esm'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>worker选项</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>worker.format</td>
<td>worker 打包时的输出类型。</td>
<td>'es' / 'iife'</td>
<td>'iife'</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>worker.plugins</td>
<td>应用于 worker 打包的 Vite 插件。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>worker.rollupOptions</td>
<td>用于打包 worker 的 Rollup 配置项。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="title">title</h2>
<h2 id="title-1">title</h2>
<h2 id="title-2">title</h2>
<h2 id="title-3">title</h2>
<h2 id="api">api</h2>
<p><code>vite.fn(param, first: string, second: boolean = true) =&gt; void</code>
description</p>
<p><code>vite.fn(param, [options: {a: string, b?: number}])</code>
description</p>
<h2 id="principle">principle</h2>
<p>此包的处理逻辑。</p>
<h3 id="uml">uml</h3>
<pre><code></code></pre>
<h2 id="todo">todo</h2>
<blockquote>
<p>服务端使用cjs规范，vite使用esm规范。vite是如何提供服务能力的？
官方文档写的太烂了。
如果一个项目需要维护4-5以上。不要用vue，用react。vue的迭代变化太大。vue的迭代问题，react都没有。
vue1 =&gt; vue2 =&gt; vue3 一次比一次变化大。从1到2还有一个一完全迁移工具。从2到3完全是重构。
vue团队急于求成。为了抢占市场，推出不完成产品。后期迭代变化巨大。好多api改变了用法。
如何才能做到写好文档
写好项目（如：结构化）
按功能模块写基本使用文档。说清如何使用基本功能。
再整理一个完整api
再聊一下运行逻辑、源码。
如何扩展、做插件
我不喜欢这个项目。
vue团队就喜欢搞些方便使用的畸型代码。把data/methods都放在vm上。把VITE_开头的变量放在import.meta.env上。<br>
未来迭代计划。
未来迭代计划。
未来迭代计划。</p>
</blockquote>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>