<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>vite</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="vite">vite</h1>
<h2 id="overview">overview</h2>
<blockquote>
<p><a href="https://vite.dev/guide/">官网</a>
是一个开发时服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，<br>
基于 rollup 提供打包功能，vite 插件也就是被 rollup 使用的。<br>
基于 rollup 提供插件功能。<br>
以 esm 规范提供代码。然后由浏览器处理。<br>
套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。<br>
强大的导入功能。<br>
需要与支持 esm 语法的浏览器配合工作。<br>
node v14.18.0+<br>
它是一个工具集。把一些常用的工具放在一起了。（像不像门面模式）构建功能大部分是基于 rollup(esbuild)的。而且面向现代浏览器。<br>
它运行的快，原来是因为基于 esbuild、做了很少工作、面向现代浏览。能不干的事儿，全不干了。<br>
本地开发服务器+构建工具。<br>
根目录下的index.html为入口，若根目录下有多个html文件，是可以支持多入口。
分为预编译阶段（esbuild）和打包阶段（rollup）<br>
支持ts</p>
</blockquote>
<h3 id="feature">feature</h3>
<ul>
<li>开发服务器</li>
<li>构建命令</li>
<li>默认以<code>&lt;root&gt;/index.html</code>为主入口。</li>
<li>在 index.html 中以<code>&lt;script type=&quot;module&quot; src=&quot;...&quot; /&gt;</code>和<code>&lt;link href=&quot;...&quot;&gt;</code>处理 js/css。vite 会处理 js/css 的引入工作。</li>
<li>可以实现多入口（即多页面）。</li>
<li>使用 Vite 开发和使用一个静态文件服务器并没有太大区别。然而，Vite 还通过原生 ESM 导入提供了许多主要用于打包场景的增强功能。</li>
<li>内部使用 esbuild 把要 cjs/umd 转换为 esm（该过程叫预构建）。</li>
<li>由 esbuild ts=&gt;js</li>
<li>支持 ts</li>
<li>支持 hmr</li>
<li>预览功能。（先打包才能在本地预览）<code>npm run preview</code></li>
</ul>
<h2 id="install">install</h2>
<p>一般不用明确安装。</p>
<pre><code class="language-shell">npm i vite -g
pnpm install -g create-vite
</code></pre>
<h2 id="usage">usage</h2>
<pre><code class="language-shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化一个项目</span>
npm init vite@latest
npm create vite@latest # cteate 是 init 的别名
yarn create vite
pnpm create vite
create-vite my-project
<span class="hljs-meta prompt_"># </span><span class="language-bash">然后会提示选择什么模板。</span>

vite # 启动
</code></pre>
<h2 id="功能">功能</h2>
<ul>
<li>提供一个类似静态文件服务器的功能。</li>
<li>vite 对原生 esm 导入做了很多增强功能。
<ul>
<li>使用 esbuild 完成预构建（cjs/umd =&gt; esm）</li>
<li>重写导入为合法 url</li>
<li>依赖是强缓存的。</li>
</ul>
</li>
<li>内置支持 ts。不做类型检查。</li>
<li>esbuild 做了
<ul>
<li>jsx / tsx</li>
<li>预构建（cjs/umd =&gt; esm）</li>
</ul>
</li>
<li>hmr</li>
<li>使用 esbuild 完成 ts=&gt;js
<ul>
<li>tsconfig.json
<ul>
<li>isolatedModules: true</li>
<li>useDefineForClassFields: true</li>
</ul>
</li>
</ul>
</li>
<li>把<code>*.css</code>放入<code>&lt;style&gt;</code>内。
<ul>
<li>postcss</li>
<li>css modules</li>
<li>css 预处理器</li>
</ul>
</li>
<li>处理静态资源。把相对路径变为可解析的 url.</li>
<li>支持 worker</li>
<li>构建优化
<ul>
<li>css 代码分割</li>
<li>生成预加载指令</li>
<li>优化异步 chunk 加载</li>
</ul>
</li>
</ul>
<h3 id="设置-esbuild-配置项">设置 esbuild 配置项</h3>
<pre><code class="language-js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">esbuild</span>: {
    <span class="hljs-attr">jsxFactory</span>: <span class="hljs-string">&#x27;h&#x27;</span>,
    <span class="hljs-attr">jsxFragment</span>: <span class="hljs-string">&#x27;fragment&#x27;</span>,
  },
})
</code></pre>
<h3 id="css">css</h3>
<ul>
<li>导入的 css 文件会插入到 style 标签中。</li>
<li><code>@import</code>内联和变基</li>
<li>postcss。需要项目中使用<code>postcss.config.js</code>配置文件。应用于已导入的 css.</li>
<li>以<code>.module.css</code>为后缀的 css 文件被认为是 css moudes 文件。</li>
<li>需要安装预处理器</li>
<li>禁用 css 注入页面<code>import styles from './foo.css?inline'</code></li>
<li>导入静态资源<code>import imgUrl from './img.png'; document.querySelect(#id).src = imgUrl;</code></li>
<li>导入 json <code>import json from './foo.json</code></li>
<li>
<h2 id="glob-导入-importmetaglobparams">glob 导入 <code>import.meta.glob(params)</code></h2>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 懒加载，动态导入实现。</span>
<span class="hljs-keyword">const</span> modules = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>)
=&gt; <span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> modules = {
    <span class="hljs-comment">// 以路径为key，值是返回Promise的方法</span>
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>),
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>)
}
<span class="hljs-comment">// 使用modules对象的key访问相应的模块</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> path <span class="hljs-keyword">in</span> modules) {
    modules[path]().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">mod</span>) =&gt;</span> {...})
}
<span class="hljs-comment">// 导入所有模块</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, {<span class="hljs-attr">eager</span>: <span class="hljs-literal">true</span>})
=&gt;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> __glob__0_0 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> __glob__0_1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>
<span class="hljs-keyword">const</span> m = {
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: __glob__0_0,
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: __glob__0_1,
}
<span class="hljs-comment">// 以字符串形式导入资源</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, {<span class="hljs-keyword">as</span> : <span class="hljs-string">&#x27;raw&#x27;</span>})
=&gt;
<span class="hljs-keyword">const</span> m = {
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: <span class="hljs-string">&#x27;export default &quot;foo&quot;\n&#x27;</span>,
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: <span class="hljs-string">&#x27;export default &quot;bar&quot;\n&#x27;</span>
}
<span class="hljs-comment">// 若as: &#x27;url&#x27;，则把资源作为url加载。</span>
<span class="hljs-comment">// 多个匹配</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>([<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, <span class="hljs-string">&#x27;./a/*.js&#x27;</span>])
<span class="hljs-comment">// 排除</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>([<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, <span class="hljs-string">&#x27;!**/bar.js&#x27;</span>])
<span class="hljs-comment">// 具名导入</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, {<span class="hljs-attr">import</span>: <span class="hljs-string">&#x27;setup&#x27;</span>})
=&gt;
<span class="hljs-keyword">const</span> m = {
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">setup</span>),
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">setup</span>)
}
<span class="hljs-comment">// import: &#x27;setup&#x27;, eager: true 会执行tree-shaking</span>
<span class="hljs-comment">// import: &#x27;default&#x27; 会加载默认导出</span>
<span class="hljs-comment">// 自定义查询</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./dir/*.js&#x27;</span>, {
    <span class="hljs-attr">query</span>: {<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span>}
})
=&gt;
<span class="hljs-keyword">const</span> m = {
    <span class="hljs-string">&#x27;./dir/foo.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/foo.js?foo=bar&amp;bar=true&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">setup</span>) <span class="hljs-comment">// 没有使用具名导入。为什么只导入setup呢？</span>
    <span class="hljs-string">&#x27;./dir/bar.js&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./dir/bar.js?foo=bar&amp;bar=true&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">setup</span>) <span class="hljs-comment">// 没有使用具名导入。为什么只导入setup呢？</span>
}
<span class="hljs-comment">// 动态导入</span>
<span class="hljs-keyword">const</span> m = <span class="hljs-keyword">await</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">`./dir/<span class="hljs-subst">${file}</span>.js`</span>)
</code></pre>
<h3 id="web-worker">web worker</h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>))
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>), {
  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;module&#x27;</span>,
})
<span class="hljs-comment">// worker 脚本将在生产构建中编译成单独的 chunk。</span>
<span class="hljs-comment">// 可以在导入请求上添加 ?worker 或 ?sharedworker 查询参数来直接导入一个 web worker 脚本。</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyWorker</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./worker?worker&#x27;</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWorker</span>()
<span class="hljs-comment">// 想将 worker 内联为 base64 字符串，请添加 inline 查询参数：</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyWorker</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./worker?worker&amp;inline&#x27;</span>
<span class="hljs-comment">// 添加 url 这个 query.会将一个 URL 的形式读取该 worker</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyWorker</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./worker?worker&amp;url&#x27;</span>
</code></pre>
<h3 id="异步-chunk-加载优化">异步 Chunk 加载优化</h3>
<p>会把多个 chunk 中共用的 chunk 一起打包。</p>
<h2 id="cli"><a href="/builder/vite/cli.html">cli</a></h2>
<h2 id="插件"><a href="/builder/vite/plugin.html">插件</a></h2>
<h2 id="依赖预构建">依赖预构建</h2>
<p>预构建就是 cjs/umd =&gt; esm 的过程。使用 esbuild 完成。</p>
<ul>
<li>兼容 cjs/umd</li>
<li>把多个 esm 依赖关系的内部模块转换为单个模块。</li>
<li>自动依赖搜寻
<ol>
<li>从缓存中找</li>
<li>从 node_modules 中找</li>
</ol>
</li>
<li>在一库多包中，不打包的依赖项目，分析并预处理依赖项目的依赖列表。可以使用<code>optimizeDeps.include / build.optimizeDeps.include</code>优化。</li>
<li>vite 使用强缓存。<code>max-age=31536000,immutable</code></li>
<li>文件系统缓存。当下列一个改变时重新运行预构建
<ul>
<li>package.json 中的 dependencies</li>
<li>lockfile</li>
<li>vite.config.js</li>
</ul>
</li>
</ul>
<h3 id="缓存">缓存</h3>
<ul>
<li>文件系统缓存。有其一变动，则重新运行构建。
<ul>
<li>锁文件。</li>
<li>补丁文件</li>
<li>vite.config.js</li>
<li>NODE_ENV</li>
</ul>
</li>
<li>浏览器缓存。有其一则不使用缓存。
<ul>
<li>禁用缓存</li>
<li><code>--force</code>选项。</li>
<li>重新载入页面。</li>
</ul>
</li>
</ul>
<h2 id="静态资源">静态资源</h2>
<p>通过在导入时的 url 中设置 qs.</p>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>引入静态资源。</td>
<td>在开发环境使用相对链接。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>在生产环境使用绝对链接。（从根路径开始）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?url</td>
<td>导入一个 url</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?raw</td>
<td>导入字符串</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?worker / ?sharedworker</td>
<td>导入为 web worker</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>?inline</td>
<td>导入为 base64 字符串</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h3 id="poblic-目录">poblic 目录</h3>
<ul>
<li>不会被源码引用（例如 robots.txt）</li>
<li>必须保持原有文件名（没有经过 hash）</li>
<li>...或者你压根不想引入该资源，只是想得到其 URL。<code>&lt;root&gt;/public</code></li>
</ul>
<h3 id="new-urlurl-importmetaurl">new URL(url, import.meta.url)</h3>
<p>import.meta.url 中 esm 的原生功能。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> imgUrl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./img.png&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">mete</span>.<span class="hljs-property">url</span>).<span class="hljs-property">href</span>
img.<span class="hljs-property">src</span> = imgUrl <span class="hljs-comment">// 使用</span>
</code></pre>
<h2 id="构建生产版本">构建生产版本</h2>
<p>默认入口是<code>&lt;root&gt;/index.html</code>。
vite 是从<code>*.html</code>文件开始打包的。</p>
<h3 id="公共基础路径">公共基础路径</h3>
<p>如果你需要在嵌套的公共路径下部署项目，只需指定 base 配置项。<br>
结果：在 css 中使用 url() / html 文件中的引用 都是基于引配置项的。
以命令行方式设置 base。</p>
<pre><code class="language-shell">vite build --base=/my/public/path/。
</code></pre>
<h3 id="自定义构建">自定义构建</h3>
<pre><code class="language-js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: { <span class="hljs-comment">// 调整低层rollup选项</span>
      <span class="hljs-comment">// https://rollupjs.org/guide/en/#big-list-of-options</span>
    },
    <span class="hljs-attr">watch</span>: {...} <span class="hljs-comment">// 文件变化时重新构建</span>
    <span class="hljs-attr">rollupOptions</span>: { <span class="hljs-comment">// 多入口打包</span>
      <span class="hljs-attr">input</span>: {
        <span class="hljs-attr">main</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;index.html&#x27;</span>),
        <span class="hljs-attr">nested</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;nested/index.html&#x27;</span>)
      }
    }
    <span class="hljs-attr">lib</span>: { <span class="hljs-comment">// 当这个库要进行发布构建</span>
        <span class="hljs-attr">entry</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;lib/main.js&#x27;</span>),
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MyLib&#x27;</span>,
        <span class="hljs-comment">// the proper extensions will be added</span>
        <span class="hljs-attr">fileName</span>: <span class="hljs-string">&#x27;my-lib&#x27;</span>
    }
  }
})
</code></pre>
<h2 id="部署静态站点">部署静态站点</h2>
<pre><code>{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;vite build&quot;,
    &quot;preview&quot;: &quot;vite preview --port 8080&quot;
  }
}
</code></pre>
<h2 id="环境变量"><a href="/builder/vite/env.html">环境变量</a></h2>
<h2 id="服务端渲染">服务端渲染</h2>
<p>示例项目</p>
<ul>
<li><a href="https://github.com/vitejs/vite/tree/main/playground/ssr-vue">vue3</a></li>
<li><a href="https://github.com/vitejs/vite/tree/main/playground/ssr-react">react</a></li>
</ul>
<h2 id="后端集成">后端集成</h2>
<pre><code class="language-js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">build</span>: {
    <span class="hljs-comment">// 在 outDir 中生成 manifest.json</span>
    <span class="hljs-attr">manifest</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-comment">// 覆盖默认的 .html 入口</span>
      <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;/path/to/main.js&#x27;</span>,
    },
  },
})
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 如果是在开发环境中 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:5173/@vite/client&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:5173/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>执行<code>vite build</code>后，会生成 <a href="/browser/manifestJson.html"><code>manifest.json</code></a> 文件</p>
<pre><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;main.js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;assets/main.4889e940.js&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;src&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;main.js&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;isEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;dynamicImports&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;views/foo.js&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;assets/main.b82dbe22.css&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;assets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;assets/asset.0ab0f9cd.png&quot;</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;views/foo.js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;assets/foo.869aea0d.js&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;src&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;views/foo.js&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;isDynamicEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;imports&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;_shared.83069a53.js&quot;</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;_shared.83069a53.js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;assets/shared.83069a53.js&quot;</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 id="config"><a href="/builder/vite/config.html">config</a></h2>
<h2 id="api"><a href="/builder/vite/api.html">api</a></h2>
<h2 id="modenode_env"><a href="/builder//vite/mode&amp;NODE_ENV.html">mode&amp;NODE_ENV</a></h2>
<h2 id="principle">principle</h2>
<p>基于 esbuil/rollup 开发的。</p>
<h3 id="uml">uml</h3>
<pre><code>
</code></pre>
<h2 id="todo">todo</h2>
<blockquote>
<p>服务端使用 cjs 规范，vite 使用 esm 规范。vite 是如何提供服务能力的？
如果一个项目需要维护 4-5 年以上。不要用 vue，用 react。vue 的迭代变化太大。vue 的迭代问题，react 都没有。
vue1 =&gt; vue2 =&gt; vue3 迭代问题一次比一次变化大。从 1 到 2 还有一个一完全迁移工具。从 2 到 3 完全是重构。
vue 团队急于求成。为了抢占市场，推出未完成产品。后期迭代变化巨大。好多 api 改变了用法。
如何才能做到写好文档
写好项目（如：结构化）</p>
</blockquote>
<pre><code>按功能模块写基本使用文档。说清如何使用基本功能。
再整理一个完整api
再聊一下运行逻辑、源码。
如何扩展、做插件
</code></pre>
<blockquote>
<p>vue 团队就喜欢搞些方便使用的畸型代码。把 data/methods 都放在 vm 上。把 VITE_开头的变量放在 import.meta.env 上。<br>
vite 自己做了什么？esbuild 做了什么？
未来迭代计划。
未来迭代计划。</p>
</blockquote>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>