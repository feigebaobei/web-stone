<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x6b63;&#x5219;&#x8868;&#x8fbe;&#x5f0f;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="正则表达式">正则表达式</h1>
<h2 id="简介">简介</h2>
<ol>
<li>字符序列形成的搜索模式</li>
<li>可用于文本搜索和文本替换的操作</li>
<li>safari 不完全支持正则。</li>
</ol>
<h2 id="定义">定义</h2>
<p>/pattern/modifier<br>
pattern 包括普通字符（eg:a-z。包括可打印字符、不可打印字符。）和特殊字符（也称元字符）</p>
<h2 id="regexp-对象">regexp 对象</h2>
<h3 id="定义-1">定义</h3>
<pre><code>let reg0 = new RegExp('\\d{5}', 'g') // 正则表达式中有\时需要替换成\\  多用于动态创建正则表达式。
let reg1 = /\d{5}/g
</code></pre>
<h3 id="属性">属性</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>RegExp.global</td>
<td>只读</td>
<td>是否全局检索</td>
<td></td>
</tr>
<tr>
<td>RegExp.ignoreCase</td>
<td>只读</td>
<td>是否忽略大小写</td>
<td></td>
</tr>
<tr>
<td>RegExp.multiline</td>
<td>只读</td>
<td>是否多行检索</td>
<td></td>
</tr>
<tr>
<td>RegExp.lastIndex</td>
<td>读写</td>
<td>若设置了 g.这个属性存储整个字符串中下一次检索的开始位置。</td>
<td>reg.lastIndex reg.lastIndex = 3</td>
</tr>
</tbody>
</table>
<h3 id="方法">方法</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\\d{5}&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>)
<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>
reg.<span class="hljs-title function_">exec</span>(str)
<span class="hljs-comment">// 返回被找到的值，或null。只返回一个匹配结果，并提供本次匹配的完整信息。其结果与str.match(reg) reg不带g 相同</span>
<span class="hljs-comment">// 其结果与str.match(reg) reg不带g 相同</span>
reg.<span class="hljs-title function_">test</span>(str) <span class="hljs-comment">// 检查是否存在。返回boolean。</span>
reg.<span class="hljs-title function_">compile</span>(regexp, modifier) <span class="hljs-comment">// 编译正则表达式。可以用于重新编译正则表达式。</span>
</code></pre>
<table>
<thead>
<tr>
<th>关键字</th>
<th>更多遍历方法</th>
<th>速度</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>exec()</td>
<td>使用 reg.lastIndex()方法遍历。</td>
<td>慢</td>
<td>可以得到信息、位置、原数据。</td>
</tr>
<tr>
<td>test()</td>
<td>使用 reg.lastIndex()方法遍历。</td>
<td>快（比 exec()大约快 5 倍）</td>
<td>只有得到是否有匹配结果。</td>
</tr>
</tbody>
</table>
<h3 id="string-对象中支持-reg-的方法">string 对象中支持 reg 的方法</h3>
<pre><code class="language-js">str.<span class="hljs-title function_">search</span>(reg / substr) <span class="hljs-comment">// 返回与正则表达式（或子字符串）相匹配的元素在指定元素中的下标。 number型。 若不匹配则返回-1</span>
str.<span class="hljs-title function_">match</span>(reg / substr)
<span class="hljs-comment">// 若使用g。则返回如下：</span>
<span class="hljs-comment">// [匹配结果0, 匹配结果1, 匹配结果2, ...]</span>
<span class="hljs-comment">// 返回由匹配元素组成的数组。</span>
<span class="hljs-comment">// 若不使用g，则返回如下：</span>
<span class="hljs-comment">// [&quot;123abc&quot;, index: 0, input: &quot;123abc&quot;, groups: undefined]</span>
<span class="hljs-comment">// 只返回一个匹配结果，并提供本次匹配的完整信息。</span>
str.<span class="hljs-title function_">replace</span>(reg / substr, replacement) <span class="hljs-comment">//</span>
str.<span class="hljs-title function_">split</span>(reg / substr, howmany) <span class="hljs-comment">//</span>
</code></pre>
<h2 id="正则对于-string">正则对于 string</h2>
<pre><code class="language-js">string.<span class="hljs-title function_">search</span>(reg) <span class="hljs-comment">// 返回第一个匹配的子串的位置。找不到匹配字符串就返回-1。不支持全局检索，因为它忽略正则表达式参数中的修饰符g。</span>
string.<span class="hljs-title function_">replace</span>(reg, item) <span class="hljs-comment">// 替换reg匹配（全局或不全局）的子串为item。$1表示引用匹配到的第一个子串。</span>
string.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span> (<span class="hljs-params">match, input, string</span>) {<span class="hljs-keyword">return</span> ...})
string.<span class="hljs-title function_">match</span>(<span class="hljs-comment">/*/g) // 全局检索时返回一个数组。里面的元素都是检索的结果。或 null
string.match(/*/</span>)  <span class="hljs-comment">// 非全局检索时返回一个类数组对象。[&quot;value&quot;, index: 0, input: &#x27;原string&#x27;] 或 null</span>
<span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\s*,\s*/</span>) <span class="hljs-comment">// 返回[1, 2, 3, 4, 5]</span>
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$1, $2, $3, ...</td>
<td>引用匹配到的第 n 个子串。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$&amp;</td>
<td>与 regexp 相匹配的子串</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$`</td>
<td>匹配子串左侧的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$'</td>
<td>匹配子串右侧的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$$</td>
<td>直接量符号</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="字符分类">字符分类</h2>
<details>
  <summary>非打印字符</summary>
  <code>
|字符|描述|  
|-|-|  
|\cx||  
|\f|换页符|  
|\n|换行符|  
|\r|回车符|  
|\s|空白字符。包括空格、制表符、换页符等|  
|\S|非空白字符|  
|\t|制表符|  
|\v|垂直制表符|  
  </code>
</details>
<details>
  <summary>匹配符</summary>
  <code>
|字符|描述|  
|-|-|  
|\w|匹配字母或数字或下划线或汉字，等价于[a-zA-Z0-9_]|  
|\W|匹配不是ASCII字符组成的单词，等价于[^a-zA-Z0-9_]|  
|\s|匹配任意的Unicode空白符|  
|\S|匹配非任意的Unicode空白符|  
|\d|数字[0-9]|  
|.|非换行符(\n)外的任意字符|  
|[\b]|退格直接量（特例）|  
  </code>
</details>
<details>
    <summary>特殊字符（转义字符）</summary>
    <p>简单说就是需要转义的字符。在需要转义的字符前面加`\`</p>
<table>
    <thead>
        <tr>
            <td>字符</td>
            <td>描述</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$</td>
            <td></td>
        </tr>
        <tr>
            <td>()</td>
            <td></td>
        </tr>
        <tr>
            <td>{</td>
            <td></td>
        </tr>
        <tr>
            <td>[</td>
            <td></td>
        </tr>
        <tr>
            <td>+</td>
            <td></td>
        </tr>
        <tr>
            <td>*</td>
            <td></td>
        </tr>
        <tr>
            <td>/</td>
            <td></td>
        </tr>
        <tr>
            <td>|</td>
            <td></td>
        </tr>
        <tr>
            <td>^</td>
            <td></td>
        </tr>
        <tr>
            <td>.</td>
            <td></td>
        </tr>
        <tr>
            <td>?</td>
            <td></td>
        </tr>
    </tbody>
</table>
</details>
<details>
    <summary>限定符</summary>
    <code>
|字符|描述|
|-|-|
|*|>=0|
|+|>=1|
|?|0或1|
|{n}|n次。n>=0|
|{n,}|>=n。n>=0|
|{n,m}|n<=x<=m。n,m>=0|
没有最多m个的限定符
    </code>
</details>
<details>
    <summary>定位符</summary>
    <code>
|字符|描述|
|-|-|
|^|开头位置|
|$|结尾位置|
|\b|匹配一个字边界，即字与空格间的位置|
|\B|非字边界|
    </code>
</details>
<details>
    <summary>修饰符</summary>
    <code>
|符号|描述|
|-|-|
|i|不区分大小写|
|g|执行全文搜索|
|m|执行多行搜索|
|s|若设置为s则允许`.`包含`\n`，默认不包含。|
    </code>
</details>
<details>
    <summary>反义</summary>
    <code>
|符号|描述|
|-|-|
|[^x]|除了x以外的任意字符|
|\W||
|\S||
|\B|不是单词的开头或结束的位置|
    </code>
</details>
<h2 id="贪婪匹配">贪婪匹配</h2>
<p>尽可能多的匹配内容。<code>.*</code><br>
使用<code>*</code>匹配。</p>
<h2 id="惰性匹配">惰性匹配</h2>
<p>尽可能少的匹配内容。<code>.*?</code><br>
在量词后面加<code>?</code>。</p>
<pre><code>{m, n}?
{m,}?
+?
??
*?
</code></pre>
<h2 id="选择分组引用">选择、分组、引用</h2>
<pre><code>/a|ab/ // 只匹配a。因为选择项的匹配匹配次序是从左到右。
()     // 表示捕获分组。匹配会被缓存起来。使用n访问缓存。
(?:  ) // 仅用于分组，不用到子表达式引用。
(?=  ) // 仅用于分组，不用到子表达式引用。正向先行断言
(?!  ) // 仅用于分组，不用到子表达式引用。负向先行断言
\1 // 第一个缓存的匹配内容
\2 // 第二个缓存的匹配内容
</code></pre>
<p><strong><code>?=</code>和<code>?:</code>的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?=</code></td>
<td>匹配一个位置</td>
<td><code>123(?=456)</code>,匹配后面有 456 的 123</td>
</tr>
<tr>
<td><code>?:</code></td>
<td>不记入编号</td>
<td><code>(a)(?:b)(c)\1\2</code>，匹配 abcac</td>
</tr>
</tbody>
</table>
<p><code>exp1(?=exp2)</code> 查找后面是 exp2 的 exp1<br>
<code>(?&lt;=exp2)exp1</code> 查找前面是 exp2 的 exp1<br>
<code>exp1(?!exp2)</code> 查找后面不是 exp2 的 exp1<br>
<code>(?&lt;!exp2)exp1</code> 查找前面不是 exp2 的 exp1</p>
<p>使用分组时组的内容必须一样。（不可以匹配相同的正则就使用分组）<br>
分组是匹配相同内容，不是相同正则。</p>
<h2 id="优先级">优先级</h2>
<p>|                          |     |     |
| ------------------------ | --- | --- | --- |
| <code>\</code>                      |     |     |
| <code>(),(?:),(?=),[]</code>        |     |     |
| <code>*,+,?,{n},{n,},{n,m}</code>   |     |     |
| <code>^,$,\任何字符,任何字符</code> |     |     |
| <code>                       |</code>   |     |     |</p>
<h2 id="积累">积累</h2>
<p><strong>匹配时间</strong></p>
<pre><code>23:49
02:03
/^([01][0-9]|2[0-3]):([0-5][0-9]|)$/
</code></pre>
<p><strong>匹配日期</strong></p>
<pre><code>2017-05-23
//年 /[0-9]{4}/
//月 /0[0-9]|1[0-2]/
//日 /[0-2][0-9]|3[01]/
/^(0-9){4}-(0[0-9|1[0-2]])-([0-2][0-9]|3[01])$/g
/^(0|[1-9]\d{0,3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/
不严谨
string =&gt; date
分别取y/m/d.
使用正则取得y1/m1/d1
比较y/y1 m/m1 d/d1

// 数字格式化 1,123,000
&quot;1234567890&quot;.replace(/\B(?=(?:\d{3})+(?!\d))/g,&quot;,&quot;) // 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)
</code></pre>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>