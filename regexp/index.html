<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x6b63;&#x5219;&#x8868;&#x8fbe;&#x5f0f;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="正则表达式">正则表达式</h1>
<h2 id="简介">简介</h2>
<ol>
<li>字符序列形成的搜索模式</li>
<li>可用于文本搜索和文本替换的操作</li>
<li>safari 不完全支持正则。</li>
</ol>
<h2 id="定义">定义</h2>
<p>/pattern/modifier<br>
pattern 包括普通字符（eg:a-z。包括可打印字符、不可打印字符。）和特殊字符（也称元字符）</p>
<h2 id="regexp-对象">regexp 对象</h2>
<h3 id="定义-1">定义</h3>
<pre><code>let reg0 = new RegExp('\\d{5}', 'g') // 正则表达式中有\时需要替换成\\  多用于动态创建正则表达式。
let reg1 = /\d{5}/g
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>new RegExp</th>
<th>字面量</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>demo</td>
<td><code>new RegExp('^\\d{3}', 'g')</code></td>
<td><code>let reg = /^\d{3}/g</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>可以使用变量</td>
<td>不可以</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>\</code>需要转义，即：<code>\\</code></td>
<td>不需要</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="modifier">modifier</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>不区分大小写</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>g</td>
<td>在全局范围内匹配</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>m</td>
<td>多行模式</td>
<td>会影响<code>^$</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s</td>
<td>启用'dotall'模式。</td>
<td>允许<code>.</code>匹配<code>\n</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>u</td>
<td>支持完整的unicode。</td>
<td>能够正确处理代理以</td>
<td></td>
<td></td>
</tr>
<tr>
<td>y</td>
<td>粘滞sticky模式</td>
<td>在文本中确切位置搜索</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="属性">属性</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>RegExp.global</td>
<td>只读</td>
<td>是否全局检索</td>
<td></td>
</tr>
<tr>
<td>RegExp.ignoreCase</td>
<td>只读</td>
<td>是否忽略大小写</td>
<td></td>
</tr>
<tr>
<td>RegExp.multiline</td>
<td>只读</td>
<td>是否多行检索</td>
<td></td>
</tr>
<tr>
<td>RegExp.lastIndex</td>
<td>读写</td>
<td>若设置了 g.这个属性存储整个字符串中下一次检索的开始位置。</td>
<td>reg.lastIndex reg.lastIndex = 3</td>
</tr>
<tr>
<td>RegExp.dotall</td>
<td>-</td>
<td>是否多行检索</td>
<td></td>
</tr>
<tr>
<td>RegExp.hasIndices</td>
<td>-</td>
<td>不会</td>
<td></td>
</tr>
<tr>
<td>RegExp.flags</td>
<td>-</td>
<td>返回修饰符</td>
<td></td>
</tr>
<tr>
<td>RegExp.source</td>
<td>-</td>
<td>不会</td>
<td></td>
</tr>
<tr>
<td>RegExp.sticky</td>
<td>-</td>
<td>不会</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="方法">方法</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\\d{5}&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>)
<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>
reg.<span class="hljs-title function_">exec</span>(str)
<span class="hljs-comment">// 返回被找到的值，或null。只返回一个匹配结果，并提供本次匹配的完整信息。其结果与str.match(reg) reg不带g 相同</span>
<span class="hljs-comment">// 其结果与str.match(reg) reg不带g 相同</span>
reg.<span class="hljs-title function_">test</span>(str) <span class="hljs-comment">// 检查是否存在。返回boolean。</span>
reg.<span class="hljs-title function_">compile</span>(regexp, modifier) <span class="hljs-comment">// 编译正则表达式。可以用于重新编译正则表达式。</span>
</code></pre>
<table>
<thead>
<tr>
<th>关键字</th>
<th>更多遍历方法</th>
<th>速度</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>exec()</td>
<td>使用 reg.lastIndex()方法遍历。</td>
<td>慢</td>
<td>可以得到信息、位置、原数据。</td>
</tr>
<tr>
<td>test()</td>
<td>使用 reg.lastIndex()方法遍历。</td>
<td>快（比 exec()大约快 5 倍）</td>
<td>只有得到是否有匹配结果。</td>
</tr>
</tbody>
</table>
<h3 id="string-对象中支持-reg-的方法">string 对象中支持 reg 的方法</h3>
<pre><code class="language-js">str.<span class="hljs-title function_">search</span>(reg / substr) <span class="hljs-comment">// 返回与正则表达式（或子字符串）相匹配的元素在指定元素中的下标。 number型。 若不匹配则返回-1</span>
str.<span class="hljs-title function_">match</span>(reg / substr)
<span class="hljs-comment">// 若使用g。则返回如下：</span>
<span class="hljs-comment">// [匹配结果0, 匹配结果1, 匹配结果2, ...]</span>
<span class="hljs-comment">// 返回由匹配元素组成的数组。</span>
<span class="hljs-comment">// 若不使用g，则返回如下：</span>
<span class="hljs-comment">// [&quot;123abc&quot;, index: 0, input: &quot;123abc&quot;, groups: undefined]</span>
<span class="hljs-comment">// 只返回一个匹配结果，并提供本次匹配的完整信息。</span>
str.<span class="hljs-title function_">replace</span>(reg / substr, replacement) <span class="hljs-comment">//</span>
str.<span class="hljs-title function_">split</span>(reg / substr, howmany) <span class="hljs-comment">//</span>
</code></pre>
<h2 id="正则对于-string">正则对于 string</h2>
<pre><code class="language-js">string.<span class="hljs-title function_">search</span>(reg) <span class="hljs-comment">// 返回第一个匹配的子串的位置。找不到匹配字符串就返回-1。不支持全局检索，因为它忽略正则表达式参数中的修饰符g。</span>
string.<span class="hljs-title function_">replace</span>(reg, item) <span class="hljs-comment">// 替换reg匹配（全局或不全局）的子串为item。$1表示引用匹配到的第一个子串。</span>
string.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span> (<span class="hljs-params">match, input, string</span>) {<span class="hljs-keyword">return</span> ...})
string.<span class="hljs-title function_">match</span>(<span class="hljs-comment">/*/g) // 全局检索时返回一个数组。里面的元素都是检索的结果。或 null
string.match(/*/</span>)  <span class="hljs-comment">// 非全局检索时返回一个类数组对象。[&quot;value&quot;, index: 0, input: &#x27;原string&#x27;] 或 null</span>
<span class="hljs-string">&#x27;1, 2, 3, 4, 5&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\s*,\s*/</span>) <span class="hljs-comment">// 返回[1, 2, 3, 4, 5]</span>
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$1, $2, $3, ..., $9</td>
<td>引用匹配到的第 n 个子串。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$&amp;</td>
<td>与 regexp 相匹配的子串</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$`</td>
<td>匹配子串左侧的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$'</td>
<td>匹配子串右侧的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$$</td>
<td>直接量符号</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="字符分类">字符分类</h2>
<details>
  <summary>非打印字符</summary>
  <code>
|字符|描述|  
|-|-|  
|\cx||  
|\f|换页符|  
|\n|换行符|  
|\r|回车符|  
|\s|空白字符。包括空格、制表符、换页符等|  
|\S|非空白字符|  
|\t|制表符|  
|\v|垂直制表符|  
  </code>
</details>
<details>
  <summary>匹配符</summary>
  <code>
|字符|描述|-|
|-|-|-|
|\w|匹配字母或数字或下划线或汉字，等价于[a-zA-Z0-9_]||
|\W|匹配不是ASCII字符组成的单词，等价于[^a-zA-Z0-9_]||
|\s|匹配任意的Unicode空白符||
|\S|匹配非任意的Unicode空白符||
|\d|数字[0-9]||
|.|非换行符(\n)外的任意字符|修饰符s分影响它匹配`\n`|
|[\b]|退格直接量（特例）||
  </code>
</details>
<details>
    <summary>特殊字符（转义字符）</summary>
    <p>简单说就是需要转义的字符。在需要转义的字符前面加`\`</p>
<table>
    <thead>
        <tr>
            <td>字符</td>
            <td>描述</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$</td>
            <td></td>
        </tr>
        <tr>
            <td>()</td>
            <td></td>
        </tr>
        <tr>
            <td>{</td>
            <td></td>
        </tr>
        <tr>
            <td>[</td>
            <td></td>
        </tr>
        <tr>
            <td>+</td>
            <td></td>
        </tr>
        <tr>
            <td>*</td>
            <td></td>
        </tr>
        <tr>
            <td>/</td>
            <td></td>
        </tr>
        <tr>
            <td>|</td>
            <td></td>
        </tr>
        <tr>
            <td>^</td>
            <td></td>
        </tr>
        <tr>
            <td>.</td>
            <td></td>
        </tr>
        <tr>
            <td>?</td>
            <td></td>
        </tr>
    </tbody>
</table>
</details>
<details>
    <summary>限定符</summary>
    <code>
|字符|描述|
|-|-|
|*|>=0|
|+|>=1|
|?|0或1|
|{n}|n次。n>=0|
|{n,}|>=n。n>=0|
|{n,m}|n<=x<=m。n,m>=0|
没有最多m个的限定符
    </code>
</details>
<details>
    <summary>定位符</summary>
    <code>
|字符|描述|
|-|-|
|^|开头位置|
|$|结尾位置|
|\b|匹配一个单词边界，即单词与空格间的位置|
|\B|非单词边界|
    </code>
</details>
<details>
    <summary>修饰符</summary>
    <code>
|符号|描述|
|-|-|
|i|不区分大小写|
|g|执行全文搜索|
|m|执行多行搜索|
|s|若设置为s则允许`.`包含`\n`，默认不包含。|
    </code>
</details>
<details>
    <summary>反义</summary>
    <code>
|符号|描述|
|-|-|
|[^x]|除了x以外的任意字符|
|\W||
|\S||
|\B|不是单词的开头或结束的位置|
    </code>
</details>
<h2 id="贪婪匹配">贪婪匹配</h2>
<p>尽可能多的匹配内容。如：<code>.*</code><br>
使用<code>*</code>匹配。
默认贪婪</p>
<h2 id="惰性匹配非贪婪匹配">惰性匹配（非贪婪匹配）</h2>
<p>从头开始最早匹配的。（不是尽可能少的匹配内容。）如：<code>.*?</code><br>
在量词后面加<code>?</code>。
一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配)</p>
<pre><code>{m, n}?
{m,}?
+?
??
*?
</code></pre>
<h2 id="回溯">回溯</h2>
<p>正则会从头开始匹配。若匹配成功部分文本，则定义为正则取得这部分文本的控制权。回溯是把已经取得控制权的文本交出去。它是浪费性能的。回溯越少，性能越高。</p>
<h2 id="选择分组引用环视缓存子表达式">选择、分组、引用、环视、缓存（子表达式）</h2>
<pre><code>/a|ab/ // 只匹配a。因为选择项的匹配匹配次序是从左到右。
()     // 表示捕获分组。匹配会被缓存起来。使用n访问缓存。
(?:  ) // 仅用于分组，不用到子表达式引用。
(?=  ) // 仅用于分组，不用到子表达式引用。正向先行断言
(?!  ) // 仅用于分组，不用到子表达式引用。负向先行断言
\1 // 第一个缓存的匹配内容，即第一个子表达式。
\2 // 第二个缓存的匹配内容，即第一个子表达式。
</code></pre>
<h3 id="分组">分组</h3>
<p>当正则表达式中有分组且分组的名字时，匹配成功时，groups为对象。</p>
<pre><code class="language-js"><span class="hljs-comment">// demo</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;abc123&#x27;</span>
<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(?&lt;k&gt;\d+)/</span>
reg.<span class="hljs-title function_">exec</span>(s) <span class="hljs-comment">// [&#x27;123&#x27;, &#x27;123&#x27;, index: 3, input: &#x27;abc123&#x27;, groups: {k: &#x27;123&#x27;}]</span>
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>demo</th>
</tr>
</thead>
<tbody>
<tr>
<td>`</td>
<td>`</td>
<td>左右为或的关系</td>
</tr>
<tr>
<td><code>(。。。)</code></td>
<td>分组</td>
<td><code>/(a)/</code></td>
</tr>
<tr>
<td><code>(?&lt;name&gt;)</code></td>
<td>命名的分组</td>
<td><code>/(?&lt;id&gt;\d)/</code></td>
</tr>
<tr>
<td><code>(?&lt;p=name&gt;)</code></td>
<td>引用命名的分组</td>
<td><code>/(?&lt;id&gt;\d)abc(?p=id)/</code></td>
</tr>
<tr>
<td><code>/(?#)/</code></td>
<td>不会。好像是注解。</td>
<td></td>
</tr>
<tr>
<td><code>(?:)</code></td>
<td>不记入分组</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong><code>?=</code>和<code>?:</code>的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?=</code></td>
<td>匹配一个位置</td>
<td><code>123(?=456)</code>,匹配后面有 456 的 123</td>
</tr>
<tr>
<td><code>?:</code></td>
<td>不记入编号</td>
<td><code>(a)(?:b)(c)\1\2</code>，匹配 abcac</td>
</tr>
</tbody>
</table>
<p><code>exp1(?=exp2)</code> 查找后面是 exp2 的 exp1<br>
<code>(?&lt;=exp2)exp1</code> 查找前面是 exp2 的 exp1<br>
<code>exp1(?!exp2)</code> 查找后面不是 exp2 的 exp1<br>
<code>(?&lt;!exp2)exp1</code> 查找前面不是 exp2 的 exp1</p>
<p>使用分组时组的内容必须一样。（不可以匹配相同的正则就使用分组）<br>
分组是匹配相同内容，不是相同正则。</p>
<h2 id="">[]</h2>
<p><code>[]</code>内的不需要转义</p>
<h2 id="优先级">优先级</h2>
<p>|                          |     |     |
| ------------------------ | --- | --- | --- |
| <code>\</code>                      |     |     |
| <code>(),(?:),(?=),[]</code>        |     |     |
| <code>*,+,?,{n},{n,},{n,m}</code>   |     |     |
| <code>^,$,\任何字符,任何字符</code> |     |     |
| <code>                       |</code>   |     |     |</p>
<h2 id="match--exec">match &amp; exec</h2>
<table>
<thead>
<tr>
<th>条件</th>
<th>match的结果</th>
<th>exec的结果</th>
<th>j是否相同</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>字符串的方法</td>
<td>正则表达式的方法</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>无子表达式+无全局匹配</td>
<td><code>[subString, index: N, input: S, groups: undefined]</code></td>
<td><code>[subString, index: N, input: S, groups: undefined]</code></td>
<td>相同</td>
<td></td>
<td></td>
</tr>
<tr>
<td>有子表达式+无全局匹配</td>
<td><code>[正则表达式的匹配文本, ...各子表达式的匹配文本, index: N, input: S, groups: undefined]</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>无子表达式+全局匹配</td>
<td><code>[...所有正则表达式的匹配文本]</code></td>
<td><code>[第一个匹配结果, index: N, input: S, group: undefined]</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>有子表达式+全局匹配</td>
<td>同上</td>
<td>同上</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>-</td>
<td>适用于循环匹配</td>
<td></td>
<td><code>while (result = reg.exec(s)) {...}</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="不再提倡使用的">不再提倡使用的</h2>
<table>
<thead>
<tr>
<th></th>
<th>功能</th>
<th>替代品</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RegExp.leftContext</code></td>
<td>匹配的子串的左侧文本。</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="性能">性能</h2>
<ul>
<li>减小回溯</li>
<li>粘性模式。</li>
</ul>
<h2 id="积累">积累</h2>
<p><strong>匹配时间</strong></p>
<pre><code>23:49
02:03
/^([01][0-9]|2[0-3]):([0-5][0-9]|)$/
</code></pre>
<p><strong>匹配日期</strong></p>
<pre><code>2017-05-23
//年 /[0-9]{4}/
//月 /0[0-9]|1[0-2]/
//日 /[0-2][0-9]|3[01]/
/^(0-9){4}-(0[0-9|1[0-2]])-([0-2][0-9]|3[01])$/g
/^(0|[1-9]\d{0,3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/
不严谨
string =&gt; date
分别取y/m/d.
使用正则取得y1/m1/d1
比较y/y1 m/m1 d/d1

// 数字格式化 1,123,000
&quot;1234567890&quot;.replace(/\B(?=(?:\d{3})+(?!\d))/g,&quot;,&quot;) // 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)
</code></pre>
<p>懒惰匹配，也就是匹配尽可能少的字符。在能使整个匹配成功的前提下使用最少的重复，只要在它后面加上一个问号?即可。现在看看懒惰版的例子吧：
a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）
为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有一条比懒惰／贪婪规则优先级更高的规则，就是：最先开始的匹配拥有最高的优先权
一旦发现匹配符合要求，立马就匹配成功
<code>[]</code>内的不转义</p>
<h2 id="判断2个正则是否相等">判断2个正则是否相等</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">r1, r2</span>) =&gt; {
    <span class="hljs-keyword">if</span> (r1.<span class="hljs-property">source</span> === r2.<span class="hljs-property">source</span>) {
        <span class="hljs-keyword">let</span> a1 = r1.<span class="hljs-property">flags</span>
        <span class="hljs-keyword">let</span> a2 = r2.<span class="hljs-property">flags</span>
        <span class="hljs-keyword">if</span> (a1.<span class="hljs-property">length</span> === a2.<span class="hljs-property">length</span>) {
            <span class="hljs-keyword">return</span> a1.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> s2.<span class="hljs-title function_">includes</span>(item))
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
}
</code></pre>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>