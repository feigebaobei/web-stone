# 正则表达式

## 简介

1. 字符序列形成的搜索模式
2. 可用于文本搜索和文本替换的操作
3. safari 不完全支持正则。

## 定义

/pattern/modifier  
pattern 包括普通字符（eg:a-z。包括可打印字符、不可打印字符。）和特殊字符（也称元字符）

## regexp 对象

### 定义

    let reg0 = new RegExp('\\d{5}', 'g') // 正则表达式中有\时需要替换成\\  多用于动态创建正则表达式。
    let reg1 = /\d{5}/g

|      | new RegExp                   | 字面量                |     |     |
| ---- | ---------------------------- | --------------------- | --- | --- |
| demo | `new RegExp('^\\d{3}', 'g')` | `let reg = /^\d{3}/g` |     |     |
|      | 可以使用变量                 | 不可以                |     |     |
|      | `\`需要转义，即：`\\`        | 不需要                |     |     |
|      |                              |                       |     |     |
|      |                              |                       |     |     |

### modifier

|     |                      |                      |     |     |
| --- | -------------------- | -------------------- | --- | --- |
| i   | 不区分大小写         |                      |     |     |
| g   | 在全局范围内匹配     |                      |     |     |
| m   | 多行模式             | 会影响`^$`           |     |     |
| s   | 启用'dotall'模式。   | 允许`.`匹配`\n`      |     |     |
| u   | 支持完整的 unicode。 | 能够正确处理代理以   |     |     |
| y   | 粘滞 sticky 模式     | 在文本中确切位置搜索 |     |     |

### 属性

|                   |      |                                                           |                                 |
| ----------------- | ---- | --------------------------------------------------------- | ------------------------------- |
| RegExp.global     | 只读 | 是否全局检索                                              |                                 |
| RegExp.ignoreCase | 只读 | 是否忽略大小写                                            |                                 |
| RegExp.multiline  | 只读 | 是否多行检索                                              |                                 |
| RegExp.lastIndex  | 读写 | 若设置了 g.这个属性存储整个字符串中下一次检索的开始位置。 | reg.lastIndex reg.lastIndex = 3 |
| RegExp.dotall     | -    | 是否多行检索                                              |                                 |
| RegExp.hasIndices | -    | 不会                                                      |                                 |
| RegExp.flags      | -    | 返回修饰符                                                |                                 |
| RegExp.source     | -    | 不会                                                      |                                 |
| RegExp.sticky     | -    | 不会                                                      |                                 |

### 方法

```js
var reg = new RegExp('\\d{5}', 'g')
var str = '1, 2, 3, 4, 5'
reg.exec(str)
// 返回被找到的值，或null。只返回一个匹配结果，并提供本次匹配的完整信息。其结果与str.match(reg) reg不带g 相同
// 其结果与str.match(reg) reg不带g 相同
reg.test(str) // 检查是否存在。返回boolean。
reg.compile(regexp, modifier) // 编译正则表达式。可以用于重新编译正则表达式。
```

| 关键字 | 更多遍历方法                   | 速度                       | 结果                         |
| ------ | ------------------------------ | -------------------------- | ---------------------------- |
| exec() | 使用 reg.lastIndex()方法遍历。 | 慢                         | 可以得到信息、位置、原数据。 |
| test() | 使用 reg.lastIndex()方法遍历。 | 快（比 exec()大约快 5 倍） | 只有得到是否有匹配结果。     |

### string 对象中支持 reg 的方法

```js
str.search(reg / substr) // 返回与正则表达式（或子字符串）相匹配的元素在指定元素中的下标。 number型。 若不匹配则返回-1
str.match(reg / substr)
// 若使用g。则返回如下：
// [匹配结果0, 匹配结果1, 匹配结果2, ...]
// 返回由匹配元素组成的数组。
// 若不使用g，则返回如下：
// ["123abc", index: 0, input: "123abc", groups: undefined]
// 只返回一个匹配结果，并提供本次匹配的完整信息。
str.replace(reg / substr, replacement) //
str.split(reg / substr, howmany) //
```

## 正则对于 string

```js
string.search(reg) // 返回第一个匹配的子串的位置。找不到匹配字符串就返回-1。不支持全局检索，因为它忽略正则表达式参数中的修饰符g。
string.replace(reg, item) // 替换reg匹配（全局或不全局）的子串为item。$1表示引用匹配到的第一个子串。
string.replace(reg, function (match, input, string) {return ...})
string.match(/*/g) // 全局检索时返回一个数组。里面的元素都是检索的结果。或 null
string.match(/*/)  // 非全局检索时返回一个类数组对象。["value", index: 0, input: '原string'] 或 null
'1, 2, 3, 4, 5'.split(/\s*,\s*/) // 返回[1, 2, 3, 4, 5]
```

|                     |                           |     |     |
| ------------------- | ------------------------- | --- | --- |
| $1, $2, $3, ..., $9 | 引用匹配到的第 n 个子串。 |     |     |
| $&                  | 与 regexp 相匹配的子串    |     |     |
| $`                  | 匹配子串左侧的文本        |     |     |
| $'                  | 匹配子串右侧的文本        |     |     |
| $$                  | 直接量符号                |     |     |

## 字符分类

<details>
  <summary>非打印字符</summary>
  <code>
|字符|描述|  
|-|-|  
|\cx||  
|\f|换页符|  
|\n|换行符|  
|\r|回车符|  
|\s|空白字符。包括空格、制表符、换页符、换行符等|  
|\S|非空白字符|  
|\t|制表符|  
|\v|垂直制表符|  
  </code>
</details>

<details>
  <summary>匹配符</summary>
  <code>
|字符|描述|-|
|-|-|-|
|\w|匹配字母或数字或下划线或汉字，等价于[a-zA-Z0-9_]||
|\W|匹配不是ASCII字符组成的单词，等价于[^a-zA-Z0-9_]||
|\s|匹配任意的Unicode空白符||
|\S|匹配非任意的Unicode空白符||
|\d|数字[0-9]||
|.|非换行符(\n)外的任意字符|修饰符s分影响它匹配`\n`|
|[\b]|退格直接量（特例）||
  </code>
</details>

<details>
    <summary>特殊字符（转义字符）</summary>
    <p>简单说就是需要转义的字符。在需要转义的字符前面加`\`</p>
<table>
    <thead>
        <tr>
            <td>字符</td>
            <td>描述</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$</td>
            <td></td>
        </tr>
        <tr>
            <td>()</td>
            <td></td>
        </tr>
        <tr>
            <td>{</td>
            <td></td>
        </tr>
        <tr>
            <td>[</td>
            <td></td>
        </tr>
        <tr>
            <td>+</td>
            <td></td>
        </tr>
        <tr>
            <td>*</td>
            <td></td>
        </tr>
        <tr>
            <td>/</td>
            <td></td>
        </tr>
        <tr>
            <td>|</td>
            <td></td>
        </tr>
        <tr>
            <td>^</td>
            <td></td>
        </tr>
        <tr>
            <td>.</td>
            <td></td>
        </tr>
        <tr>
            <td>?</td>
            <td></td>
        </tr>
    </tbody>
</table>
</details>

<details>
    <summary>限定符</summary>
    <code>
|字符|描述|
|-|-|
|*|>=0|
|+|>=1|
|?|0或1|
|{n}|n次。n>=0|
|{n,}|>=n。n>=0|
|{n,m}|n<=x<=m。n,m>=0|
没有最多m个的限定符
    </code>
</details>

<details>
    <summary>定位符</summary>
    <code>
|字符|描述|
|-|-|
|^|开头位置|
|$|结尾位置|
|\b|匹配一个单词边界，即单词与空格间、符号等的位置|
|\B|非单词边界|
    </code>
</details>

<details>
    <summary>修饰符</summary>
    <code>
|符号|描述|
|-|-|
|i|不区分大小写|
|g|执行全文搜索|
|m|执行多行搜索|
|s|若设置为s则允许`.`包含`\n`，默认不包含。|
    </code>
</details>

<details>
    <summary>反义</summary>
    <code>
|符号|描述|
|-|-|
|[^x]|除了x以外的任意字符|
|\W||
|\S||
|\B|不是单词的开头或结束的位置|
    </code>
</details>

## 贪婪匹配

尽可能多的匹配内容。如：`.*`  
使用`*`匹配。
默认贪婪

## 惰性匹配（非贪婪匹配）

从头开始最早匹配的。（不是尽可能少的匹配内容。）如：`.*?`  
在量词后面加`?`。
一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有 g，开启下一组匹配)

```
{m, n}?
{m,}?
+?
??
*?
```

## 回溯

正则会从头开始匹配。若匹配成功部分文本，则定义为正则取得这部分文本的控制权。回溯是把已经取得控制权的文本交出去。它是浪费性能的。回溯越少，性能越高。

## 选择、分组、引用、环视、缓存（子表达式）

```
/a|ab/ // 只匹配a。因为选择项的匹配匹配次序是从左到右。
()     // 表示捕获分组。匹配会被缓存起来。使用n访问缓存。
(?:  ) // 仅用于分组，不用到子表达式引用。
(?=  ) // 仅用于分组，不用到子表达式引用。正向先行断言
(?!  ) // 仅用于分组，不用到子表达式引用。负向先行断言
\1 // 第一个缓存的匹配内容，即第一个子表达式。
\2 // 第二个缓存的匹配内容，即第一个子表达式。
```

### 分组

当正则表达式中有分组且分组的名字时，匹配成功时，groups 为对象。

```js
// demo
var s = 'abc123'
var reg = /(?<k>\d+)/
reg.exec(s) // ['123', '123', index: 3, input: 'abc123', groups: {k: '123'}]
```

|               |                    | demo                    |
| ------------- | ------------------ | ----------------------- | --- | --- |
| `             | `                  | 左右为或的关系          | `/a | b/` |
| `(。。。)`    | 分组               | `/(a)/`                 |
| `(?<name>)`   | 命名的分组         | `/(?<id>\d)/`           |
| `(?<p=name>)` | 引用命名的分组     | `/(?<id>\d)abc(?p=id)/` |
| `/(?#)/`      | 不会。好像是注解。 |                         |
| `(?:)`        | 不记入分组         |                         |
|               |                    |                         |
|               |                    |                         |
|               |                    |                         |

**`?=`和`?:`的区别**

|      |              |                                    |
| ---- | ------------ | ---------------------------------- |
| `?=` | 匹配一个位置 | `123(?=456)`,匹配后面有 456 的 123 |
| `?:` | 不记入编号   | `(a)(?:b)(c)\1\2`，匹配 abcac      |

`exp1(?=exp2)` 查找后面是 exp2 的 exp1  
`(?<=exp2)exp1` 查找前面是 exp2 的 exp1  
`exp1(?!exp2)` 查找后面不是 exp2 的 exp1  
`(?<!exp2)exp1` 查找前面不是 exp2 的 exp1

使用分组时组的内容必须一样。（不可以匹配相同的正则就使用分组）  
分组是匹配相同内容，不是相同正则。

## []

`[]`内的不需要转义

## 优先级

|                          |     |     |
| ------------------------ | --- | --- | --- |
| `\`                      |     |     |
| `(),(?:),(?=),[]`        |     |     |
| `*,+,?,{n},{n,},{n,m}`   |     |     |
| `^,$,\任何字符,任何字符` |     |     |
| `                        | `   |     |     |

## match & exec

| 条件                  | match 的结果                                                                             | exec 的结果                                              | j 是否相同 |                                      |     |
| --------------------- | ---------------------------------------------------------------------------------------- | -------------------------------------------------------- | ---------- | ------------------------------------ | --- |
|                       | 字符串的方法                                                                             | 正则表达式的方法                                         |            |                                      |     |
| 无子表达式+无全局匹配 | `[subString, index: N, input: S, groups: undefined]`                                     | `[subString, index: N, input: S, groups: undefined]`     | 相同       |                                      |     |
| 有子表达式+无全局匹配 | `[正则表达式的匹配文本, ...各子表达式的匹配文本, index: N, input: S, groups: undefined]` |                                                          |            |                                      |     |
| 无子表达式+全局匹配   | `[...所有正则表达式的匹配文本]`                                                          | `[第一个匹配结果, index: N, input: S, group: undefined]` |            |                                      |     |
| 有子表达式+全局匹配   | 同上                                                                                     | 同上                                                     |            |                                      |     |
|                       | -                                                                                        | 适用于循环匹配                                           |            | `while (result = reg.exec(s)) {...}` |     |

## 不再提倡使用的

|                      | 功能                   | 替代品 |
| -------------------- | ---------------------- | ------ |
| `RegExp.leftContext` | 匹配的子串的左侧文本。 |        |
|                      |                        |        |
|                      |                        |        |

## 性能

- 减小回溯
- 粘性模式。

## 积累

**匹配时间**

    23:49
    02:03
    /^([01][0-9]|2[0-3]):([0-5][0-9]|)$/

**匹配日期**

    2017-05-23
    //年 /[0-9]{4}/
    //月 /0[0-9]|1[0-2]/
    //日 /[0-2][0-9]|3[01]/
    /^(0-9){4}-(0[0-9|1[0-2]])-([0-2][0-9]|3[01])$/g
    /^(0|[1-9]\d{0,3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/
    不严谨
    string => date
    分别取y/m/d.
    使用正则取得y1/m1/d1
    比较y/y1 m/m1 d/d1

    // 数字格式化 1,123,000
    "1234567890".replace(/\B(?=(?:\d{3})+(?!\d))/g,",") // 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)

懒惰匹配，也就是匹配尽可能少的字符。在能使整个匹配成功的前提下使用最少的重复，只要在它后面加上一个问号?即可。现在看看懒惰版的例子吧：
a.\*?b 匹配最短的，以 a 开始，以 b 结束的字符串。如果把它应用于 aabab 的话，它会匹配 aab（第一到第三个字符）和 ab（第四到第五个字符）
为什么第一个匹配是 aab（第一到第三个字符）而不是 ab（第二到第三个字符）？简单地说，因为正则表达式有一条比懒惰／贪婪规则优先级更高的规则，就是：最先开始的匹配拥有最高的优先权
一旦发现匹配符合要求，立马就匹配成功
`[]`内的不转义

## 判断 2 个正则是否相等

```js
let f = (r1, r2) => {
  if (r1.source === r2.source) {
    let a1 = r1.flags
    let a2 = r2.flags
    if (a1.length === a2.length) {
      return a1.every((item) => s2.includes(item))
    } else {
      return false
    }
  } else {
    return false
  }
}
```

ascii 半角字符 \u0020-\u007E
全角的正则表达式 ^[^\uff00-\uffff]_$
半角的正则表达式 ^[\uFF00-\uFFFF]_$
