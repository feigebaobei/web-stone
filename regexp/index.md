# 正则表达式

## 简介

1. 字符序列形成的搜索模式
2. 可用于文本搜索和文本替换的操作
3. safari 不完全支持正则。

## 定义

/pattern/modifier  
pattern 包括普通字符（eg:a-z。包括可打印字符、不可打印字符。）和特殊字符（也称元字符）

## regexp 对象

### 定义

    let reg0 = new RegExp('\\d{5}', 'g') // 正则表达式中有\时需要替换成\\  多用于动态创建正则表达式。
    let reg1 = /\d{5}/g

### 属性

|                   |      |                                                           |                                 |
| ----------------- | ---- | --------------------------------------------------------- | ------------------------------- |
| RegExp.global     | 只读 | 是否全局检索                                              |                                 |
| RegExp.ignoreCase | 只读 | 是否忽略大小写                                            |                                 |
| RegExp.multiline  | 只读 | 是否多行检索                                              |                                 |
| RegExp.lastIndex  | 读写 | 若设置了 g.这个属性存储整个字符串中下一次检索的开始位置。 | reg.lastIndex reg.lastIndex = 3 |

### 方法

```js
var reg = new RegExp('\\d{5}', 'g')
var str = '1, 2, 3, 4, 5'
reg.exec(str)
// 返回被找到的值，或null。只返回一个匹配结果，并提供本次匹配的完整信息。其结果与str.match(reg) reg不带g 相同
// 其结果与str.match(reg) reg不带g 相同
reg.test(str) // 检查是否存在。返回boolean。
reg.compile(regexp, modifier) // 编译正则表达式。可以用于重新编译正则表达式。
```

| 关键字 | 更多遍历方法                   | 速度                       | 结果                         |
| ------ | ------------------------------ | -------------------------- | ---------------------------- |
| exec() | 使用 reg.lastIndex()方法遍历。 | 慢                         | 可以得到信息、位置、原数据。 |
| test() | 使用 reg.lastIndex()方法遍历。 | 快（比 exec()大约快 5 倍） | 只有得到是否有匹配结果。     |

### string 对象中支持 reg 的方法

```js
str.search(reg / substr) // 返回与正则表达式（或子字符串）相匹配的元素在指定元素中的下标。 number型。 若不匹配则返回-1
str.match(reg / substr)
// 若使用g。则返回如下：
// [匹配结果0, 匹配结果1, 匹配结果2, ...]
// 返回由匹配元素组成的数组。
// 若不使用g，则返回如下：
// ["123abc", index: 0, input: "123abc", groups: undefined]
// 只返回一个匹配结果，并提供本次匹配的完整信息。
str.replace(reg / substr, replacement) //
str.split(reg / substr, howmany) //
```

## 正则对于 string

```js
string.search(reg) // 返回第一个匹配的子串的位置。找不到匹配字符串就返回-1。不支持全局检索，因为它忽略正则表达式参数中的修饰符g。
string.replace(reg, item) // 替换reg匹配（全局或不全局）的子串为item。$1表示引用第一个子串
string.replace(reg, function (match, input, string) {return ...})
string.match(/*/g) // 全局检索时返回一个数组。里面的元素都是检索的结果。或 null
string.match(/*/)  // 非全局检索时返回一个类数组对象。["value", index: 0, input: '原string'] 或 null
'1, 2, 3, 4, 5'.split(/\s*,\s*/) // 返回[1, 2, 3, 4, 5]
```

|                 |                        |     |     |
| --------------- | ---------------------- | --- | --- |
| $1, $2, $3, ... |                        |     |     |
| $&              | 与 regexp 相匹配的子串 |     |     |
| $`              | 匹配子串左侧的文本     |     |     |
| $'              | 匹配子串右侧的文本     |     |     |
| $$              | 直接量符号             |     |     |

## 字符分类

<details>
  <summary>非打印字符</summary>
  <code>
|字符|描述|  
|-|-|  
|\cx||  
|\f|换页符|  
|\n|换行符|  
|\r|回车符|  
|\s|空白字符。包括空格、制表符、换页符等|  
|\S|非空白字符|  
|\t|制表符|  
|\v|垂直制表符|  
  </code>
</details>

<details>
  <summary>匹配符</summary>
  <code>
|字符|描述|  
|-|-|  
|\w|匹配字母或数字或下划线或汉字，等价于[a-zA-Z0-9]|  
|\W|匹配不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]|  
|\s|匹配任意的Unicode空白符|  
|\S|匹配非任意的Unicode空白符|  
|\d|数字[0-9]|  
|.|非换行符(\n)外的任意字符|  
|[\b]|退格直接量（特例）|  
  </code>
</details>

<details>
    <summary>特殊字符（转义字符）</summary>
    <p>简单说就是需要转义的字符。在需要转义的字符前面加`\`</p>
<table>
    <thead>
        <tr>
            <td>字符</td>
            <td>描述</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$</td>
            <td></td>
        </tr>
        <tr>
            <td>()</td>
            <td></td>
        </tr>
        <tr>
            <td>{</td>
            <td></td>
        </tr>
        <tr>
            <td>[</td>
            <td></td>
        </tr>
        <tr>
            <td>+</td>
            <td></td>
        </tr>
        <tr>
            <td>*</td>
            <td></td>
        </tr>
        <tr>
            <td>/</td>
            <td></td>
        </tr>
        <tr>
            <td>|</td>
            <td></td>
        </tr>
        <tr>
            <td>^</td>
            <td></td>
        </tr>
        <tr>
            <td>.</td>
            <td></td>
        </tr>
        <tr>
            <td>?</td>
            <td></td>
        </tr>
    </tbody>
</table>
</details>

<details>
    <summary>限定符</summary>
    <code>
|字符|描述|
|-|-|
|*|>=0|
|+|>=1|
|?|0或1|
|{n}|n次。n>=0|
|{n,}|>=n。n>=0|
|{n,m}|n<=x<=m。n,m>=0|
    </code>
</details>

<details>
    <summary>定位符</summary>
    <code>
|字符|描述|
|-|-|
|^|开头位置|
|$|结尾位置|
|\b|匹配一个字边界，即字与空格间的位置|
|\B|非字边界|
    </code>
</details>

<details>
    <summary>修饰符</summary>
    <code>
|符号|描述|
|-|-|
|i|不区分大小写|
|g|执行全文搜索|
|m|执行多行搜索|
|s|若设置为s则允许`.`包含`\n`，默认不包含。|
    </code>
</details>

<details>
    <summary>反义</summary>
    <code>
|符号|描述|
|-|-|
|[^x]|除了x以外的任意字符|
|\W||
|\S||
|\B|不是单词的开头或结束的位置|
    </code>
</details>

## 贪婪匹配

尽可能多的匹配内容。`.*`  
使用`*`匹配。

## 惰性匹配

尽可能少的匹配内容。`.*?`  
在量词后面加`?`。

```
{m, n}?
{m,}?
+?
??
*?
```

## 选择、分组、引用

```
/a|ab/ // 只匹配a。因为选择项的匹配匹配次序是从左到右。
() // 表示捕获分组。匹配会被缓存起来。使用n访问缓存。
使用括号分组
(?:  ) // 仅用于分组，不用到子表达式引用。
(?=  ) // 仅用于分组，不用到子表达式引用。`exp1(?=exp2)` 查找后面是exp2的exp1  正向先行断言
(?!  ) // 仅用于分组，不用到子表达式引用。负向先行断言
\1 // 第一个缓存的匹配内容
\2 // 第二个缓存的匹配内容
```

**`?=`和`?:`的区别**

|      |              |                                    |
| ---- | ------------ | ---------------------------------- |
| `?=` | 匹配一个位置 | `123(?=456)`,匹配后面有 456 的 123 |
| `?:` | 不记入编号   | `(a)(?:b)(c)\1\2`，匹配 abcac      |

`exp1(?=exp2)` 查找后面是 exp2 的 exp1  
`(?<=exp2)exp1` 查找 exp2 后面的 exp1  
`exp1(?!exp2)` 查找后面不是 exp2 的 exp1  
`(?<!exp2)exp1` 查找前面不是 exp2 的 exp1

左右两侧单双引号匹配

    /(['"])[^'"]*\1/

左右两侧单双引号不匹配

    /['"][^'"]*['"]/

## 优先级

|                          |     |     |
| ------------------------ | --- | --- | --- |
| `\`                      |     |     |
| `(),(?:),(?=),[]`        |     |     |
| `*,+,?,{n},{n,},{n,m}`   |     |     |
| `^,$,\任何字符,任何字符` |     |     |
| `                        | `   |     |     |

## 积累

**匹配时间**

    23:49
    02:03
    /^[01][0-9]|2[0-3]:[0-5][0-9]$/g

**匹配日期**

    2017-05-23
    //年 /[0-9]{4}/
    //月 /0[0-9]|1[0-2]/
    //日 /[0-2][0-9]|3[01]/
    /^(0-9){4}-(0[0-9|1[0-2]])-([0-2][0-9]|3[01])$/g

    // 前瞻：
    exp1(?=exp2) 查找exp2前面的exp1
    // 后顾：
    (?<=exp2)exp1 查找exp2后面的exp1
    // 负前瞻：
    exp1(?!exp2) 查找后面不是exp2的exp1
    // 负后顾：
    (?<!exp2)exp1 查找前面不是exp2的exp1

    // 数字格式化 1,123,000
    "1234567890".replace(/\B(?=(?:\d{3})+(?!\d))/g,",") // 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)

**左右两侧单双引号匹配**

    /(['"])[^'"]*\1/

**左右两侧单双引号不匹配**

    /['"][^'"]*['"]/
