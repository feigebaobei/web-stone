代码改进

# no.20 软件质量概述

## 软件质量的特性

- 正确性
- 易用性
- 效率
- 可靠性
- 完整性
- 适应性
- 精确性
- 健壮性

有一部分是重叠的。质量的外部特性是用户关心的。
程序员关心内部质量特性：

- 可维护性
- 灵活性
- 可移植性
- 可重用性
- 可读性
- 可测试性
- 可理解性  
  内部特性与外部特性之间的差异不是泾渭分明的。  
  有时一个特性会损害另一个特性，有时一个特性会促进另一个特性。

|        | 正确性 | 易用性 | 效率 | 可靠性 | 完整性 | 适应性 | 精确性 | 健壮性 |
| ------ | ------ | ------ | ---- | ------ | ------ | ------ | ------ | ------ |
| 正确性 | -      |        | y    | y      |        |        | y      | n      |
| 易用性 |        | -      |      |        |        | y      | y      |        |
| 效率   | n      |        | -    | n      | n      | n      | n      |        |
| 可靠性 | y      |        |      | -      | y      |        | y      | n      |
| 完整性 |        |        | n    | y      | -      |        |        |        |
| 适应性 |        |        |      |        | n      | -      |        | y      |
| 精确性 | y      |        | n    | y      |        | n      | -      | n      |
| 健壮性 | n      | y      | n    | n      | n      | y      | n      | -      |

## 改进软件质量的技术

软件质量保证是一项需要预先计划的、系统性的活动，其目标是确保系统具有人们所期望的特性。

- 软件质量目标
- 明确的质量保证活动
- 测试策略
- 软件工程指南
- 非正式技术评审
- 正式技术评审
- 外部审计

开发过程

- 变更控制过程
- 结果的度量
- 制作原型

设置目标是实现高质量软件的一个简单、显而易见的步骤。它很容易被忽视。  
质量保证技术的相对效能  
找出缺陷的成本  
修正缺陷的成本

- 对所有需求、所有架构以及系统关键部分的设计进行正式审查
- 建模或创建原型
- 代码阅读或审查
- 执行测试

软件质量的普遍原理

- 提高生产率和改进质量的最佳方法是减少花费在代码返工上的时间，无论返回是由需求变化、设计变更还是调试引起的。（业界平均生产率大约每人每天 10-50 行最终交付代码）

# no.21 协同构建

就是多个程序员在一个写代码。目标是提高软件质量。  
协同构建：

- 结对编程
- 正式审查
- 非正式技术评审
- 文档阅读
- 集体所有制适用于所有形式的协同构建
- 在构建前后保持协作

## 结对编程

- 一个程序员在写代码
- 另一个程序员在观察是否有错误。思考是否代码是否正确以及这些代码是做了正确的事。
- 用编码规范支持结对编程
- 不要让结对编程变成旁观
- 不要强迫在简单的问题上使用结对编程
- 定期对结对人员和分配的工作任务进行轮换
- 鼓励双方跟上对方的步伐
- 确保双方都能看到显示器
- 不要强迫看不顺眼的人结对
- 避免新手组件
- 指定一个组长

好处

- 使人们在压力之下保持更好的状态
- 提升代码质量
- 缩短进度时间表

## 正式审查

在检测缺陷方面很有效。比测试省钱。

### 审查活动中的人员角色

不少于 3 人。

|        |                                                                                                                  |                                      |     |
| ------ | ---------------------------------------------------------------------------------------------------------------- | ------------------------------------ | --- |
| 主持人 | 让审查以一定速度进行。保证会议有成效。尽可能找出最多错误。必须具备技术胜任力。可以不是专家，一定要了解相关细节。 |                                      |     |
| 作者   | 解释设计、代码中不清楚的部分                                                                                     |                                      |     |
| 审查员 | 找出缺陷                                                                                                         |                                      |     |
| 记录员 | 记录审查会议中发现的错误和行动项的分配情况                                                                       | 作者和主持人不能做记录员             |     |
| 管理者 |                                                                                                                  | 邀请管理者参加审核会议一般不是好主意 |     |

### 审查的步骤

|                  |                                                                                                                                                                                                                        |                                                                 |     |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------- | --- |
| 规划             | 作者向主持人提交给主持人。主持人决定由谁审查该材料以及何时何地召开审查会议。                                                                                                                                           |                                                                 |     |
| 概述             | 作者说清创建设计或代码的技术环境。不超过 1h                                                                                                                                                                            | 此阶段可掩盖设计、代码中不清楚的地方。                          |     |
| 准备             | 每人独立审查                                                                                                                                                                                                           | 基于视角审查会发现更多错误。                                    |     |
| 审查会议         | 主持人选择非作者一人阐述设计或阅读代码。说清所有逻辑。陈述进程中记录员记录发现的错误。所有讨论在确认它确实是一个错误时停止。记录员记录错误的类型、严重程度。然后继续审查。若讨论过程未保持聚集，则主持人要收加到正轨。 | 开始：150-200r/h,系统级：90r/h,应用程序：500r/h。一般不过程 2h. |     |
| 审查报告         | 主持人整理会议记录，周知相关同事。                                                                                                                                                                                     | 一天内主持人出报告                                              |     |
| 返工             | 主持人分配给相关相事错误后。由对应的人员解决错误。                                                                                                                                                                     |                                                                 |     |
| 跟进             | - 重新审查。 - 审查部分。 - 修正后不审查。                                                                                                                                                                             |                                                                 |     |
| 第三个小时的会议 | 讨论大家感兴趣的问题的解决方案。                                                                                                                                                                                       |                                                                 |     |
| 对审查进行微调   |                                                                                                                                                                                                                        |                                                                 |     |

审查无固定清单。每个团队由人员组成不同，他们容易范的错误也不同，不容易范的错误也不同。审查清单应该由多次审查后沉淀下来。

### 走查

由 2+个人讨论设计或代码。
解决错误方面，审查更有效。
若每个人的正确率是 80%。则
2 人正确率为 1-(0.2)^2 = 0.96
3 1-(0.2)^3 = 0.992
1-(0.2)^x > 0.9999
x > 5

### 代码阅读

发现错误的效率
||||
|-|-|-|
|代码阅读|3.3 个/h|20%-60%的错误|
|测试|1.8 个/h||
4000 行为宜。  
90%的错误在准备审查会议时发现。10%在审查过程中发现。

依靠审查、走查、代码阅读可提高软件质量。
结对编程与审查基本等效。

# no.22 开发人员测试

测试的 4 个阶段

- 单元测试
- 组件测试
- 集成测试
- 回归测试（没算它）
- 系统测试

| 黑盒测试                         | 白盒测试                         |
| -------------------------------- | -------------------------------- |
| 无法获知所测试程序的内部工作原理 | 已了解所测试程序的内部工作原理。 |
| 避免编写该代码的相同盲点。       |                                  |
|                                  |                                  |

发现 bug 的数量：协同开发 > 测试。

- 测试的目标与开发的目标背道而驰。
- 测试无法证明软件中已无错误。
- 测试不能提高代码质量。测试结果是可衡量软件质量的指标。
- 要求测试者在心理上已经发现错误。

开发时间所占时间比
![图]()

开发人员的测试方法：

- 测试每个相关需求。
- 对每个相关的设计重点进行测试
- 为这些需求和设计添加详细的测试用例
- 列出一个错误检查清单

测试是先做还是后做？先写测试用例。

- 先后测试用例用时相同
- 先写测试用例可更早发现缺陷
- 可使程序员先考虑需求和设计
- 早暴露相关问题
- 会将写好的测试用例保留下来。  
  先写测试用例是过去十年中出现的最有用的软件实践之一。

开发人员的局限性：

- 开发人员采用“干净测试”
- 对测试覆盖率过于乐观
- 跳过复杂的测试覆盖类型

测试技巧：

- 非完整测试
- 结构化基础测试
  - 测试用例的数量： 从 1 开始，每遇到 if/while/repeat/for/and/or 加 1。每个 case 加 1，没有 default 加 1.
- 数据流测试
- 数据状态的组合
- 等价划分。一个测试用例代表一部分可能的输入数据。
- 错误猜测
- 边界分析
- 复合边界
- 不良数据的类别
- 良好数据的类别
- 使用便于进行手工检查的测试用例

典型错误

- 从错误最多的地方开始改。
- 80%的错误出现在项目 20%的类或子程序中。
- 项目 50%的错误出现在 5%的类中。
- 提高质量可以缩短开发周期降低开发成本。

错误分类

- 25.18% 结构性错误
- 22.44% 数据错误
- 16.19% 功能实施错误
- 9.88% 构建错误
- 8.98% 集成错误
- 8.12% 功能需求错误
- 2.76% 测试定义或测试执行错误
- 1.74% 系统、软件架构错误
- 4.71% 其他非特定类型错误

- 大多数错误的范围是相当有限的。
- 许多错误和代码构建无关，与相关领域的知识有关。
- 大多数代码构建错误都是程序员人为错误
- 令人惊讶的是，笔误（拼写错误）是问题的常见来源。
- 对程序员错误的研究中，对设计的误解是个老生常谈的主题。
- 大多数错误修复起来很容易。
- 度量自己组织的错误相关经验是个好主意。

![错误的比例]()

期望发现多少错误

- 业内经验是，1-25 个/1000 行。
- 内部测试阶段，10-20 个/1000 行。
- 净室开发，0.1-3 个/1000 行。
- tsp，0.6 个/1000 行。

- 写测试用例
- 用小项目测试
- 用工具测试
- 单独运行一个方法

测试数据生成器
覆盖率监测
数据记录器、日志  
符号调试器  
系统干扰器  
维护测试记录。让测试过程变得可重复之外，还需要对项目进行度量。
单次-》多次-》循环、递归
个性-》重复-》批处理 脚手架
具象-》抽象-》沉淀、分层 模板 有背景色画

个人测试记录。定性分析-》定量分析。
跟踪自己的测试记录，分析常犯的错误，在编写代码、测试代码、修正错误上所花的时间。

《编程珠玑》
《测试驱动开发》

# no.23 调试

调试是识别错误的根本原因并纠正它的过程。
决定软件的质量的因素：（由大到小排列）

1. 需求分析
2. 良好设计
3. 高质量代编码
4. 调试

缺陷即机会

- 理解自己要编写的程序
- 理解自己犯下的错误属于什么类型
- 从代码阅读者的角度理解代码质量
- 从解决缺陷的方法中学习

真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。—— 鲁讯

无效的方法

- 靠猜来发现缺陷
- 不要浪费时间去理解问题
- 迷信调试、

调试的科学方法

1. 通过可重复的实验搜集数据
2. 形成一个解释相关数据的假设
3. 设计一个实验来证明或证伪该假设
4. 证明或证伪该假设
5. 按需重复以上步骤

如果缺陷不能可靠地复现，是几乎不可能进行诊断的。
定位错误的根源
查出缺陷的小技巧

- 使用所有可用的数据来做假设
- 精炼产生错误的测试用例
- 在单元测试套件中运行代码。
- 使用可用的工具
- 用不同的几种方法重现错误
- 生成更多数据来产生过多的假设
- 头脑分晓找出可能的假设
- 列出尝试的事情
- 以前有缺陷的类、子程序值行怀疑
- 检查最近变更的代码
- 扩大可疑的代码区域
- 逐步集成
- 检查常见缺陷
- 向别人讲述问题
- 放下问题，先休息一下。

暴力调试
语法错误
修复缺陷

- 先理解问题再修复
- 理解程序，而不仅仅是问题
- 确认缺陷诊断结论
- 放松
- 保存原始代码
- 修复问题
- 仅在有充分理由的情况下修改代码
- 一次只改一处
- 检查修复的程序
- 添加一个暴露缺陷的单元测试
- 寻找类似的缺陷

源代码比较工具
编译器告警消息
扩展语法和逻辑检查
代码执行分析工具
测试框架、脚手架
调试工具

# no.24 重构

理想世界：一个管理良好的软件项目会进行有条理的需求开发、并定义一个稳定的程序功能清单，设计按需求进行，而且仔细进行，使编码能从开始到结束以线性方式完成。
现实世界：代码在最初的开发过程中会发生大幅演化。最初编码过程中的许多变化和维护过程中的变化起码都一样显著。在一个典型的项目中，编码、调试和单测的工作量占比 30%-65%，具体由项目规模定。
结构化编程的最初使用是“分解”，指将一个程序尽可能地分解成组成部分。
重构：在不改变其可观察的行为的情况下，对软件内部结构进行修改，使其更容易理解，修改起来代价更低。

## 重构的理由：

|                                        |                                                  |                                                  |
| -------------------------------------- | ------------------------------------------------ | ------------------------------------------------ |
| 代码发生重复                           | 整理为单例对外输出                               |                                                  |
| 子程序太长                             | 模块化，即增加定义清晰、名称明确的子程序         |                                                  |
| 类的内聚力很差                         | 把不相关的功能拆成别的类                         |                                                  |
| 类的接口不能提供一致的抽象层级         | -                                                | 因迭代不规范造成的                               |
| 参数表有太多参数                       | 分解成良好的、小成子程序                         |                                                  |
| 在类中进行的修改各自独立               | 应该按不同职责拆成多个类                         |                                                  |
| 必须并行修改多个类                     | 单例                                             |                                                  |
| 必须并行修改继承层次结构               | -                                                | 这是平行修改                                     |
| 必须并行修改 case                      |                                                  |                                                  |
| 一起使用的相关数据没有被组织成类       |                                                  |                                                  |
| 一个子程序使用了另一个类的特性         | 子程序移入另一个类                               |                                                  |
| 无脑使用基本数据类型                   |                                                  |                                                  |
| 类的作用不大                           | 把该类的工作迁入另一个类。                       |                                                  |
| 子程序链传递流浪数据                   |                                                  |                                                  |
| 中间对象不做任务事情                   | 取消中间对象                                     |                                                  |
| 一个类与另一个类过于亲密               |                                                  |                                                  |
| 某个子程序的名字太差劲                 | 定义一个名符其实的名字                           |                                                  |
| 公共数据成员                           |                                                  |                                                  |
| 一个子类只使用了其父类的一小部分子程序 | 把关系从属于改为拥有。即将数据转换为子类需要的。 | 子类未超父类                                     |
| 用注释解释难以理解的代码               |                                                  | 注释不用于解决代码。糟糕的代码不要存，必须重写。 |
| 全局变量的使用                         |                                                  |                                                  |
| 程序中包含的代码似乎有一天总会用得着   |                                                  | 超前设计                                         |

写代码 <-> 迭代 <-> 重构
优先前者，其次后者。
小 <----- 变动 -----> 大

## 特定的重构

数据级重构
||||
|-|-|-|
|神秘数字-》具名常量|||
|用更清晰或更有信息量的名字重命名变量|||
|使表达式内联|||
|用子程序替代表达式|||
|引入中间变量|||
|将一个多用途的变量转换为多个单用例的变量|||
|局部的用途就用局部变量，不要用参数|||
|将数据基本无转换为类|||
|将一组类型代码（type codes）转换为类或枚举|||
|将一组类型代码转换为带有子类的类|||
|将数组改为对象|||
|封装集合|||
|用数据类替代传统记录|||

语句级重构
||||
|-|-|-|
|分解布尔表达式|||
|将复杂布尔表达式移入一个命名良好的布尔函数|||
|合并条件语句不同部分的重复片段|||
|使用 break 或 return 替代循环控制变量|||
|知道答案后立即返回，而不是在嵌套 if-then-else 语句中赋一个返回值|||
|用多态替代条件语句（尤其是重复的 case 语句）|||
|创建和使用空对象，而不是测试空值|||

子程序级重构
||||
|-|-|-|
|提取子程序/提取方法|||
|内联子程序的代码|||
|将长的子程序转换为类|||
|用简单算法代替复杂算法|||
|增加参数|||
|删除参数|||
|将查询操作与修改操作分开|||
|通过参数化合并类似的子程序|||
|分解行为依赖于传入参数的子程序|||
|传递整个对象而不是特定的字段|||
|传递特定的字段而不是整个对象|||
|封装向下转型|||

类级重构
||||
|-|-|-|
|将值对象修改为引用对象|||
|将引用对象修改为值对象|||
|用数据初始化替代虚函数|||
|改变成员函数或数据的位置|||
|将特化代码提取到一个子类中|||
|将相似代码合并到超类中|||

类接口重构
||||
|-|-|-|
|将子程序移到另一个类中|||
|将一个类转换为两个|||
|淘汰没作用的类|||
|隐藏委托|||
|去掉中间人|||
|用委托代替继承|||
|用继承代替委托|||
|引入外来的子程序|||
|引入扩展类|||
|封装公开的成品变量|||
|删除不可修改的字段的 set 子程序|||
|隐藏不打算在类外使用的子程序|||
|封装未使用的子程序|||
|合并实现厚厚相似的超类和子类|||

系统级重构
||||
|-|-|-|
|为你无法控制的数据创建一个明确的引用源|||
|将单向类关联改为双向类关联|||
|将双向类关联改为单向类关联|||
|提供工厂方法而不是简单构造函数|||
|用异常代替错误代码或相反|||

安全重构
||||
|-|-|-|
|保存开始时的代码|||
|保持小幅重构|||
|一次一个重构|||
|列出步骤清单|||
|做一个停车场|||
|经常做检查点|||
|利用编译器警告|||
|重新测试|||
|添加测试用例|||
|审查修改|||
|基于重构风险等级来调整方法|||

不宜重构的情况
||||
|-|-|-|
|不要将重构作为编码和修复的幌子|||
|避免重构而不是重写|||
||||

## 重构策略

|                                                                |                                                    |     |
| -------------------------------------------------------------- | -------------------------------------------------- | --- |
| 添加子程序时重构                                               |                                                    |     |
| 添加类时重构                                                   |                                                    |     |
| 修复缺陷时重构                                                 |                                                    |     |
| 瞄准容易出错的模块                                             |                                                    |     |
| 在维护环境中，改进你所接触的部分                               |                                                    |     |
| 在干净的代码和丑陋的代码之间定义一个接口，再通过接口移动代码。 | 界定哪些需要重构，一直界定到不能再界定，然后重构。 |     |

明确现有不足
确定如何改进
划定影响范围
制定切流方案
制定容灾方案
界定新旧代码同时存在的时间，尽量减少该时长。
制定应急方案

# no.25 代码调优策略

程序架构、类的设计、算法比代码调优改进性能更明显。

## 如何调优

- 程序需求
- 程序设计
  - 设计单独资源目标
  - 明确个人的目标
  - 可设定一些各效率没有直接关系
- 类和子程序设计
- 操作系统交互
- 代码编译
- 硬件
- 代码调优

诸多因素平衡才是好代码。
高效的代码不一定是“更好”的代码。
“别因强求最优面使好事难成”——伏尔泰
先完成再完善

## 一些无稽之谈

- 减小高级语言中的代码行数可提升所生成的机器码的速度可缩小其规模
- 某些操作可能比其他操作更快或者更小。
- 即刻优化
  - 几乎不可能在程序完全跑起来之前确定性能瓶颈
  - 即使在极少数情况下开发人员识别出瓶颈，他们也会过犹不及地对待这个瓶颈，以至于顾此失彼。
  - 在初始化开发中专注于优化，有碍于完成其他的程序目标。
- 快的程序和正确的程序同等重要。（这几乎不可能同时满足）

## 何时调优

非必要，不优化。
在没有绝对清晰的未优化方案之前，请不要进行优化。——杰克逊

## 效率低下的常见根源

- 输入、输出操作
- 分页
- 系统调用
- 解释型语言
- 错误

## 方法总结

1. 使用良好设计的代码来开发软件，使其易于理解和修改
2. 若性能很差，则采取以下操作
   1. 保存一个能正常工作的版本，以便能回到“最后已知良好状态”
   2. 度量系统以找到热点
   3. 确定性能低下是否来自于设计、数据类型或算法的不足，以及是否适合代码调优。如果不适合代码调优，返回步骤 1.
   4. 对步骤 2.3 中确定的瓶颈进行调优
   5. 逐一度量每一项改进
   6. 如果一项改进没有提升性能，就恢复步骤 2.1
3. 重复步骤 2

# no.26 代码调优技术

代码调优是小幅改变，而不是对设计的大幅改变。

## 逻辑

|                            |                          |     |
| -------------------------- | ------------------------ | --- |
| 知道答案后就停止测试       | if/confinue/break/return |     |
| 按频率调整测试顺序         |                          |     |
| 相似逻辑结构之间的性能比较 |                          |     |
|                            | 查表代替复杂的表达式     |     |
|                            | 使用惰性过值             |     |

## 循环

|                      |                                |     |
| -------------------- | ------------------------------ | --- |
| 循环判断外提         | for+if/else => if+for+else+for |     |
| 合并                 | 多个循环体放在一个循环体中     |     |
| 展开                 | 减小循环体重                   |     |
| 最小化循环内部的工作 |                                |     |
| 哨兵值               |                                |     |
| 最忙的循环放在最内层 | 就是循环次数大的放在外面       |     |
| 降低强度             |                                |     |

## 数据变换

|                  |     |     |
| ---------------- | --- | --- |
| float => int     |     |     |
| 数组维度尽可能少 |     |     |
| 最小化数组引用   |     |     |
| 使用辅助索引     |     |     |
| 使用缓存         |     |     |

## 表达式

|                  |                                                    |     |
| ---------------- | -------------------------------------------------- | --- | --- | --- |
| 利用代数恒等式   | 如`!a && !b`=>`!(a                                 |     | b)` |     |
| 降低强度         |                                                    |     |
|                  | 乘法 =》 加法                                      |     |
|                  | 幂 =》 乘法                                        |     |
|                  | 三角函数 =》 三角恒等式                            |     |
|                  | float/long =》 int                                 |     |
|                  | 乘 2、除 2 =》 移位                                |     |
| 在编译时初始化   |                                                    |     |
| 小心系统子程序   | 一般精度都很快。当不需要太精确时可重写系统子程序。 |     |
| 预计算结果       |                                                    |     |
|                  | 在程序执行前计算出结果                             |     |
|                  | 循环前使用算好的结果                               |     |
| 消除公共子表达式 | 就是缓存子表达式的结果                             |     |

## 子程序

代码调优最强大的工具之一是好的子程序分解。

## 用低层语言重新编码
