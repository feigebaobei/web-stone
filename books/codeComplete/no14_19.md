# no.14 直线型代码的组织

面向顺序编程
顺序执行的方式：

- 组织代码，使依赖关系显而易见。
- 子程序的命名要揭示依赖关系。
- 使用子程序参数来揭示依赖关系。

自上而下的顺序对可读性贡献最大。  
相关语句分在一组。

# no.15 使用条件语句

```
if else
switch case
```

先写正常情况，再写否正常情况。
正常情况的逻辑写在 if 内（非 else 内）。  
用布尔函数调用可简化复杂测试  
最常见的情况放在最前面。

选择最有效的 case 顺序

- 按频率排列
- 按字母、数字顺序排列
- 正常情况定在最前面
- default 检测错误

# no.16 控制循环

循环类型：

- 控制次数
- 每次迭代判断是否完成
- 一旦开始就无限循环，常用于嵌入式系统。如心脏起搏器。

先判断再循环 while
先循环再判断 do while

退出循环

- 确保循环会终止
- 循环结束条件显而易见
- 考虑使用安全计数器
- 提前处理循环
  - break
  - continue
  - 最后使用 return
  - 检查端点
    - 第一个的前一个
    - 第一个
    - 循环内的任一个（非第一，非最后）
    - 最后一个
    - 最后一人的后一个

控制循环

- 只从一个地方进入循环
- 在循环前写初始化代码
- 将 while(true)用于无限循环

处理循环体

- 避免空循环
- 在循环开头或结尾处理循环内务处理
- 每个循环只做一个功能

使用循环变量

- 使用有意义的变量名
  - 如：setNameIndex
- 避免循环索引串扰
- 循环变量的作用域限制在循环内部

循环的理想长度

- 一屏内
- 三层内
- 长循环写有子程序中

# no.17 不常见的控制结构

一个方法中少写几个 return  
递归：

- 确保可以停止
- 使用安全计数器来防止无限递归
- 把递归放在一个子程序中
- 留意栈以防溢出
-

# no.18 表驱动法

写一个 mysql

```
          数据存在的空间<Map>
    |-----------------|           索引表1         索引表的索引表
    |                 |          |------|      |--------|
    |          数据1 --|----------|      |------|        |
    |                 |          |------|      |        |
    |                 |                        |        |
    |                 |           索引表n       |        |
    |                 |          |------|      |        |
    |          数据2 --|----------|      |------|        |
    |                 |          |------|      |--------|
    |                 |
    |                 |           ......
    |                 |
    |-----------------|

```

- 直接访问表
- 索引访问表
  - 移动索引总比移动数据快
- 阶梯访问表
  - 把浮点数转换为整数索引
  - 可很好地处理不规则数据

与其试图找到最佳方案，不如努力找到一个好的方案后尽量并避免灾难 ---- Butler Lampson

# no.19 常规控制问题

简化复杂的表达式

- 使用新的布尔变量将复杂的测试拆分为部分测试
- 将复杂的表达式转移到返回布尔值的函数
- 使用决策表替代复杂条件
- 使用德摩根定理简化否定形式的布尔判断
- 使用圆括号澄清布尔表达式

简化深层嵌套

- 使用 break 块简化嵌套 if
- 将嵌套 if 转换为一组 if-then-else
- 将嵌套 if 转换为 case 语句
- 将深层嵌套的代码纳入子程序中
- 使用更面向对象的方法
- 重新设计深层嵌套的代码
  - 从 case 变为多态对象

## 德摩根定理

|          |      |     |
| -------- | ---- | --- | ----------- | --- |
| !a && !b | !(a  |     | b)          |     |
| !a && b  | !(a  |     | !b)         |     |
| a && !b  | !(!a |     | b)          |     |
| a && b   | !(!a |     | !b)         |     |
| !a       |      | !b  | !(a && b)   |     |
| !a       |      | b   | !(a && !b)  |     |
| a        |      | !b  | !(!a && b)  |     |
| a        |      | b   | !(!a && !b) |     |

提取非在前
ab 各取反
与变或，或变与

## 结构化编程

来自 Edsger W. Dijkstra 1969 的论文。  
结构化一词火了以后，产生了结构化分析、结构化设计、结构代偷懒。  
结构化程序以一种有序的、有规律的方式进行。不会不可预测地跳转。  
由三部分组成：

- 顺序
- 分支
- 循环  
  它们也是任何编程语言的基本组成部分。

## 复杂度

Tom McCabe 的论文中提出程序的复杂度由其控制流程决定。其实还包括循环等。

- 增加程序员的脑容量
- 降低复杂度

复杂度由计算子程序的决策点的数量决定。

1. 从头开始，沿子程序常规路径开始计数。
2. 遇到以下每个关键字或其等价表示都递增 1
3. 为每个 case 递增 1

|      |                                                        |
| ---- | ------------------------------------------------------ |
| 0-5  | 子程序可能还行                                         |
| 6-10 | 开始考虑如何简化这个子程序                             |
| 11+  | 将子程序的一部分分解到子程序，并在该方法中调用子程序。 |

### 其他类型的复杂度

- 使用的数据量
- 控制结构的嵌套层数
- 代码行数
- 以变量的连续引用之间的行数
- 变量被使用的行数
- 输入量
- 输出量
