高质量的代码

# no.5 软件构建的设计

在较大开项目中，正式架构可能只关注系统级的问题，许多设计工作可能有意留给构建。  
设计没有章法，即使它产生的结果有条理。  
设计工作的一个关键部分是权衡相互竞争的设计特性。 - 存储空间

- 运行速度
- 开发时长
- 安全
- 错误处理

没有一种工具是万能的。  
设计需要设计评审、非正式讨论、写代码。  
项目失败最常见的原因是需求不到位、计划不周或管理不善。  
应该使用一种安全的、一次只专注其中一部分的方法来组织程序。目标是尽量减少任何时候都要考虑的程序的数量。  
在软件架构层面，问题的复杂性通过将系统分为子系统来降低。把复杂问题分为若干简单问题。子系统越独立，就越能使其安全地专注于解决一个复杂的点。精心定义的对象将关注点分开，这样就可以一次只专注于一件事。  
理想的设计特征

- 最小化的复杂性。
- 层次性
- 易维护
- 松耦合
- 可扩展性
- 可重用性
- 高扇入
- 低、中扇出
- 移植性
- 精简性
- 标准技术

设计的层次

- 软件系统
- 分解为子系统
- 分解包中的类
- 分解为类中的数据和子程序
- 设计内部子程序

隐藏秘密（信息隐藏）

- 结构化设计的结果
- 保护自身的隐私权
- 类的接口应尽可能少地透露内部运作（增加内聚性）
- 容易实现松耦合

设计类的接口是一个迭代过程。一般会设计几次。  
容易变动的区域

1. 确定可能会变动的地方
2. 分离可能发生变化的项
3. 隔离可能发生变化的项

设计模式

- 力求强内聚性
- 建立层次结构
- 正式化类的契约
- 分配职责
- 为测试而设计
- 避免失败
- 有意识地选择绑定时间
- 建立中心控制点
- 考虑使用蛮力
- 画图
- 保持设计的模块化

设计往往需要从高层和低层 2 个角度，多次反复考虑。  
自上而下的设计方法。是分解策略。从一般性问题出发，将其分解成可管理的部分。
自下而上的设计方法。是合成策略。从可管理的部分出发，组成一般性的解决方案。  
二者相辅相成。

宁愿用 80%的设计工作用于创建和探索多种备选设计方案，20%用于创建粗略不太精练的文档。

# no.6 可以工作的类

基于语句思考编程问题 》 基于子程序 》 基于类

## adt 抽象数据类型 abstract data type 由实例到类的过程

对数据进行的操作的集合。

1. 提供描述数据的能力
2. 可改变数据的能力

好处：

- 可以隐藏实现细节
- 修改不影响整个程序
- 可让接口提供更多信息
- 更容易提高性能
- 更容易确定程序的正确性。（方便单元测试）
- 程序可读性更佳
- 不必在中到处传递数据
- 可以直接操作现实世界的实体，不必操作低级的实现结构

## 良好的接口

- 在类的接口中呈现一致的抽象级别
- 一定要理解类实现的是什么抽象
- 成对提供服务并包含反向操作
- 将不相关的信息移到另一个类中
- 尽可能使接口可编程而不是表达语义
- 不要添加与接口抽象不一致的公共成员
- 把抽象和内聚入在一起考虑

## 良好的封装

- 最小化类和成员的可访问性
- 不要公开成员数据
- 避免将私有实现细节放到类的接口中
- 不要对类的用户做出预设
- 避免友元类
- 不要因为子程序只使用了公共子程序就把它放到公共接口中
- 倾向于读代码方便而不是写代码方便
- 格外警惕在语义上破坏封装
- 警惕过于紧密的耦合
- 耦合与抽象、封装相辅相成

## 设计和实现问题

### 包含

- 类应该包含哪些属性、方法
- 不到万不得已不使用私有继承
- 方法数最好在 7+-2 个内

### 继承

- 通过 public 实现继承
- 要么设计继承并提供文档说明，要么禁止继承
- 遵循里氏替换原则
- 只继承想继承的东西
- 不要“覆盖”不可覆盖的成员函数
- 将通用接口、数据和行为移到继承树中尽可能高的位置
- 对仅一个实例的类持怀疑态度
- 对仅一个派生类的基类持怀疑态度
- 对覆盖了子程序但在子程序的派生版本中什么都不做的类持怀疑态度
- 避免过深的继承树
- 尽量利用多态而不是全面的类型检查

### 多重继承

### 成员函数和数据

- 尽量减少类中子程序数量
- 禁止隐式生成不需要的成员函数各操作符
- 尽量减少类调用的不同子程序的数量
- 尽量减少对其他类的间接子程序调用

### 构造函数

- 尽可能在所有构造函数中初始化所有成员数据
- 使用 private 构造函数强制单例属性
- 除非认证可行，否则使用深拷贝而不是浅拷贝

### 创建类的理由

- 建构现实世界中的对象。
- 建模抽象对象
- 降低复杂性
- 隔离复杂性
- 隐藏实现细节
- 限制变化千万的影响
- 隐藏全局数据
- 简化参数传递
- 建立中心控制点
- 使代码更容易重用
- 为程序家庭做计划
- 打包相关操作
- 实现特定的重构
- 避免创建万能类
- 消除无关紧要的类
- 避免以动词命名的类

# no.7 高质量的子程序

# no.8 防御式编程

# no.9 伪代码编程过程
