高质量的代码

# no.5 软件构建的设计

在较大开项目中，正式架构可能只关注系统级的问题，许多设计工作可能有意留给构建。  
设计没有章法，即使它产生的结果有条理。  
设计工作的一个关键部分是权衡相互竞争的设计特性。 - 存储空间

- 运行速度
- 开发时长
- 安全
- 错误处理

没有一种工具是万能的。  
设计需要设计评审、非正式讨论、写代码。  
项目失败最常见的原因是需求不到位、计划不周或管理不善。  
应该使用一种安全的、一次只专注其中一部分的方法来组织程序。目标是尽量减少任何时候都要考虑的程序的数量。  
在软件架构层面，问题的复杂性通过将系统分为子系统来降低。把复杂问题分为若干简单问题。子系统越独立，就越能使其安全地专注于解决一个复杂的点。精心定义的对象将关注点分开，这样就可以一次只专注于一件事。  
理想的设计特征

- 最小化的复杂性。
- 层次性
- 易维护
- 松耦合
- 可扩展性
- 可重用性
- 高扇入
- 低、中扇出
- 移植性
- 精简性
- 标准技术

设计的层次

- 软件系统
- 分解为子系统
- 分解包中的类
- 分解为类中的数据和子程序
- 设计内部子程序

隐藏秘密（信息隐藏）

- 结构化设计的结果
- 保护自身的隐私权
- 类的接口应尽可能少地透露内部运作（增加内聚性）
- 容易实现松耦合

设计类的接口是一个迭代过程。一般会设计几次。  
容易变动的区域

1. 确定可能会变动的地方
2. 分离可能发生变化的项
3. 隔离可能发生变化的项

设计模式

- 力求强内聚性
- 建立层次结构
- 正式化类的契约
- 分配职责
- 为测试而设计
- 避免失败
- 有意识地选择绑定时间
- 建立中心控制点
- 考虑使用蛮力
- 画图
- 保持设计的模块化

设计往往需要从高层和低层 2 个角度，多次反复考虑。  
自上而下的设计方法。是分解策略。从一般性问题出发，将其分解成可管理的部分。
自下而上的设计方法。是合成策略。从可管理的部分出发，组成一般性的解决方案。  
二者相辅相成。

宁愿用 80%的设计工作用于创建和探索多种备选设计方案，20%用于创建粗略不太精练的文档。

# no.6 可以工作的类

基于语句思考编程问题 》 基于子程序 》 基于类

## adt 抽象数据类型 abstract data type 由实例到类的过程

对数据进行的操作的集合。

1. 提供描述数据的能力
2. 可改变数据的能力

好处：

- 可以隐藏实现细节
- 修改不影响整个程序
- 可让接口提供更多信息
- 更容易提高性能
- 更容易确定程序的正确性。（方便单元测试）
- 程序可读性更佳
- 不必在中到处传递数据
- 可以直接操作现实世界的实体，不必操作低级的实现结构

## 良好的接口

- 在类的接口中呈现一致的抽象级别
- 一定要理解类实现的是什么抽象
- 成对提供服务并包含反向操作
- 将不相关的信息移到另一个类中
- 尽可能使接口可编程而不是表达语义
- 不要添加与接口抽象不一致的公共成员
- 把抽象和内聚入在一起考虑

## 良好的封装

- 最小化类和成员的可访问性
- 不要公开成员数据
- 避免将私有实现细节放到类的接口中
- 不要对类的用户做出预设
- 避免友元类
- 不要因为子程序只使用了公共子程序就把它放到公共接口中
- 倾向于读代码方便而不是写代码方便
- 格外警惕在语义上破坏封装
- 警惕过于紧密的耦合
- 耦合与抽象、封装相辅相成

## 设计和实现问题

### 包含

- 类应该包含哪些属性、方法
- 不到万不得已不使用私有继承
- 方法数最好在 7+-2 个内

### 继承

- 通过 public 实现继承
- 要么设计继承并提供文档说明，要么禁止继承
- 遵循里氏替换原则
- 只继承想继承的东西
- 不要“覆盖”不可覆盖的成员函数
- 将通用接口、数据和行为移到继承树中尽可能高的位置
- 对仅一个实例的类持怀疑态度
- 对仅一个派生类的基类持怀疑态度
- 对覆盖了子程序但在子程序的派生版本中什么都不做的类持怀疑态度
- 避免过深的继承树
- 尽量利用多态而不是全面的类型检查

### 多重继承

### 成员函数和数据

- 尽量减少类中子程序数量
- 禁止隐式生成不需要的成员函数各操作符
- 尽量减少类调用的不同子程序的数量
- 尽量减少对其他类的间接子程序调用

### 构造函数

- 尽可能在所有构造函数中初始化所有成员数据
- 使用 private 构造函数强制单例属性
- 除非认证可行，否则使用深拷贝而不是浅拷贝

### 创建类的理由

- 建构现实世界中的对象。
- 建模抽象对象
- 降低复杂性
- 隔离复杂性
- 隐藏实现细节
- 限制变化千万的影响
- 隐藏全局数据
- 简化参数传递
- 建立中心控制点
- 使代码更容易重用
- 为程序家庭做计划
- 打包相关操作
- 实现特定的重构
- 避免创建万能类
- 消除无关紧要的类
- 避免以动词命名的类

# no.7 高质量的子程序

- 可读性
- 节省空间
- 提高性能

## 创建子程序的正当理由

- 分层
- 分块
- 分支（无前后）

|                      |                                          |     |     |
| -------------------- | ---------------------------------------- | --- | --- |
| 降低复杂性           |                                          |     |     |
| 避免重复代码         |                                          |     |     |
| 支持子类化           |                                          |     |     |
| 隐藏处理顺序         |                                          |     |     |
| 隐藏指针操作         |                                          |     |     |
| 提高可移植性         |                                          |     |     |
| 简化复杂的布尔表达式 |                                          |     |     |
| 方便提高性能         | 只需要修改一处代码，就可提高全量的性能。 |     |     |

## 子程序级别的设计

|        |                                                                                                                                                                                            |     |     |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --- | --- |
| 内聚性 | 功能内聚、顺序内聚、通信内聚、瞬时内聚、过程内聚、逻辑内聚、偶发内聚                                                                                                                       |     |     |
| 名称   | 描述全部功能，避免无意义、模糊、空泛的动词。不要只用数字来区分子程序名称。                                                                                                                 |     |     |
| 参数   | 按“输入-修改-输出”的顺序来排列参数。可以考虑创建自己专属的 IN 关键字和 OUT 关键字。使用所有参数。将状态和变量放在最后。子程序参数不作为工作变量使用。参数在 7 个左右。确保实参与形参匹配。 |     |     |

## 函数 & 过程

|     | 函数                             | 过程             |     |
| --- | -------------------------------- | ---------------- | --- |
|     | 有返回值的子程序                 | 无返回值的子程序 |     |
|     | 不返回指向局部数据的引用或指针。 |                  |     |

## 宏子程序和内联子程序

# no.8 防御式编程

防御式编程：即使向子程序传入错误数据，它也不会受到破坏，哪怕这些错误数据是由其他子程序产生的。  
ts 可用于（就是）防御式编程  
防御式编程在于防御意想不到的错误。

1. 垃圾进，错误提示出。
2. 垃圾进，什么都不出。
3. 垃圾乾，垃圾出。

## 保护程序

|                              |     |     |     |
| ---------------------------- | --- | --- | --- |
| 检查来源于外部的所有数据的值 |     |     |     |
| 检查子程序所有输入参数       |     |     |     |
| 决定如何处理错误的输入数据   |     |     |     |

## 断言

### 错误 & 断言

|     | 错误             | 断言             |     |
| --- | ---------------- | ---------------- | --- |
|     | 处理预期内的问题 | 处理预期外的问题 |     |
|     | 用于兼容、兜底   | 明确功能边界     |     |

### 如何健壮

- 断言参数
- 强类型

## 错误处理技术

|                              |                            |                            |     |
| ---------------------------- | -------------------------- | -------------------------- | --- |
| 返回中立值                   |                            |                            |     |
| 换用下一条有效数据           | 路过当次错误，执行下次     |                            |     |
| 返回与上次相同的答案         |                            |                            |     |
| 换用最接近的合法值           |                            |                            |     |
| 在文件中记录警告信息         |                            |                            |     |
| 返回一个错误代码             | http 中常用 500 =》 xxxxxx |                            |     |
| 调用错误处理子程序或对象     | 封装错误对象。             | axios                      |     |
| 用最妥当的方式在局部处理错误 |                            |                            |     |
| 关闭程序                     | 原子性。                   | react/vue 都在出错时不渲染 |     |

## 异常

|                                          |     |     |     |
| ---------------------------------------- | --- | --- | --- |
| 使用异常来通知程序其他部分不应忽略的错误 |     |     |     |
| 仅在真正异常的情况下才抛出异常           |     |     |     |
| 不要使用异常来推荐责任                   |     |     |     |
| 在合适的抽象层级抛出异常                 |     |     |     |
| 在异常消息中包括导致异常的所有信息       |     |     |     |
| 避免使用空的 catch 块                    |     |     |     |
| 了解库代码所抛出的异常                   |     |     |     |
| 考虑创建一个集中式异常报告程序           |     |     |     |
| 把项目中对异常的使用标准化               |     |     |     |
| 考虑异常的替代方案                       |     |     |     |

## 隔离程序

沙箱模式  
使之包容由错误造成的损害  
是一种容损策略

```
若干数据 =》栅栏 =》 程序
```

## 调试辅助代码

### 进攻式编程

放大错误。

|                                                                                |     |     |     |
| ------------------------------------------------------------------------------ | --- | --- | --- |
| 确保断言语句可以使程序终止运行                                                 |     |     |     |
| 完全填充分配到所有内存                                                         |     |     |     |
| 完全填充分配到的所有文件或流                                                   |     |     |     |
| 确保每个 case 语句中的 default 分支或 else 分支都能产生严重的错误              |     |     |     |
| 在删除对象前使其填满垃圾数据                                                   |     |     |     |
| 让程序把错误日志通过电子邮件发送给你，让你可以看到已发布软件中发生的各种错误。 |     |     |     |

### 生产版本的代码中保留多少防御式代码

|                              |            |     |     |
| ---------------------------- | ---------- | --- | --- |
| 保留用于检查重要错误的代码   |            |     |     |
| 删除用于微不足道错误的代码   |            |     |     |
| 删除导致便性崩溃的代码       | 进攻式代码 |     |     |
| 保留有助于程序优雅崩溃的代码 |            |     |     |
| 为技术支持人员记录错误信息   |            |     |     |
| 确认留下的错误消息是友好的   |            |     |     |

# no.9 伪代码编程过程

ppp pseudocode programming process  
伪代码是指非正式的和自然语言差不多的一种表示法。描述了算法、子程序、类或程度如何工作。

|                                      |     |     |     |
| ------------------------------------ | --- | --- | --- |
| 伪代码有利于设计审查                 |     |     |     |
| 伪代码支持迭代细化的理念             |     |     |     |
| 伪代码使个性更容易                   |     |     |     |
| 伪代码使注释工作最小化               |     |     |     |
| 伪代码比其他形式的设计文档更容易维护 |     |     |     |
