<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- <p>我们合作一次。</p> -->
    <script type="module" >
        let clog = console.log
        // 工具方法
        let sum = (arr) => {
            return arr.reduce((r, c) => {
                return r += c
            }, 0)
        }
        
        let isReverseStr = (s) => {
            let bool = true
            if (!s) { // ''
                bool = false
            } else {
                let arr = s.split('')
                for (let i = 0; i < arr.length / 2; i++) {
                    if (arr[i] === arr[arr.length - 1 - i]) {} else {
                        bool = false
                        break;
                    }
                }
            }
            return bool
        }
        // clog(isReverseStr(''))
        // clog(isReverseStr('a'))
        // clog(isReverseStr('ab'))
        // clog(isReverseStr('abc'))
        // clog(isReverseStr('aba'))
        // clog(isReverseStr('abba'))
        // clog(isReverseStr('abbac'))


        let arr = [
            {
                bookId: 'bookId',
                borrowCount: 0,
            },
            {
                bookId: 'bookId',
                borrowCount: 3,
            },
            {
                bookId: 'bookId',
                borrowCount: 6,
            },
            {
                bookId: 'bookId',
                borrowCount: 2,
            },
            {
                bookId: 'bookId',
                borrowCount: 1,
            },
        ]
        class Queue {
            constructor(priority) {
                this._arr = []
                this.priority = priority
            }
            enqueue(o) {
                switch (this._arr.length) {
                    case 0:
                        this._arr.push(o)
                        break;
                    default:
                        let index = this._arr.findIndex(item => item[this.priority] < o[this.priority])
                        if (index > -1) {
                            this._arr.splice(index, 0, o)
                        } else {
                            this._arr.push(o)
                        }
                        break;
                }
            }
            dequeue() {
                return this._arr.shift()
            }
        }
        let findF = (arr, k) => {
            // queue 优先队列
            // map   数量对对象的映射
            // arr   只记录最多的

            let a = []
            let q = new Queue('borrowCount')
            arr.forEach(item => q.enqueue(item))
            let i = 0
            while (i < k && i < arr.length) {
                a.push(q.dequeue())
                i++
            }
            return a
        }
        // clog(findF(arr, 7))
        // clog(findF(arr, 3))
        // clog(findF(arr, 0))
        // clog(findF(arr, -1))


        let getSum = (arr) => {
            if (!arr.length) {return 0}
            let sum = arr[0]
            let max = arr[0]
            for(let i = 1; i < arr.length; i++) {
                // 决定当前元素是并入前面的子数组，还是重新开始
                sum = Math.max(sum + arr[i], arr[i])
                max = Math.max(sum, max)
                // max = Math.max(max, Math.max(sum + arr[i], arr[i]))
            }
            return max
        }
        getSum = (arr) => {
            if (!arr.length) {
                return []
            }
            let start = 0
            let end = start + 1
            let sum = arr[0]
            let max = arr[0]
            for(let i = 1; i < arr.length; i++) {
                if (sum + arr[i] < arr[i]) { // 非连续
                    sum = arr[i]
                    start = i
                    end = i + 1
                } else { // 连续
                    sum += arr[i]
                    if (max < sum) {
                        end = i + 1
                        max = sum
                    }
                }
            }
            return arr.slice(start, end)
            // return max
        }
        // clog(getSum([-2, 1, -3, 4, -1, 2, 1, -5, 4]))



        let f = (arr, sum) => {
            let r = 0
            let s = 0
            for (let i = 0; i < arr.length; i++) {
                for (let j = i; j < arr.length; j++) {
                    if (s + arr[j] <= sum) {
                        s += arr[j]
                    }
                    if (s === sum) {
                        r++
                        break;
                    }
                }
            }
            return r
        }
        // f([10, 5, 2, 1], 10)


        let res = []
        f = (arr, state = []) => {
            if (state.length === arr.length) {
                res.push([...state])
                return
            } else {
                arr.forEach(item => {
                    if (!state.includes(item)) {
                        state.push(item)
                        f(arr, state)
                        state.pop()
                    }
                })
            }
        }
        // clog(f([1,2,3]), res)


        // 子集和
        let t = []
        f = (arr, target, state = []) => {
            if (sum(state) === target) {
                let p =  state.reduce((r, c) => {
                    r *= c
                    return r
                }, 1)
                if (t.includes(p)) {} else {
                    t.push(p)
                    res.push([...state])
                }
                return
            } else {
                arr.forEach(item => {
                    let s = sum(state)
                    if (s < target) {
                        state.push(item)
                        f(arr, target, state)
                        state.pop()
                    }
                })
            }
        }
        // f([3,4,5], 9)
        // clog(res)


        f = (n, choices, state = [0]) => {
            if (state[state.length - 1] === n) {
                res.push([...state])
            } else {
                for(let item of choices) {
                    let t = state[state.length - 1] + item
                    if (t <= n) {
                        state.push(t)
                        f(n, choices, state)
                        state.pop()
                    // } else if (n < t) {
                        // ;
                    }
                }
            }
        }
        // f(4, [3])
        // clog(res)


        let map = new Map()
        map.set(1, 1)
        map.set(2, 2)
        f = (n) => {
            if (n <= 2) {
                let t = map.get(n)
                // clog(t, n, map)
                return t
            } else {
                let t = f(n - 2) + f(n - 1)
                map.set(n, t)
                return t
            }
        }
        // clog(f(6))


        f = (coins, amt) => {
            let t = 0
            let a = []
            while (t < amt) {
                for (let i = 0; i < coins.length; i++) {
                    if (coins[i] <= (amt - t)) {
                        t += coins[i]
                        a.push(coins[i])
                        break;
                    }
                }
            }
            return a.length || -1
        }
        // clog(f([5,1], 4))

        arr = []
        f = (coins, amt, state = []) => {
            if (sum(state) === amt) {
                let t = state.reduce((r, c) => {
                    return r *= c
                }, 1)
                if (!arr.includes(t)) {
                    arr.push(t)
                    res.push([...state])
                    return
                } else {
                    return
                }
            } else {
                for (let i = 0; i < coins.length; i++) {
                    state.push(coins[i])
                    if (sum(state) <= amt) {
                        f(coins, amt, state)
                    }  
                    state.pop()
                }
            }
        }
        // let deuniqe = (arr) => {
        //     let map = new Map()
        //     arr.forEach(item => {
        //         let obj = {}
        //         item.forEach(subItem => {
        //             if (obj[subItem] === undefined) {

        //             }
        //             subItem
        //         })
        //     })
        // }
        // clog(f([1,5,10], 18), res, arr)



        class Item {
            constructor(w, v) {
                this.weight = w
                this.value = v
                this.vw = v / w
            }
        }
        f = (w, v, c) => {
            let items = w.map((a, i) => new Item(a, v[i]))
            items.sort((a, b) => b.vw - a.vw)
            let resValue = 0
            let restW = c
            let res = []
            for (let item of items) {
                if (item.weight <= restW) {
                    res.push(item)
                    restW -= item.weight
                    if (!restW) {
                        break
                    }
                } else {
                    let wt = (item.weight - restW) / item.weight
                    let vt = item.value * wt / item.weight
                    res.push({
                        value: restW * item.vw,
                        weight: restW,
                        vw: item.vw,
                    })
                    break;
                }
            }
            return res
        }
        // clog(f([20, 40, 10, 30, 50], [120, 210, 50, 150, 240], 120))
        // clog(f([20, 40, 10, 30, 50], [120, 210, 50, 150, 240], 50))





        f = (arr) => {
            let res = []
            for (let i = 0; i < arr.length - 1; i++) {
                for (let j = i; j < arr.length; j++) {
                    let w = j - i
                    let h = Math.min(arr[i], arr[j])
                    let s = w * h
                    res.push(s)
                }
            }
            // return res
            return Math.max(...res)
        }
        // clog(f([3, 8, 5, 2, 7, 7, 3, 4]))


        f = (n) => {
            let m
            let res = []
            while(n > 10) {
                m = n % 10
                res.unshift(m)
                n = Math.floor(n / 10)
            }
            res.unshift(n)
            return res
        }
        // clog(f(23440))



        f = (a, b, c) => {
            let arr = [a, b, c].sort((a, b) => a - b)
            return arr
        }
        // clog(f(3,8,2))


        f = (a, b, c) => {
            return ((a + b + c) / 3).toFixed(3)
        }
        // clog(f(1,2,3))



        f = (n) => {
            let dp = new Array(n + 1)
            dp[0] = 0
            dp[1] = 1
            for (let i = 2; i <= n; i++) {
                dp[i] = dp[i - 1] * i
            }
            clog(dp)
            return dp.reduce((r, c) => {
                return r += c
            }, 0)
        }
        // clog(f(4))




        f = () => {
            let res = []
            for (let i = 123; i < 328; i++) {
                // i, 2 * i, 3 * i
                // if (3 * i < 999)
                let set = new Set()
                String(i).split('').forEach(item => {
                    set.add(item)
                })
                String(2 * i).split('').forEach(item => {
                    set.add(item)
                })
                String(3 * i).split('').forEach(item => {
                    set.add(item)
                })
                if (set.size === 9) {
                    res.push([i, 2 * i, 3 * i])
                }
            }
            return res
        }
        // clog(f())



        f = (n, k) => {
            let res = new Array(n + 1).fill(false)
            // 0 off 1 on
            let i = 1
            while (i <= k) {
                for (let j = i; j <= n; j+=j) {
                    res[j] = !res[j]
                }
                i++
            }
            clog(res)
            return res.map((item, index) => {
                if (item) {
                    return index
                }
            }).filter(item => item)
        }
        // clog(f(7, 3))



        f = (n) => {
            // 用2个dp表处理
            // 9 7 5 3 1
            let dpa = Array.from({length: n}, (item, index) => 2 * index + 1).reverse()
            let dpb = new Array(n).fill(0).map((item, index) => index)
            let res = []
            for (let i = 0; i < n; i++) {
                res.push(' '.repeat(dpb[i]) + '#'.repeat(dpa[i]))
            }
            return res
        }
        // clog(f(5))



        f = (n) => {
            if (n === 1) {
                return [[1]]
            } else {
                let i = 0, x = 0, y = 0
                let arr = Array.from({length: n}, () => Array.from({length: n}).fill(0))
                let rotate = 1
                while(i < n * n && rotate <= n / 2) {
                    x = rotate - 1
                    y = rotate - 1
                    while (x < n - rotate) {
                        arr[x][y] = ++i
                        x++
                    }
                    while (y < n - rotate) {
                        arr[x][y] = ++i
                        y++
                    }
                    while (x >= rotate) {
                        arr[x][y] = ++i
                        x--
                    }
                    while (y >= rotate) {
                        arr[x][y] = ++i
                        y--
                    }
                    rotate++
                }
                if (n % 2) {
                    arr[x+1][y+1] = n * n
                }
                return arr
            }
        }
        // clog(f(4))
        // clog(f(6))
        // clog(f(5))
        // clog(f(7))
        // clog(f(1))
        // clog(f(2))
        



        f = (n, m) => {
            if (n === 1 && m === 1) {
                return [[1]]
            } else {
                let i = 0, x = 0, y = 0, rotate = 1
                let rotateCount = Math.floor(Math.min(n, m) / 2)
                let big = Math.max(n, m)
                let arr = Array.from({length: n}, () => Array.from({length: m}, () => 0))
                while(i < n * m && rotate <= rotateCount) {
                    x = rotate - 1
                    y = rotate - 1
                    while (x < n - rotate) {
                        arr[x][y] = ++i
                        x++
                    }
                    while (y < m - rotate) {
                        arr[x][y] = ++i
                        y++
                    }
                    while (x >= rotate) {
                        arr[x][y] = ++i
                        x--
                    }
                    while (y >= rotate) {
                        arr[x][y] = ++i
                        y--
                    }
                    rotate++
                }
                if (n === 1 || m === 1) {
                } else {
                    x++
                    y++
                }
                if (n > m) {
                    let k = 0
                    while (k < big - (rotate - 1) * 2) {
                        arr[x][y] = ++i
                        x++
                        k++
                    }
                } else if (n < m) {
                    let k = 0
                    while (k < big - (rotate - 1) * 2) {
                        arr[x][y] = ++i
                        y++
                        k++
                    }
                }
                return arr
            }
        }
        // clog(f(2, 3))
        // clog(f(4, 4))
        // clog(f(5, 5))
        // clog(f(5, 7))
        // clog(f(1, 1))
        // clog(f(8, 3))
        // clog(f(1, 5))
        // clog(f(8, 1))



        f = (s) => {
            let t = s.split('').reverse().join('')
            clog(t)
            return t === s
        }
        // clog(f('str'))
        // clog(f('sts'))
        // clog(f('stts'))




        f = (s) => {
            let arr = s.split('')
            let res = true
            if (arr.length % 2) {
                arr.splice(Math.floor(arr.length / 2), 1)
            }
            for (let i = 0; i < Math.floor(arr.length / 2); i++) {
                if (arr[i] !== arr[arr.length - 1 - i]) {
                    res = false
                    break;
                }
            }
            return res
        }
        // clog(f('str'))
        // clog(f('sts'))
        // clog(f('stts'))




        f = (n) => {
            let i = 1 // 几位数
            let t = n
            while (t > 10) {
                t = t / 10
                i++
            }
            let res = 0
            for (let p = n - (i * 9); p < n;) {
                let pOrigin = p
                let sumNumber = 0
                while (p > 1) {
                    sumNumber += Math.floor(p % 10)
                    p /= 10
                }
                p = pOrigin
                if (p + sumNumber === n) {
                    res = p
                    break;
                } else {
                    p++
                }
            }
            return res
        }
        // clog(f(216))
        // clog(f(2005))
        // clog(f(121))



        f = (...arr) => {
            let res = []
            let diff = Number.MAX_SAFE_INTEGER
            for (let i = 0; i < arr.length - 1; i++) {
                for (let j = i+1; j < arr.length; j++) {
                    let t = Math.abs(arr[i] - arr[j])
                    if (diff > t) {
                        diff = t
                        res = [arr[i], arr[j]]
                    }
                }
            }
            return res
        }
        // clog(f(1,10,8,5,6,0,9))


        f = (s) => {
            let dp = Array.from({length: s.length}, () => 0)
            if (s.charAt(0) === 'O') {
                dp[0] = 1
            } else {
                dp[0] = 0
            }
            for (let i = 1; i < s.length; i++) {
                if (s.charAt(i) === 'O') {
                    dp[i] = dp[i - 1] + 1
                } else {
                    dp[i] = 0
                }
            }
            return dp.reduce((r, c) => r += c, 0)
        }
        // clog(f('OOXXOXXOOO'))


        
        map = new Map([
            ['C', 12.01],
            ['H', 1.008],
            ['O', 16.00],
            ['N', 14.01],
            // ...
        ])
        f = (s) => {
            let reg = /[A-Z]\d*/g
            let arr = s.match(reg)
            let obj = {}
            arr.forEach(item => {
                let k = item.slice(0, 1)
                let n = Number(item.slice(1)) || 1
                if (Object.keys(obj).includes(k)) {
                    obj[k] += n
                } else {
                    obj[k] = n
                }                
            })
            return Object.entries(obj) // [[k, v], ...]
            .reduce((r, [k, v]) => {
                r += map.get(k) * v
                return r
            }, 0)
        }
        // clog(f('C6H5OH'))



        f = (n) => {
            let s = ''
            for (let i = 1; i <= n; i++) {
                s += String(i)
            }
            let map = new Map([
                ['0', 0],
                ['1', 0],
                ['2', 0],
                ['3', 0],
                ['4', 0],
                ['5', 0],
                ['6', 0],
                ['7', 0],
                ['8', 0],
                ['9', 0],
            ])
            for (let i = 0; i < s.length; i++) {
                let t = map.get(s.charAt(i))
                map.set(s.charAt(i), ++t)
            }
            return map
        }
        // clog(f(100))



f = (...arr) => {
    let m = arr.length
    let n = arr[0].length
    let res = ''
    // m个长度为n的dna序列
    for (let j = 0; j < n; j++) {
        let o = new Map([
            ['A', 0],
            ['C', 0],
            ['G', 0],
            ['T', 0],
        ])
        for (let i = 0; i < m; i++) {
            let t = o.get(arr[i][j])
            o.set(arr[i][j], ++t)
        }
        let max = Math.max(o.get('A'), o.get('C'), o.get('G'), o.get('T'))
        if (o.get('A') === max) {
            res += 'A'
        } else if (o.get('C') === max) {
            res += 'C'
        } else if (o.get('G') === max) {
            res += 'G'
        } else if (o.get('T') === max) {
            res += 'T'
        }
    }
    return res
}
// clog(f('TATGAТАС',
// 'TAAGCТАС',
// 'AAAGATCC',
// 'TGAGATAС',
// 'TAAGATGT'))




f = (s, t) => {
    if (s.length < t.length) {
        let dp = [] // 保存第i个字母在t串中的下标
        for (let i = 0; i < s.length; i++) {
            for (let j = (dp[i - 1] || -1) + 1; j < t.length; j++) {
                if (s.charAt(i) === t.charAt(j)) {
                    dp[i] = j
                    break
                }
            }
        }
        return dp.length === s.length
    } else {
        return false
    }
}
// clog(f('bce', 'abcde'))




// for (let i = 0; ;i++) {
//     debugger
//     clog(i)
// }
// 不停
// 死循环





f = (n, k, m) => {
    let arr = []
    for (let i = 1; i <= n; i++) {
        arr.push(i)
    }
    let i = 0
    let j = n - 1
    let res = []
    while (arr.length) {
        i += k
        let _i = i % arr.length
        j -= m
        while (j < 0) {
            j += arr.length
        }
        let _j = j % arr.length
        if (_i === _j) {
            res.push(...arr.splice(_i, 1))
        } else {
            res.push(...arr.splice(_i, 1))
            if (_i < _j) {
                _j--
            }
            res.push(...arr.splice(_j, 1))
        }
    }
    return res
}
// clog(f(10, 4, 3))




arr = []
let init = (r, c) => {
    arr = Array.from({length: r}, () => Array.from({length: c}, () => 0))
    let t = 0
    for (let i = 0; i < r; i++) {
        for (let j = 0; j < c; j++) {
            arr[i][j] = ++t
        }
    }
}
// clog(init(3, 5), arr)





arr = [
    [['H', 'V'], ['V'], ['H'], ['V']],
    [['H'], ['H', 'V'], ['H', 'V'], ['V']],
    [[], ['H', 'V'], [], ['V']],
    [[], ['H'], ['H'], []],
]
f = (n, state) => {
    let res = []
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            for (let k = Math.max(i, j) + 1; k < n; k++) { // 延长到k
                let boolArr = []
                // 上
                let t = j
                let pointArr = []
                while (t < k) {
                    pointArr.push(arr[i][t])
                    t++
                }
                if (pointArr.every(p => p.includes('H'))) {
                    boolArr.push(true)
                } else {
                    boolArr.push(false)
                }
                // 下
                t = j
                pointArr = []
                while (t < k) {
                    pointArr.push(arr[k][t])
                    t++
                }
                if (pointArr.every(p => p.includes('H'))) {
                    boolArr.push(true)
                } else {
                    boolArr.push(false)
                }
                // 左
                t = i
                pointArr = []
                while (t < k) {
                    pointArr.push(arr[t][j])
                    t++
                }
                if (pointArr.every(p => p.includes('V'))) {
                    boolArr.push(true)
                } else {
                    boolArr.push(false)
                }
                // 右
                t = i
                pointArr = []
                while (t < k) {
                    pointArr.push(arr[t][k])
                    t++
                }
                if (pointArr.every(p => p.includes('V'))) {
                    boolArr.push(true)
                } else {
                    boolArr.push(false)
                }
                // 总
                if (boolArr.every(item => item)) {
                    res.push([[i, j], k])
                }
            }
        }
    }
    return res
}
// clog(f(4))





f = (arr = [
    // [a, b, c]
]) => {
    // 阈值设为 8 * 60min
    let dp = Array.from({length: arr.length}, () => []) // 0 清醒   1 睡眠
    let i = 1
    for (let j = 0; j < arr.length; j++) {
        let tArr = []
        let t = 0
        while (t < arr[j][0]) {
            tArr.push(0)
            t++
        }
        t = 0
        while (t < arr[j][1]) {
            tArr.push(1)
            t++
        }
        dp[j] = tArr.slice(arr[j][2] - 1)
    }
    let j = 0
    let tArr = []
    while (j < dp.length) {
        tArr.push(dp[j].length)
        j++
    }
    i = Math.min(...tArr)
    while (i < 8 * 60 + 1) {
        let k = 0
        while (k < arr.length) {
            let length = dp[k].length
            if (length <= i) {
                switch (dp[k][length - 1]) {
                    case 0: // 要睡觉
                        let activeCount = 0
                        let sleepCount = 0
                        for (let j = 0; j < arr.length; j++) {
                            switch (dp[j][i - 1]) {
                                case 0:
                                    activeCount++
                                    break;
                                case 1:
                                    sleepCount++
                                    break
                            }
                        }
                        if (sleepCount > activeCount) {
                            dp[k].push(...Array.from({length: arr[k][1]}, () => 1))
                        } else {
                            dp[k].push(...Array.from({length: arr[k][0]}, () => 0))
                        }
                        break;
                    case 1: // 要清醒
                        dp[k].push(...(Array.from({length: arr[k][0]}, () => 0)))
                        break;
                }
            }
            k++
        }
        let sleepCount = 0
        for (let j = 0; j < dp.length; j++) {
            switch(dp[j][dp[j].length - 1]) {
                case 1:
                    sleepCount++
                    break;
            }
        }
        if (!sleepCount) {
            return i
        }
        i++ // 可以取最短的dp[i]
    }
    return -1
}
// clog(f([[2,4,1], [1,5,2], [1,4,3]]))




f = (str) => {
    let reg = /\b[a-zA-Z]+\b/g
    let arr = str.match(reg)
    let set = new Set(arr)
    return [...set].sort((a, b) => {
        a = a.toUpperCase()
        b = b.toUpperCase()
        let r = 0
        for (let i = 0; i < Math.min(a.length, b.length); i++) {
            r = a.charCodeAt(i) - b.charCodeAt(i)
            if (r !== 0) {
                break
            }
        }
        if (r === 0 && a.length !== b.length) {
            r = a.length - b.length
        }
        return r
    })
}
// clog(f('Two blondes were going to Disneyland when they came to a fork in the road. The sign read: "Disneyland Left."'))





f = (n) => {
    let dp = []
    let i = 1
    while (dp.length < n) {
        if (!(i % 2) || !(i % 3) || !(i % 5)) {
            dp.push(i)
        }
        i++
    }
    clog('dp', dp)
    return dp[n - 1]
}
// clog(f(1500))



f = (arr) => {
    // 最长文件名的长度
    // 每m个文件名就换行
    // let maxLengthFileName = ''
    // let fileNameArr = arr.map(item => item.length)
    let m = 0
    let maxCol = 60 // 题目中没有。书中的示例代码中有。
    arr.forEach(item => {
        m = Math.max(m, item.length)
    })
    let col, row
    col = Math.floor((maxCol - m) / (m + 2))
    row = Math.ceil(arr.length / col)
    let res = ''
    for (let i = 0; i < row; i++) {
        for (let j = 0; j < col; j++) {
            let t = arr[i + row * j]
            if (t) {
                t += ' '.repeat(m - t.length)
                if (j === col - 1) {
                    res += t + '\n'
                } else {
                    res += t + '  '
                }
            }
        }
    }
    return res
}
// clog(f('Alice Chris Jan Marsha Ruben Bobby Cindy Jody Mike Shirley Buffy Danny Keith Mr.French Sissy Carol Greg Lori Peter'.split(' ')))




f = (
    arr // 一行一个元素
) => {
    // 少了洗数据
    let wordArr = arr.map(item => {
        return item.split(' ')
    })
    let rowMaxLength = Math.max(...wordArr.map(item => item.length))
    let dp = Array.from({length: arr.length}, () => [])
    for (let i = 0; i < rowMaxLength; i++) {
        let tArr = []
        for (let j = 0; j < arr.length; j++) {
            if (wordArr[j][i]) {
                tArr.push(wordArr[j][i])
            }
        }
        // 这列单词的最大长度
        let wordMaxLength =  Math.max(...tArr.map(item => item.length))
        for (let j = 0; j < arr.length; j++) {
            if (wordArr[j][i]) {
                dp[j].push(wordArr[j][i] + ' '.repeat(wordMaxLength - wordArr[j][i].length))
            } else {
                dp[j].push(' '.repeat(wordMaxLength))
            }
        }
    }
    clog('dp', dp)
    let res = ''
    for (let i = 0; i < dp.length; i++) {
        res += dp[i].join(' ') + '\n'
    }
    return res
}
// clog(f(['start: integer: // begins here', 
// 'stop: integer; // ends here', 
// 's: string;', 
// 'c: char; // temp']))




f = (arr, safe = 0, p) => {
    // 0
    // loop
    // 1000
    let pArr = arr.map(item => item)
    for (let i = 0; i < 1000; i++) {
        let t = []
        for (let j = 0; j < arr.length - 1; j++) {
            t.push(Math.abs(arr[j] - arr[j + 1]))
        }
        t.push(Math.abs(arr[arr.length - 1] - arr[0]))
        clog(t)
        if (t.every(item => item === 0)) {
            return 0
        }
        if (t.every((item, index) => item === pArr[index])) {
            return 'loop'
        }
        arr = t
    }
    return 1000
}
// clog(f([8, 11, 2, 7]))




f = (n) => {
    let arr = []
    for (let i = 1; i < n + 1; i++) {
        arr.push(i)
    }
    while (arr.length) {
        let p = arr.shift()
        let t = arr.shift()
        if (t) {
            arr.push(t)
        }
    }
}
// f(20)




f = (arr) => {
    // 按x正序排列
    // 奇数时找到中位点
    // 偶数时找到2个中位点之间的点
    arr.sort((a, b) => (a.x - b.x))
    let x
    if (arr.length % 2) {
        let t = Math.floor(arr.length / 2)
        x = arr[t].x
    } else {
        let t = Math.floor(arr.length / 2)
        x = (arr[t].x + arr[t - 1].x) / 2
    }
    // 判断是否对称
    for (let i = 0; i < arr.length / 2; i++) {
        if (
            Math.abs(arr[i].x - x) !== Math.abs(arr[arr.length - 1 - i].x - x)
            || arr[i].y !== arr[arr.length - 1 - i].y
        ) {
            return false
        }
    }
    return true
}
// clog(f([{x: -2, y: 5},
//     {x: 0, y: 0},
//     {x: 2, y: 3},
//     {x: 4, y: 0},
//     {x: 6, y: 5},
// ]))
// clog(f([
//     {x: 0, y: 4},
//     {x: 0, y: 0},
//     {x: 2, y: 3},
//     {x: 4, y: 0},
// ]))





f = (map0, map1) => {
    let res = ''
    let arrOld = Array.from(map0.keys())
    let arrNew = Array.from(map1.keys())
    let addArr = []
    let modifyArr = []
    let deleteArr = []
    for (let i = 0; i < arrOld.length; i++) {
        // 从旧到新
        if (arrNew.includes(arrOld[i])) { // 仍存在
            // 是否修改
            if (map1.get(arrOld[i]) === map0.get(arrOld[i])) {
                // null
            } else {
                modifyArr.push(arrOld[i])
            }
        } else { // 不存在，即已删除
            deleteArr.push(arrOld[i])
        }
    }
    for (let i = 0; i < arrNew.length; i++) {
        // 从新到旧
        if (!arrOld.includes(arrNew[i])) { // 旧的不包含，即增加
            addArr.push(arrNew[i])
        }
    }
    if (addArr.length) {
        res += '+'
        res += addArr.join(',')
        res += ';'
    }
    if (deleteArr.length) {
        res += '-'
        res += deleteArr.join(',')
        res += ';'
    }
    if (modifyArr.length) {
        res += '*'
        res += modifyArr.join(',')
        res += ';'
    }
    return res
}
// clog(f(new Map([
//     ['a', 3],
//     ['b', 4],
//     ['c', 10],
//     ['f', 6],
// ]), new Map([
//     ['a', 3],
//     ['c', 5],
//     ['d', 10],
//     ['ee', 4],
// ])))





f = (n) => {
    let map = new Map([
        [0, 1],
        [1, 1],
    ])
    let getFib = (n) => {
        if ([0, 1].includes(n)) {
            return map.get(n)
        } else {
            if (map.get(n)) {
                return map.get(n)
            } else {
                let t = getFib(n - 1) + getFib(n - 2)
                map.set(n, t)
                return t
            }
        }
    }
    let i = 0
    let c = String(getFib(i))
    while (!c.startsWith(String(n))) {
        i++
        clog(i)
        c = String(getFib(i))
    }
    return Number(c)
}
// clog(f(12))



f = () => {
    // let arr = [1,2,3]
    let arr = []
    let fn = (i, opF, p = undefined) => {
        if (i < arr.length) {
            return Promise.resolve(opF(arr[i])).then(res => {
                i++
                return fn(i, opF, res)
            })
        } else {
            return Promise.resolve(p)
        }
    }
    return fn(0, clog)
}
// f().then(r => {
//     clog(r)
// })





f = (arr, opFn) => {
  let _f = (i, opFn, p) => {
    if (i < arr.length) {
      return Promise.resolve(opFn(arr[i])).then((res) => {
        i++
        return _f(i, opFn, res)
      })
    } else {
      return Promise.resolve(p)
    }
  }
  return _f(0, opFn)
}
// clog(f([1,2,2,3], clog))




f = () => {
    let arr = [1,2,3]
    arr.splice(-2, 0, 6)
    clog(arr)
}
// f()





f = (arr) => {
    return arr.map(item => {
        let lineArr = item.split('')
        let sucessArr = []
        let p = 0    
        lineArr.forEach(item => {
            switch (item) {
                case '[':
                    p = 0
                    break;
                case ']':
                    p = sucessArr.length
                    break;
                default:
                    sucessArr.splice(p, 0, item)
                    p++
                    break;
            }
        })
        return sucessArr.join('')
    })
}
// clog(f(['This is_a [Beiju]_text', '[[]] [] [] Happy_Birthday_to_Tsinghua_University']))





f = (n, commandList) => {
    let arr = []
    for (let i = 0; i < n; i++) {
        arr.push(i + 1)
    }
    commandList.forEach(command => {
        let commandArr = command.split(' ').map(Number)
        let xIndex, yIndex
        xIndex = arr.findIndex(item => item === commandArr[1])
        yIndex = arr.findIndex(item => item === commandArr[2])
        switch (commandArr[0]) {
            case 1:
                if (xIndex + 1 === yIndex) {
                    // null
                } else {
                    arr.splice(xIndex, 1)
                    let newYIndex = xIndex < yIndex ? yIndex - 1 : yIndex
                    arr.splice(newYIndex, 0, commandArr[1])
                }
                // clog(arr)
                break;
            case 2:
                // xIndex = arr.findIndex(item => item === commandArr[1])
                // yIndex = arr.findIndex(item => item === commandArr[2])
                if (yIndex + 1 === xIndex) {} else {
                    arr.splice(xIndex, 1)
                    arr.splice(xIndex < yIndex ? yIndex - 1 : yIndex, 0, commandArr[1])
                }
                break;
            case 3:
                [arr[xIndex], arr[yIndex]] = [arr[yIndex], arr[xIndex]]
                break;
            case 4:
                arr.reverse()
                break;
        }
    })
    return arr
}
// clog(f(6, ['1 1 4']))




f = (i, d) => {
    // 创建一棵树。
    // 节点：{
    //     left: node,
    //     value: {
    //         count: number,
    //         toggle: boolean, // true 开 false 关
    //     },
    //     right: node,
    // }
    let createNode = (v) => {
        return {
            left: null,
            value: v,
            right: null,
        }
    }
    class Tree {
        constructor() {
            this.root = null
        }
        mount(node, v1, v2) {
            node.left = v1
            node.right = v2
        }
    }
    let tree = new Tree()
    let nodeCount = 0
    for (let j = 0; j < d; j++) {
        nodeCount += Math.pow(2, j)
    }
    tree.root = createNode({
        count: 1,
        toggle: false,
    })
    let tArr = [tree.root] // 要挂载子节点的数组
    let cur = 1
    while (cur < nodeCount) {
        let node = tArr.shift()
        let leftNode = createNode({
            count: ++cur,
            toggle: false,
        })
        let rightNode = createNode({
            count: ++cur,
            toggle: false,
        })
        tArr.push(leftNode)
        tArr.push(rightNode)
        tree.mount(node, leftNode, rightNode)
    }
    // 放球
    let _f = (node, n) => {
        if (!node) {
            return n
        } else {
            if (node.value.toggle) { // 如果该结点上的开关关闭,则往左走,否则往右走
                node.value.toggle = !node.value.toggle
                return _f(node.right, node.value.count)
            } else {
                node.value.toggle = !node.value.toggle
                return _f(node.left, node.value.count)
            }
        }
    }
    let dp = []
    for (let j = 0; j < i; j++) {
        dp.push(_f(tree.root))
    }
    return dp
}
// clog(f(2, 4))





f = (arr
    // [
    //     [wl, dl, wr, dr],
    // ]
) => {
    let createNode = (w, d) => {
        return {
            left: null,
            right: null,
            value: {
                d,
                w,
            }
        }
    }
    class Tree {
        constructor() {
            this.root = null
        }
        mount(parentNode, branch, w, d) {
            let node = createNode(w, d)
            switch (branch) {
                case 'left': 
                    this.mountLeft(parentNode, node)
                    break;
                case 'right':
                    this.mountRight(parentNode, node)
                    break;
            }
        }
        mountLeft(parentNode, node) {
            parentNode.left = node
        }
        mountRight(parentNode, node) {
            parentNode.right = node
        }
    }
    let tree = new Tree()
    // 创建树
    tree.root = {
        left: null,
        right: null,
        value: null,
    }
    // 挂节点
    let tArr = [tree.root]
    while (tArr.length) {
        let tNode = tArr.shift()
        let arrItem = arr.shift()
        tree.mount(tNode, 'left', arrItem[0], arrItem[1])
        tree.mount(tNode, 'right', arrItem[2], arrItem[3])
        if (arrItem[2] === 0) {
            tArr.unshift(tNode.right)
        }
        if (arrItem[0] === 0) {
            tArr.unshift(tNode.left)
        }
    }
    // 算w
    let _f = (node) => {
        if (!node) {
            return
        } else {
            if (node.value.w) {
                return node.value.w
            } else {
                return node.value.w = _f(node.left) + _f(node.right)
            }
        }
    }
    _f(tree.root.left)
    _f(tree.root.right)
    clog(tree)
    // 判断是否平衡 wl * dl = wr * dr
    let res = []
    let isBalance = (node) => {
        if (node.left && node.right) {
            clog(node.left.value.w * node.left.value.d, node.right.value.w * node.right.value.d)
            if ((node.left.value.w * node.left.value.d) === (node.right.value.d * node.right.value.w)) {
            } else [
                res.push(node)
            ]
            isBalance(node.left)
            isBalance(node.right)
        }
    }
    isBalance(tree.root)
    // 收集所有不平衡的节点
    return res
}
// clog(f([
//     [0, 2, 0, 4],
//     [0, 3, 0, 1],
//     [1, 1, 1, 1],
//     [2, 4, 4, 2],
//     [1, 6, 3, 2],
// ]))




f = (arr) => {
    let tagArr = Array.from({length: arr.length}, () => Array.from({length: arr[0].length}, () => 0))
    // 0 未探索 1 可访问 2 已使用
    let queueArr = []
    // 八连块
    let res = []
    let bfs = (i, j, p) => {
        queueArr.push([i, j])
        while (queueArr.length) {
            let [r, c] = queueArr.shift()
            tagArr[r][c] = 2
            p.push([r, c])
            // 右
            if (
                arr[r] && arr[r][c + 1] // 存在
                && arr[r][c + 1] === '@' // 是@
                && tagArr[r][c + 1] === 0 // 未搜索
            ) {
                queueArr.push([r, c + 1])
                tagArr[r][c + 1] = 1
            }
            // 右下
            if (
                arr[r + 1] && arr[r + 1][c + 1] // 存在
                && arr[r + 1][c + 1] === '@' // 是@
                && tagArr[r + 1][c + 1] === 0 // 未搜索
            ) {
                queueArr.push([r + 1, c + 1])
                tagArr[r + 1][c + 1] = 1
            }
            // 下
            if (
                arr[r + 1] && arr[r + 1][c] // 存在
                && arr[r + 1][c] === '@' // 是@
                && tagArr[r + 1][c] === 0 // 未搜索
            ) {
                queueArr.push([r + 1, c])
                tagArr[r + 1][c] = 1
            }
            // 左下
            if (
                arr[r - 1] && arr[r - 1][c - 1] // 存在
                && arr[r - 1][c - 1] === '@' // 是@
                && tagArr[r - 1][c - 1] === 0 // 未搜索
            ) {
                queueArr.push([r - 1, c - 1])
                tagArr[r - 1][c - 1] = 1
            }
            // 左
            if (
                arr[r - 1] && arr[r - 1][c] // 存在
                && arr[r - 1][c] === '@' // 是@
                && tagArr[r - 1][c] === 0 // 未搜索
            ) {
                queueArr.push([r - 1, c])
                tagArr[r - 1][c] = 1
            }
            // 左上
            if (
                arr[r - 1] && arr[r - 1][c - 1] // 存在
                && arr[r - 1][c - 1] === '@' // 是@
                && tagArr[r - 1][c - 1] === 0 // 未搜索
            ) {
                queueArr.push([r - 1, c - 1])
                tagArr[r - 1][c - 1] = 1
            }
            // 上
            if (
                arr[r - 1] && arr[r - 1][c] // 存在
                && arr[r - 1][c] === '@' // 是@
                && tagArr[r - 1][c] === 0 // 未搜索
            ) {
                queueArr.push([r - 1, c])
                tagArr[r - 1][c] = 1
            }
            // 右上
            if (
                arr[r - 1] && arr[r - 1][c + 1] // 存在
                && arr[r - 1][c + 1] === '@' // 是@
                && tagArr[r - 1][c + 1] === 0 // 未搜索
            ) {
                queueArr.push([r - 1, c + 1])
                tagArr[r - 1][c - 1] = 1
            }
        }
    }
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr[i].length; j++) {
            if (!tagArr[i][j] && arr[i][j] === '@') {
                res.push([])
                bfs(i, j, res[res.length - 1])
            }
        }
    }
    return res
}
// clog(f([
//     ['*', '*', '*', '*', '@'],
//     ['*', '@', '@', '*', '@'],
//     ['*', '@', '*', '*', '@'],
//     ['@', '@', '@', '*', '@'],
//     ['@', '@', '*', '*', '@'],
// ]))




f = (n) => {
    let r = ''
    if (n % 100) {
        if (n % 4) {
            r = 'no'
        } else {
            r = 'yes'
        }
    } else {
        if (n % 400) {
            r = 'no'
        } else {
            r = 'yes'
        }
    }
    return r
}
// clog(f(2026))




f = (n, m, obstacleList, start, end) => {
    let dp = Array.from({length: n}, () => Array.from({length: m}, () => Number.MAX_SAFE_INTEGER))
    // dp[i]表示到第i个格子需要的最短距离
    let tag = Array.from({length: n}, () => Array.from({length: m}, () => 0))
    // 0 未探索 1 可访问 2 已使用
    // clog(dp)
    obstacleList.forEach(item => {
        dp[item[0]][item[1]] = -1 // 用-1表示障碍物
    })
    dp[start[0]][start[1]] = 1 // 初始 起点记为1

    // tag[start[0]][start[1]] = 1
    // let queue = [[start[0], start[1]]]
    
    tag[start[0]][start[1]] = 2
    let queue = []
    if (dp[start[0]][start[1] + 1]
        && dp[start[0]][start[1] + 1] !== -1
    ) {
        tag[start[0]][start[1] + 1] = 1
        queue.push([start[0], start[1] + 1])
    }
    if (dp[start[0] + 1] && dp[start[0] + 1][start[1]]
        && dp[start[0] + 1][start[1]] !== -1
    ) {
        tag[start[0] + 1][start[1]] = 1
        queue.push([start[0] + 1, start[1]])
    }
    if (dp[start[0]][start[1] - 1]
        && dp[start[0]][start[1] - 1] !== -1
    ) {
        tag[start[0]][start[1] - 1] = 1
        queue.push([start[0], start[1] - 1])
    }
    if (dp[start[0] - 1] && dp[start[0] - 1][start[1]]
        && dp[start[0] - 1][start[1]] !== -1
    ) {
        tag[start[0] - 1][start[1]] = 1
        queue.push([start[0] - 1, start[1]])
    }
    
    while(queue.length) {
        let t = queue.shift()
        let [i, j]  = t
        // 处理当前值
        // 周围最小值+1
        dp[i][j] = Math.min(
            dp[i - 1] && dp[i - 1][j] > 0 ? dp[i - 1][j] : Number.MAX_SAFE_INTEGER,
            dp[i][j + 1] > 0 ? dp[i][j + 1] : Number.MAX_SAFE_INTEGER,
            dp[i + 1] && dp[i + 1][j] > 0 ? dp[i + 1][j] : Number.MAX_SAFE_INTEGER,
            dp[i][j - 1] > 0 ? dp[i][j - 1] : Number.MAX_SAFE_INTEGER,
        ) + 1
        tag[i][j] = 2
        // 相邻点入队列
        // 上
        if (dp[i - 1] && dp[i - 1][j] // 存在
            && ![-1].includes(dp[i - 1][j]) // 不是障碍物
            && tag[i - 1][j] === 0// 未搜索
        ) {
            tag[i - 1][j] = 1
            queue.push([i - 1, j])
        }
        // 右
        if (dp[i] && dp[i][j + 1] // 存在
            && ![-1].includes(dp[i][j + 1]) // 不是障碍物
            && tag[i][j + 1] === 0// 未搜索
        ) {
            tag[i][j + 1] = 1
            queue.push([i, j + 1])
        }
        // 下
        if (dp[i + 1] && dp[i + 1][j] // 存在
            && ![-1].includes(dp[i + 1][j]) // 不是障碍物
            && tag[i + 1][j] === 0// 未搜索
        ) {
            tag[i + 1][j] = 1
            queue.push([i + 1, j])
        }
        // 左
        if (dp[i] && dp[i][j - 1] // 存在
            && ![-1].includes(dp[i][j - 1]) // 不是障碍物
            && tag[i][j - 1] === 0// 未搜索
        ) {
            tag[i][j - 1] = 1
            queue.push([i, j - 1])
        }
    }
    clog(dp)
    return dp[end[0]][end[1]]
}




f = (n, m, obstacleList, start, end) => {
    let res = []
    let map = Array.from({length: n}, () => Array.from({length: m}, () => 
    // Number.MAX_SAFE_INTEGER))
    1))
    obstacleList.forEach(([i, j]) => {
        map[i][j] = -1
    })
    let tag = Array.from({length: n}, () => Array.from({length: m}, () => 0))
    tag[start[0]][start[1]] = 1
    clog(map)
    let fn = (p, state = []) => {
        let [i, j] = p
        tag[i][j] = 2
        state.push([i, j])
        if (state.length && state[state.length - 1][0] === end[0] && state[state.length - 1][1] === end[1]) {
            res.push([...state])
        }
        // 上
        if (map[i-1] && map[i-1][j] // 存在
            && tag[i-1][j] !== 2 // 不走已经走过的节点
            && map[i-1][j] !== -1 // 不是障碍物
        ) {
            fn([i-1, j], state)
        }
        // 右
        if (map[i][j+1] // 存在
            && tag[i][j+1] !== 2 // 
            && map[i][j+1] !== -1 // 不是障碍物
        ) {
            fn([i, j+1], state)
        }
        // 下
        if (map[i+1] && map[i+1][j] // 存在
            && tag[i+1][j] !== 2 // 
            && map[i+1][j] !== -1 // 不是障碍物
        ) {
            fn([i+1, j], state)
        }
        // 左
        if (map[i][j-1] // 存在
            && tag[i][j-1] !== 2 // 
            && map[i][j-1] !== -1
        ) {
            fn([i, j-1], state)
        }
        tag[i][j] = 1
        state.pop()
    }
    // fn(start)
    fn(start)
    return res
}
// clog(f(6, 5, [
//     [0, 2],
//     [1, 1],
//     [2, 1],
//     [3, 1],
//     [4, 3],
//     [2, 3],
//     [2, 4],
// ], [0, 0], [0, 4]))



class Chain {}
class GraphNode {
    constructor() {
    }
    is(node) {}
}
class GraphAdjMat {
    constructor(vertices, edges) {
        // 初始化邻接表、邻接矩阵、邻接map.
        this.vertices = [] // 所有点组成的数组
        // this.adjMat = [] // 邻接矩阵
        // this.adjArr = [] // 邻接表
        // this.adjChain = new Chain()
        this.adjMap = new Map() // 邻接map
        for (let v of vertices) {
            this.addVertex(v)
        }
        for (let e of edges) {
            this.addEdges(e[0], e[1])
        }
    }
    size() {
        return this.vertices.length
    }
    // 添加点
    addVertex(v) {
        this.vertices.push(v)
        // let tArr = Array.from({length: this.size()}, () => 0)
        // tArr[0] = v
        // this.adjMat.push(tArr)
        // this.adjMat.forEach(arr => arr.push(0))

        // this.adjArr.push(new Chain(v))
        
        this.adjMap.set(v, [])
    }
    // 添加边
    addEdge(v0, v1) {
        // 无向图
        if (this.adjMap.has(v0) && this.adjMap.has(v1) && !v0.is(v1)) {
            this.adjMap.get(v0).push(v1)
            this.adjMap.get(v1).push(v0)
        }
    }
    // 删除点
    removeEdge(v) {
        if (this.adjMat.has(v)) {
            this.adjMap.delete(v)
            this.adjMap.forEach((arr, key, map) => {
                let index = arr.findIndex(item => item.is(v))
                arr.splice(index, 1)
            })
        }
    }
    // 删除边
    removeVertex(v0, v1) {
        if (this.adjMap.has(v0) && this.adjMap.has(v1)) {
            let index = this.adjMap.get(v0).findIndex(v => v.is(v1))
            this.adjMap.get(v0).splice(index, 1)
            index = this.adjMap.get(v1).findIndex(v => v.is(v0))
            this.adjMap.get(v1).splice(index, 1)
        }
    }
    // 打印图
    print() {
        clog(this.vertices)
        this.adjMap.forEach((value) => {
            clog(value)
        })
    }
    // 是否邻接
    isAdj(v0, v1) {
        // 无向图需要判断1个方向
        if (this.adjMap.has(v0) && this.adjMap.has(v1)) {
            return this.adjMap.get(v0).some(v => v.is(v1))
        }
        // 有向图需要判断2个方向
    } 
    // 广度优先
    bfs(v, fn) {
        let queue = [v]
        let tag = new Map()
        // 不存在 未搜索
        // 1 可访问
        // 2 已处理
        tag.set(v, 1)
        while (queue.length) {
            let t = queue.shift()
            fn(t)
            tag.set(t, 2)
            this.adjMap.get(t).forEach(item => {
                if (tag.has(item)) {
                } else {
                    tag.set(item, 1)
                    queue.push(item)
                }
            })
        }
    }
    // 深度优先
    dfs(v, fn) {
        let tagMap = new Map()
        let f = (v, fn) => {
            fn(v)
            tagMap.set(v, 1)
            this.adjMap.get(v).forEach(itemV => {
                if (!this.map.has(itemV)) {
                    f(itemV, fn)
                }
            })
        }
        f(v, fn)
    }
}



f = (vertexList, edgeList) => {
    class Graph {}
    let graph = new Graph() // 有向无环图
    let aNode = {value: 'a'}
    let bNode = {value: 'b'}
    let cNode = {value: 'c'}
    let dNode = {value: 'd'}
    graph = {
        adjMap: new Map([
            [aNode, [bNode]],
            [dNode, [cNode, bNode]],
        ])
    }
    let res = []
    let fn = (v, state, extraChoise) => {
        if (v.value === 'b') {
            res.push([...state])
        } else {
            let choise = graph.adjMap.get(v)
            let allArr = [...choise, ...extraChoise]
            for (let v of allArr) {
                state.push(v)
                fn(v, state, allArr)
                state.pop()
            }
        }
    }
    let uniqueByKey = (arr, key) => {
        let set = new Set()
        return arr.filter(item => {
            if (set.has(item[key])) {
                return false
            } else {
                set.add(item[key])
                return true
            }
        })
    }
    let tagArr = []
    fn = (state, choise) => {
        if (state.length === 4 && state[state.length - 1].value === 'b') {
            let t = state.reduce((r, c) => {
                return r += c.value
            }, '')
            if (tagArr.includes(t)) {

            } else {
                tagArr.push(t)
                res.push([...state])
            }
        } else {
            if (state.find(item => item.value === 'b')) {

            } else {
                for (let v of choise) {
                    state.push(v)
                    let arr = choise.filter(item => item.value !== v.value)
                    arr.push(...(graph.adjMap.get(v) || []))
                    uniqueByKey(arr, 'value')
                    fn(state, arr)
                    state.pop()
                }
            }
        }
    }
    let startList = Array.from(graph.adjMap.keys())
    startList.forEach(v => {
        fn([], startList)
    })
    return res
}
// clog(f())




















    </script>
</body>
</html>