<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <!-- <link href="./pwa.js" as="script"> 不能正常工作 -->
    <!-- <script src="./pwa.js"></script> -->
    <!-- <script src="./watch.js" defer></script>
    <script src="./sw.js"></script>
    <script src="./test.js" preload></script> -->
    <!-- <script src="./test.js" async></script> -->
    <!-- <script src="./test.js" async ref="prefetch"></script> -->
    <!-- <link rel="preload" href="./sw.js" as="script"> -->
    <!-- <link rel="preload" href="./pwa.js" as="script"> -->
    <!-- <link rel="prefetch" href="./sw.js" as="script"> -->
  </head>
  <body>
    <script>
      const clog = console.log
      const j = (o) => {
        clog(JSON.parse(JSON.stringify(o)))
      }
      
      

  class BaseTree {
    constructor() {
        this.root = null;
    }
    createNode(v) {
        return {
            value: v,
            left: null,
            right: null,
        };
    }
    // 先父节点，再左节点，再右节点
    _preOrderTraverse(cb, node) {
        if (node) {
            cb(node.value);
            this._preOrderTraverse(cb, node.left);
            this._preOrderTraverse(cb, node.right);
        }
    }
    // 整体从左到右依次操作
    _inOrderTraverse(cb, node) {
        if (node) {
            this._inOrderTraverse(cb, node.left);
            cb(node.value);
            this._inOrderTraverse(cb, node.right);
        }
    }
    // 先左节点，再右节点，再父节点
    _postOrderTraverse(cb, node) {
        if (node) {
            this._postOrderTraverse(cb, node.left);
            this._postOrderTraverse(cb, node.right);
            cb(node.value);
        }
    }
    _findMinNode(node) {
        let cur = node;
        while (cur && cur.left) {
            cur = cur.left;
        }
        return cur;
    }
    _remove(node, value) {
        if (!node) {
            return null;
        }
        if (value < node.value) {
            node.left = this._remove(node.left, value);
            return node;
        }
        else if (value > node.value) {
            node.right = this._remove(node.right, value);
            return node;
        }
        else {
            // 有0个节点
            if (!node.left && !node.right) {
                node = null;
                return node;
            }
            // 有1个节点
            if (!node.left) {
                node = node.right;
                return node;
            }
            else if (!node.right) {
                node = node.left;
                return node;
            }
            // 有2个节点
            let t = this._findMinNode(node.right);
            node.value = t.value;
            node.right = this._remove(node.right, t.value);
            return node;
        }
    }
    heightNode(node) {
        return node
            ? Math.max(this.heightNode(node.left), this.heightNode(node.right)) + 1
            : -1;
    }
}
class BinarySearchTree extends BaseTree {
    constructor() {
        super();
    }
    insert(v) {
        let node = this.createNode(v);
        if (this.root) {
            this._insertNode(this.root, node);
        }
        else {
            this.root = node;
        }
    }
    _insertNode(node, newNode) {
        if (newNode.value < node.value) {
            if (!node.left) {
                node.left = newNode;
            }
            else {
                this._insertNode(node.left, newNode);
            }
        }
        else {
            if (!node.right) {
                node.right = newNode;
            }
            else {
                this._insertNode(node.right, newNode);
            }
        }
    }
    // 是否存在
    search(v) {
        let res = false;
        let cur = this.root;
        while (cur) {
            if (cur.value === v) {
                res = true;
                break;
            }
            if (v < cur.value) {
                cur = cur.left;
            }
            else {
                cur = cur.right;
            }
        }
        return res;
    }
    traverse(cb, order = 'inOrder') {
        switch (order) {
            case 'preOrder':
                this._inOrderTraverse(cb, this.root);
                break;
            case 'inOrder':
                this._inOrderTraverse(cb, this.root);
                break;
            case 'postOrder':
                this._postOrderTraverse(cb, this.root);
                break;
        }
    }
    min() {
        let cur = this.root;
        while (cur && cur.left) {
            cur = cur.left;
        }
        return cur.value;
    }
    max() {
        let cur = this.root;
        while (cur && cur.right) {
            cur = cur.right;
        }
        return cur.value;
    }
    remove(v) {
        this.root = this._remove(this.root, v);
    }
}

let tree = new BinarySearchTree()
tree.insert(3)
tree.insert(9)
tree.insert(20)
tree.insert(15)
tree.insert(7)
// tree.insert(8)
clog(tree)
let f = (node = null, deep = 0) => {
  if (!node) {
    return deep
  } else {
    if (!node.left && !node.right) {
      return deep
    } else if (node.left && !node.right) {
      deep++
      return f(node.left, deep)
    } else if (!node.left && node.right) {
      deep++
      return f(node.right, deep)
    } else {
      deep++
      return Math.min(f(node.left, deep), f(node.right, deep))
    }
  }
}
clog(f(tree.root))

let arr = []
class Queue {
  constructor () {
    this.items = []
    // this.size
  }
  size() {
    return this.items.length
  }
  enqueue(v) {
    return this.items.push(v)
  }
  dequeue() {
    return this.items.shift()
  }
}
let f2 = (node = null, deep = 0) => {
  if (!node) {
    return deep
  } else {
    let queue = new Queue()
    queue.enqueue(node)
    let len = queue.size()
    while (len) {
      let i = 0
      while (i < len) {
        let n = queue.dequeue()
        if (!n.left && !n.right) {
          return deep
        } else {
          n.left && queue.enqueue(n.left)
          n.right && queue.enqueue(n.right)
        }
        i++
      }
      deep++
      len = queue.size()
    }
  }

}


// clog(tree.root)
clog(f2(tree.root))




    </script>
  </body>
</html>
