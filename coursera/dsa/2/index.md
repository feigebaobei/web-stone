# no.2

## stack

10 -》 2  
减而治之、分而治之不能正常运行时，使用使用栈处理。

栈混洗：2 个栈之间多次执行 pop/push.  
排列情况 <= n!  
![](/coursera/dsa/2/stackSum.png)  
任意三个元素能否按某相对次序出现于混洗中，与其它元素无关。  
123 =》 312 是禁形。  
n 个括号组成的合法表达式，就是 n 个括号的栈混洗的过程。  
合法的括号匹配与合法的栈混洗之间存在一一对应关系。  
**邓老师的代码非常严谨**  
逆波兰表达式，可以不使用括号表示优化级。  
示例都是使用 0，1，2，3，4，……,9 的。经过计算后结果都是 2013.

```js
// 中缀 =》 rpn
```

## queue

# no.3 树

## overview

- 按层次关系分
- 树是特殊的图。连通无环图。
- 半线性。前驱惟一，后续不惟一。
-

## 概念

|                      |                    |                                  |
| -------------------- | ------------------ | -------------------------------- |
| vertex               | 节点               |                                  |
| edge                 | 边                 |                                  |
| 有根树               |                    |                                  |
| subTree              | 子树               |                                  |
| parent/child/sibling |                    | react 中把它们使用链表连接起来。 |
| degree               | 度                 | 该节点的孩子的数量               |
| 有序树               | 兄弟节点之间有顺序 |                                  |
| 连通性               |                    |                                  |
| 无环性               |                    | 任一节点与根节点之间存在唯一路径 |
| 通路                 |                    |                                  |
| 连通图               |                    |                                  |
| 无环图               | acyclic            |                                  |
| 无环连通图           |                    |                                  |
| 极小连通图           |                    |                                  |
| 极大无环图           |                    |                                  |
| 深度                 | 从根向叶           | 根节点深度为 0                   |
| 高度                 | 从叶向根           | 叶子点高度为 1                   |
| 空树                 | 根节点为 null      | 空树的高度是-1                   |
| title                |                    |                                  |
| title                |                    |                                  |

## 树的表示法

|              |                            |     |     |
| ------------ | -------------------------- | --- | --- |
| root         |                            |     |     |
| parent       |                            |     |     |
| firstChild   |                            |     |     |
| nextSibling  |                            |     |     |
| insert(i, e) | 把 e 作为第 i 个子节点插入 |     |     |
| remove(i)    |                            |     |     |
| traverse()   | 遍历                       |     |     |

```ts
interface node<T> {
  value: A
  parent: node<T>
  children: Chain<T>
}
```

### 长子+兄弟法

表示兄弟节点之间的关系。  
||||
|-|-|-|
|firstChild|长子||
|nextSibling|下一个兄弟||

```ts
interface node<T> {
  value: T
  parent: node<T>
  firstChild: node<T>
  nextSibling: node<T>
}
```

## 二叉树 binary tree

度 <= 2  
最多有（2^(h+1)-1）个节点  
可以用于表示“树”

按每层节点数量可分为：

- 单链表
- 满二叉树

特点：

- 宽度增长为指数式
- 高度增长为对数式  
  也就是宽度增长更快。

还原树：

- 可以根据“先序遍历”拓扑出树结构。别的遍历方式不行
- 当树是真二叉树时，使用使用 preorder/inorder/postorder 方式还原。
-

### 真二叉树 proper binary tree

每个节点的出度是 0 或 2.  
意义：只需要在思想上认为度总是 2，不需要在实际中真的兑现。

### 满二叉树 full binary tree

叶子节点在最后一层上的真二叉树。

### 完全二叉树 complete binary tree

非最后一层为满二叉树，最后一层从左到右分布。

- 叶子节点只能出现在最好二层。

### 遍历

- 先序
  - 先自上而下左侧节点，再自下而上右铡节点。
  - 使用栈保存右侧节点
  - 使用深度优先。
- 中序
  - 先自下而上左侧节点，再
- 后序
- 层次（广度优先）

中序处理方法与事件捕获阶段、当前阶段、冒泡阶段，很像。

## 多叉树

使用二叉树表示。  
二叉树的子节点是 left/right.长子兄弟表示法的子节点是 firstChild、兄弟是 nextSibling。都是二个叉。

## title

## title

## title

## title

# no.4

# no.5

# no.6
