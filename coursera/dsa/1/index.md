# no.1 week

## 需要的基础

- C++语言程序设计基础：类、继承、重载、重写、虚方法、模板
- 离散数学基础: 集合、偏序集、良序、数学归纳法、级数、递归、递推
- 概率基础: 随机分布、概率、伯努利实验、数学期望、期望值的线性律

# no.2 week

- 程序 != 算法
- 列循环 ~ 有穷性

## 计算 = 信息处理

- 对象：规律、技巧。
- 目标：高效、低耗。

借助某种工具，遵照一定规则，以明确而机械的形式进行。  
计算模型 = 计算机 = 信息处理工具

算法：
||||
|-|-|-|
|输入|待处理的信息（问题）||
|输出|经处理的信息（答案）||
|正确性|可以解决指定的问题||
|确定性|任一算法都可以描述为一个由基本操作组成的序列||
|可行性|每一基本操作都可实现，且在常数时间内完成||
|有穷性|对于任何输入，经过有穷次基本操作，都可以得到输出||

求直线 l 上过点 A 的垂线。

- 勾股法 3、4、5

三等分 AB 线段。

- 相似三角形

## 有穷性

hailStone

```js
let clog = console.log
let hailstone = (n) => {
  let length = 1
  while (1 < n) {
    if (n % 2) {
      // 奇
      n = n * 3 + 1
    } else {
      // 偶
      n = n / 2
    }
    length++
  }
  return length
}
clog(hailstone(42)) // 9
clog(hailstone(7)) // 17
clog(hailstone(27)) // 112
```

无法证明是否有穷。

## 好算法

- 正确
  - 简单的
  - 大规模的
  - 一般性的
  - 退化的
  - 任意合法的
- 健壮 能辨别不合法的输入并做适当处理，而不致非正常退出。
- 可读： 结构化 + 准确命名 + 注释 + ……
- 效率： 速度尽可能快，存储空间尽可能少。
  - algorithms + data structure = programs
  - (algorithms + data structures) \* efficiency = computation

## 计算模型

to measure is to know.  
if you can not measure it, you can not improve it.

## 算法分析

- 正确性
- 成本
  - **运行时间** + 所需存储空间
  -

T(n) 程序运行次数 时间复杂度。
为稳妥起见，取最环情况。

### 划分等价类

### 图灵机

### ram 模型

## 大 O 记号

当 n>>2 时。存在 c>0，有`T(n)<cf(n)`
在数学上一个好的标记超过一个新理论。 ———— 图灵

- 长远 考虑 dsa 处理更大问题上的潜力。
- 主流 考虑主要方面，不考虑次要方面。

**渐进分析** 当问题足够大时，考察成本的增长趋势。  
T(n) 基本操作次数  
S(s) 占用存储单元数 （通常不考虑）

O(fn) = T(n)

- 反映增长趋势。
- 常系数可忽略。
- 低次项可忽略。

## 大欧密喀 下界

当 n>>2 时。存在 c>0，有`T(n)>cf(n)`

## 西它

当 n>>2 时。存在 c1>c2>0，有`c1f(n)>T(n)>c2f(n)`

## 复杂度

- 有效解
  - 常数
    - 不含循环、分支转向、递归。
  - 对数
    - 底数不同
    - 交幂不同
    - 对数多项式
  - 多项式
  - 线性： 所有 O(n)类函数
  - 从 O(n)到 O(n^2)
  - 幂
- 难解
  - 指数

## 2-subset

## 增长速度

![增长速度](/coursera/dsa/1/v.png)

# no.3 week

# no.4 week

# no.5 week

# no.6 week

# no.7 week
