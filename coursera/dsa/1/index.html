<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>no&period;1 week</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="no1-week">no.1 week</h1>
<h2 id="需要的基础">需要的基础</h2>
<ul>
<li>C++语言程序设计基础：类、继承、重载、重写、虚方法、模板</li>
<li>离散数学基础: 集合、偏序集、良序、数学归纳法、级数、递归、递推</li>
<li>概率基础: 随机分布、概率、伯努利实验、数学期望、期望值的线性律</li>
</ul>
<h1 id="no2-week">no.2 week</h1>
<ul>
<li>程序 != 算法</li>
<li>列循环 ~ 有穷性</li>
</ul>
<h2 id="计算--信息处理">计算 = 信息处理</h2>
<ul>
<li>对象：规律、技巧。</li>
<li>目标：高效、低耗。</li>
</ul>
<p>借助某种工具，遵照一定规则，以明确而机械的形式进行。<br>
计算模型 = 计算机 = 信息处理工具</p>
<p>算法：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>输入</td>
<td>待处理的信息（问题）</td>
<td></td>
</tr>
<tr>
<td>输出</td>
<td>经处理的信息（答案）</td>
<td></td>
</tr>
<tr>
<td>正确性</td>
<td>可以解决指定的问题</td>
<td></td>
</tr>
<tr>
<td>确定性</td>
<td>任一算法都可以描述为一个由基本操作组成的序列</td>
<td></td>
</tr>
<tr>
<td>可行性</td>
<td>每一基本操作都可实现，且在常数时间内完成</td>
<td></td>
</tr>
<tr>
<td>有穷性</td>
<td>对于任何输入，经过有穷次基本操作，都可以得到输出</td>
<td></td>
</tr>
</tbody>
</table>
<p>求直线 l 上过点 A 的垂线。</p>
<ul>
<li>勾股法 3、4、5</li>
</ul>
<p>三等分 AB 线段。</p>
<ul>
<li>相似三角形</li>
</ul>
<h2 id="有穷性">有穷性</h2>
<p>hailStone</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> clog = <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">hailstone</span> = (<span class="hljs-params">n</span>) =&gt; {
  <span class="hljs-keyword">let</span> length = <span class="hljs-number">1</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span> &lt; n) {
    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) {
      <span class="hljs-comment">// 奇</span>
      n = n * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 偶</span>
      n = n / <span class="hljs-number">2</span>
    }
    length++
  }
  <span class="hljs-keyword">return</span> length
}
<span class="hljs-title function_">clog</span>(<span class="hljs-title function_">hailstone</span>(<span class="hljs-number">42</span>)) <span class="hljs-comment">// 9</span>
<span class="hljs-title function_">clog</span>(<span class="hljs-title function_">hailstone</span>(<span class="hljs-number">7</span>)) <span class="hljs-comment">// 17</span>
<span class="hljs-title function_">clog</span>(<span class="hljs-title function_">hailstone</span>(<span class="hljs-number">27</span>)) <span class="hljs-comment">// 112</span>
</code></pre>
<p>无法证明是否有穷。</p>
<h2 id="好算法">好算法</h2>
<ul>
<li>正确
<ul>
<li>简单的</li>
<li>大规模的</li>
<li>一般性的</li>
<li>退化的</li>
<li>任意合法的</li>
</ul>
</li>
<li>健壮 能辨别不合法的输入并做适当处理，而不致非正常退出。</li>
<li>可读： 结构化 + 准确命名 + 注释 + ……</li>
<li>效率： 速度尽可能快，存储空间尽可能少。
<ul>
<li>algorithms + data structure = programs</li>
<li>(algorithms + data structures) * efficiency = computation</li>
</ul>
</li>
</ul>
<h2 id="计算模型">计算模型</h2>
<p>to measure is to know.<br>
if you can not measure it, you can not improve it.</p>
<h2 id="算法分析">算法分析</h2>
<ul>
<li>正确性</li>
<li>成本
<ul>
<li><strong>运行时间</strong> + 所需存储空间</li>
<li></li>
</ul>
</li>
</ul>
<p>T(n) 程序运行次数 时间复杂度。
为稳妥起见，取最环情况。</p>
<h3 id="划分等价类">划分等价类</h3>
<h3 id="图灵机">图灵机</h3>
<h3 id="ram-模型">ram 模型</h3>
<h2 id="大-o-记号">大 O 记号</h2>
<p>当 n&gt;&gt;2 时。存在 c&gt;0，有<code>T(n)&lt;cf(n)</code>
在数学上一个好的标记超过一个新理论。 ———— 图灵</p>
<ul>
<li>长远 考虑 dsa 处理更大问题上的潜力。</li>
<li>主流 考虑主要方面，不考虑次要方面。</li>
</ul>
<p><strong>渐进分析</strong> 当问题足够大时，考察成本的增长趋势。<br>
T(n) 基本操作次数<br>
S(s) 占用存储单元数 （通常不考虑）</p>
<p>O(fn) = T(n)</p>
<ul>
<li>反映增长趋势。</li>
<li>常系数可忽略。</li>
<li>低次项可忽略。</li>
</ul>
<h2 id="大欧密喀-下界">大欧密喀 下界</h2>
<p>当 n&gt;&gt;2 时。存在 c&gt;0，有<code>T(n)&gt;cf(n)</code></p>
<h2 id="西它">西它</h2>
<p>当 n&gt;&gt;2 时。存在 c1&gt;c2&gt;0，有<code>c1f(n)&gt;T(n)&gt;c2f(n)</code></p>
<h2 id="复杂度">复杂度</h2>
<ul>
<li>有效解
<ul>
<li>常数
<ul>
<li>不含循环、分支转向、递归。</li>
</ul>
</li>
<li>对数
<ul>
<li>底数不同</li>
<li>交幂不同</li>
<li>对数多项式</li>
</ul>
</li>
<li>多项式</li>
<li>线性： 所有 O(n)类函数</li>
<li>从 O(n)到 O(n^2)</li>
<li>幂</li>
</ul>
</li>
<li>难解
<ul>
<li>指数</li>
</ul>
</li>
</ul>
<h2 id="2-subset">2-subset</h2>
<h2 id="增长速度">增长速度</h2>
<p><img src="file:////coursera/dsa/1/v.png" alt="增长速度"></p>
<h1 id="no3-week">no.3 week</h1>
<h2 id="算法分析">算法分析</h2>
<p>主要任务：</p>
<ul>
<li>正确性（不变性*单调性）</li>
<li>复杂度</li>
</ul>
<p>复杂度分析的主要方法：</p>
<ul>
<li>迭代：级数求和</li>
<li>递归：递归跟踪+递推方程</li>
<li>猜测+验证</li>
</ul>
<h2 id="级数-或-级数求和">级数 或 级数求和</h2>
<ul>
<li>算数级数：与末项平方同阶</li>
<li>幂方级数：比幂次高出一阶
<ul>
<li>T(n) = 1^2 + 2^2 + ... + n^2 = O(n^3)</li>
<li>T(n) = 1^3 + 2^3 + ... + n^3 = O(n^4)</li>
</ul>
</li>
<li>几何级数（a &gt; 1）：与末项同阶
<ul>
<li>等比数列 O(a^n)</li>
</ul>
</li>
<li>收敛级数
<ul>
<li>随着数量增加，趋于 O(1)</li>
</ul>
</li>
<li>可能未必收敛，然而长度有限
<ul>
<li>h(n) = 1 + 1/2 + 1/3 + ... + 1/n = O(logn) 调和级数</li>
<li>log1 + log2 + log3 + ... + logn = log(n!) = O(nlogn) 对数级数</li>
</ul>
</li>
</ul>
<h2 id="循环">循环</h2>
<pre><code>for (let i = 0; i &lt; n; i++)
for (let j = 0; j &lt; n; j++)
for (let j = 0; j &lt; i; j++)
for (let j = 0; j &lt; i; j+= 2)
三个都是O(n^2)
计算次数递减
</code></pre>
<h2 id="迭代与递归">迭代与递归</h2>
<p>迭代乃人工，递归方神通。<br>
迭代的效率&gt;递归。<br>
<strong>凡治众如治寡，分数是也</strong>
求 n 个数之和</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">arr, n</span>) =&gt; {
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    sum += arr[i]
  }
  <span class="hljs-keyword">return</span> sum
}
<span class="hljs-comment">// 时间复杂度 O(n)</span>
<span class="hljs-comment">// 空间复杂度 O(2) ： sum / i</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">arr, sum = <span class="hljs-number">0</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>), (sum += arr[<span class="hljs-number">0</span>]))
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> sum
  }
}
</code></pre>
<p>递归分析<br>
（概括其中的规律。像递推。）
检查每个递归实例，累计所需时间，其总和即算法执行时间。</p>
<ul>
<li>
<p>分而治之</p>
</li>
<li>
<p>减而治之</p>
</li>
<li>
<p>最好情况</p>
</li>
<li>
<p>最坏情况</p>
</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<ul>
<li>mark it work</li>
<li>mark it right</li>
<li>mark it fast</li>
</ul>
<p>Φ^36 = 2^25
Φ^5 = 10</p>
<h3 id="fib">fib</h3>
<pre><code class="language-js"><span class="hljs-comment">// generator方法</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">getFibArr</span> = (<span class="hljs-params">n</span>) =&gt; {
  <span class="hljs-keyword">let</span> genF = <span class="hljs-keyword">function</span>* (n) {
    <span class="hljs-keyword">let</span> [pre, cur] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (i &lt; n) {
      <span class="hljs-keyword">yield</span> cur
      <span class="hljs-comment">// [pre, cur] = [cur, pre + cur]</span>
      <span class="hljs-keyword">let</span> t = cur
      cur = t + pre
      pre = t
      i++
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">genF</span>(n))
}

<span class="hljs-comment">// 根据最后2项和为新添加的元素</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">n</span>) =&gt; {
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span> || !<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(n)) {
    <span class="hljs-keyword">return</span> []
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>]
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  } <span class="hljs-keyword">else</span> {
    res = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {
      <span class="hljs-keyword">let</span> t = res[res.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] + res[res.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>]
      res.<span class="hljs-title function_">push</span>(t)
    }
    <span class="hljs-keyword">return</span> res
  }
}

<span class="hljs-comment">// 得到fib中no.n个数</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">n</span>) =&gt; {
  <span class="hljs-comment">// 定义字典</span>
  <span class="hljs-comment">// 为字典赋值</span>
  <span class="hljs-comment">// 从字典中取值并赋值</span>
  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
  ])
  <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(n)) {
    <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(n)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">let</span> t = <span class="hljs-title function_">f</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">f</span>(n - <span class="hljs-number">2</span>)
    map.<span class="hljs-title function_">set</span>(n, t)
    <span class="hljs-keyword">return</span> t
  }
}
<span class="hljs-comment">// 还可做成类</span>
<span class="hljs-comment">// 待测试</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fib</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
      [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
      [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
    ])
  }
  <span class="hljs-title function_">sum</span>(<span class="hljs-params"><span class="hljs-keyword">from</span> = <span class="hljs-number">0</span>, to = <span class="hljs-variable language_">this</span>._map.size</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toArray</span>(<span class="hljs-keyword">from</span>, to).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">r, c</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> (r += c)
    }, <span class="hljs-number">0</span>)
  }
  <span class="hljs-title function_">toArray</span>(<span class="hljs-params"><span class="hljs-keyword">from</span> = <span class="hljs-number">0</span>, to = <span class="hljs-variable language_">this</span>._map.size</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_map</span>.<span class="hljs-title function_">values</span>()).<span class="hljs-title function_">slice</span>(<span class="hljs-keyword">from</span>, to)
  }
  <span class="hljs-title function_">getValueByIndex</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_map</span>.<span class="hljs-title function_">get</span>(n)) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_map</span>.<span class="hljs-title function_">get</span>(n)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">let</span> t = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValueByIndex</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValueByIndex</span>(n - <span class="hljs-number">2</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_map</span>.<span class="hljs-title function_">set</span>(n, t)
      <span class="hljs-keyword">return</span> t
    }
  }
  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_map</span>.<span class="hljs-title function_">clear</span>()
  }
}
</code></pre>
<h3 id="最长公共子序列-lcs">最长公共子序列 lcs</h3>
<pre><code class="language-js"><span class="hljs-comment">// 行列方式</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;didactical&#x27;</span> <span class="hljs-comment">// &#x27;ab&#x27;</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;advantage&#x27;</span> <span class="hljs-comment">// &#x27;abc&#x27;</span>
<span class="hljs-comment">// 返回lcs的长度</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">a, b</span>) =&gt; {
  <span class="hljs-comment">// 使用map</span>
  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>; i &lt; a.<span class="hljs-property">length</span>; i++) {
    map.<span class="hljs-title function_">set</span>(<span class="hljs-string">`<span class="hljs-subst">${i}</span>,-1`</span>, <span class="hljs-number">0</span>)
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = -<span class="hljs-number">1</span>; j &lt; b.<span class="hljs-property">length</span>; j++) {
    map.<span class="hljs-title function_">set</span>(<span class="hljs-string">`-1,<span class="hljs-subst">${j}</span>`</span>, <span class="hljs-number">0</span>)
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; b.<span class="hljs-property">length</span>; j++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">charAt</span>(i) === b.<span class="hljs-title function_">charAt</span>(j)) {
        map.<span class="hljs-title function_">set</span>(<span class="hljs-string">`<span class="hljs-subst">${i}</span>,<span class="hljs-subst">${j}</span>`</span>, map.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${i - <span class="hljs-number">1</span>}</span>,<span class="hljs-subst">${j - <span class="hljs-number">1</span>}</span>`</span>) + <span class="hljs-number">1</span>)
      } <span class="hljs-keyword">else</span> {
        map.<span class="hljs-title function_">set</span>(
          <span class="hljs-string">`<span class="hljs-subst">${i}</span>,<span class="hljs-subst">${j}</span>`</span>,
          <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${i - <span class="hljs-number">1</span>}</span>,<span class="hljs-subst">${j}</span>`</span>), map.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${i}</span>,<span class="hljs-subst">${j - <span class="hljs-number">1</span>}</span>`</span>))
        )
      }
    }
  }
  <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${a.length - <span class="hljs-number">1</span>}</span>,<span class="hljs-subst">${b.length - <span class="hljs-number">1</span>}</span>`</span>)
}
</code></pre>
<ul>
<li>单调性</li>
<li>最好情况 O(n+m)</li>
<li>若出现 2 个子问题，则可能出现雷同</li>
</ul>
<h1 id="no4-week">no.4 week</h1>
<ul>
<li>线性结构
<ul>
<li>向量（我学到的是面向对象的思想）</li>
<li>链表</li>
</ul>
</li>
</ul>
<p>秩：xxxx
构造函数：类在实例化时执行
析构函数：类的实例被删除时执行。js 中好像没有析构函数</p>
<h2 id="接口与实现">接口与实现</h2>
<ul>
<li>抽象数据类型 abstract data type
<ul>
<li>数据模型 + 定义在该模型上的一组操作</li>
</ul>
</li>
<li>数据结构
<ul>
<li>基于某种特定语言，实现 adt 的一整套算法</li>
</ul>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 逆序对的数量</span>
<span class="hljs-comment">// 若为0，则有序递增。</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">a</span>) =&gt; {
  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) {
    <span class="hljs-title function_">clog</span>(a[i], a[i + <span class="hljs-number">1</span>])
    <span class="hljs-keyword">if</span> (a[i] &gt; a[i + <span class="hljs-number">1</span>]) {
      res++
    }
  }
  <span class="hljs-keyword">return</span> res
}
</code></pre>
<h3 id="静态空间管理">静态空间管理</h3>
<ul>
<li>开辟内部数组</li>
<li>上溢、下溢</li>
<li>难以准确预测空间的需求量</li>
<li>是否可动态调整容量？</li>
</ul>
<h3 id="动态空间管理">动态空间管理</h3>
<ul>
<li>当即将发生上溢时，适当地扩大内部数组的容量。
<ul>
<li>增加容量
<ul>
<li>递增式扩容 分摊成本 O(n) 装填因子 约 100%</li>
<li>加倍式扩容 O(1) &gt;50%</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="平均分析--分摊分析">平均分析 &amp; 分摊分析</h3>
<table>
<thead>
<tr>
<th></th>
<th>平均分析</th>
<th>分摊分析</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>根据数据结构各种操作出现概率的分布，将对应的成本加权平均</td>
<td>对数据结构连续地实施足够多次操作，所需总体成本分摊到单次操作。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>各种操作作为独立事件分别考查</td>
<td>对一系列操作做整体的考量</td>
<td></td>
</tr>
<tr>
<td></td>
<td>割裂了操作之间的相关性和连贯性</td>
<td>刻画了可能出现的操作序列</td>
<td></td>
</tr>
<tr>
<td></td>
<td>往往不能准确地评判数据结构和算法的真实性能</td>
<td>精准的评判数据结构和算法的真实性能</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="二分查找">二分查找</h3>
<p>1.5logn</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">binSearch</span> = (<span class="hljs-params">arr, e</span>) =&gt; {
  <span class="hljs-keyword">let</span> lo = <span class="hljs-number">0</span>,
    hi = arr.<span class="hljs-property">length</span>
  <span class="hljs-keyword">let</span> m
  <span class="hljs-keyword">while</span> (lo &lt; hi) {
    m = (lo + hi) &gt;&gt; <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; Math.floor((lo + hi) / 2)</span>
    <span class="hljs-keyword">if</span> (arr[m] &gt; e) {
      hi = m
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[m] &lt; e) {
      lo = m + <span class="hljs-number">1</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> m
    }
  }
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
}
</code></pre>
<h1 id="no5-week">no.5 week</h1>
<h2 id="fibonacci查找">fibonacci查找</h2>
<p>没学会
当数组长度n = fib(k) - 1，则m = fib(k - 1) - 1，分为二个数组。长度：（fib(k-1)-1, fib(k-2)-1）</p>
<pre><code class="language-js"></code></pre>
<h2 id="改进二分查找">改进二分查找</h2>
<pre><code class="language-js"><span class="hljs-comment">// 版本b</span>
<span class="hljs-comment">// 待测试</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">bs</span> = (<span class="hljs-params">arr, e</span>) =&gt; {
  <span class="hljs-keyword">let</span> lo = <span class="hljs-number">0</span>, hi = arr.<span class="hljs-property">length</span>
  <span class="hljs-keyword">let</span> m
  <span class="hljs-keyword">while</span> (hi - lo &gt; <span class="hljs-number">1</span>) {
    m = (hi + lo) &gt;&gt; <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> (arr[m] &gt; e) {
      hi = m
    } <span class="hljs-keyword">else</span> {
      lo = m
    }
  }
  <span class="hljs-keyword">return</span> arr[lo] === e ? lo : -<span class="hljs-number">1</span>
} 
<span class="hljs-comment">// 版本c</span>
<span class="hljs-comment">// 待测试</span>
</code></pre>
<h2 id="插值查找">插值查找</h2>
<pre><code>(m-l) / (h-l) = (e-a[l]) / (a[h]-a[l])
</code></pre>
<p>loglogn</p>
<h2 id="冒泡排序">冒泡排序</h2>
<pre><code class="language-js">
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>改进</td>
<td>标记未排序部分是否已经有序。</td>
<td>若有序则跳过未排序部分。</td>
</tr>
<tr>
<td></td>
<td>再改进</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="归并排序">归并排序</h2>
<h2 id="其它排序"><a href="/dsa/sort.html">其它排序</a></h2>
<ul>
<li>选择排序</li>
<li>堆排序</li>
<li>快速排序</li>
</ul>
<h1 id="no6-week">no.6 week</h1>
<p>对于列表接口中的 find(e) 与 search(e)，其中一个重要区别在于 find 普适于所有列表，而 search 适用于有序列表。</p>
<pre><code class="language-js">link.<span class="hljs-title function_">find</span>(e, n, p) <span class="hljs-comment">// 在link中p下标往前n个元素的范围内查找元素e.</span>
link.<span class="hljs-title function_">find</span>(e, p, n) <span class="hljs-comment">// 在link中p下标往后n个元素的范围内查找元素e.</span>
</code></pre>
<p>选择排序与冒泡排序类似</p>
<table>
<thead>
<tr>
<th></th>
<th>选择排序</th>
<th>冒泡排序</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>取出最大值（或最小值）移动一次</td>
<td>多次比较才能得到最大值（或最小值）。过程中会移动多次</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="no7-week">no.7 week</h1>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>