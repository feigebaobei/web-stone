# title

## 伸展树 splayTree

- 比 avlt 宽松一些
- 局部性
  - 刚被访问过的数据，可能还会很快被访问。
- 利用了中序遍历不变的特性。
- 一次向上追溯 2 层 v, p = v.parent, g = p.parent. avlt 是每次向上追溯一层。
- 对应路径的长度减头。可减少树的高度为原来的一半。因为它每次都会在 g 节点的左或右增加节点。

## b-tree

- 最初为了解决不同存储级别之间在访问速度上的巨大差异。（即高效 io）
- 应用的内存虽然的增长，但是实际可应用的内存在减小。
- 多个子节点。（多度）
- 节点中包括多个元素
- 叶子节点的深度一致
- 平衡多路搜索树 multi-way
- 每向下降一层，则读入一组关键码。
- 它是高阶平衡树。m 阶表示：每个节点最多 m 个分支，m-1 个关键码。
- 节点的子元素数量：
  - 非根节点 `[m/2] <= n + 1`
  - 根节点 `2 <= n + 1 `
- 也称为 `([m/2], m)-树`
- (2,4)-树地位很重要。与 rb-tree 有关
- 超级节点可以使用 2 个线性数据结构表示
  - 一个放数据
  - 一个放子元素的链接
- 查找工作结束与外部节点
- 每层的节点为数量
  - 1
  - 2
  - `2 * [m/2]^(k-1)`
- m 阶。即：m 个内部节点，m+1 个外部节点，m 种成功可能，m+1 种失败可能。
-

### 存储分级

向下为外存，向上为内丰。
上下传递数据为 io 操作.  
越上层访问速度越快。反之成立。  
io 时操作 1b 与 1kb 几乎一样。

```
    cpu
    ram
    disk
    array // 磁盘陈列
    ...
```

### title

## title

## todo

好多静态结构，是由动态调整来保持的。
