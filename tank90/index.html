<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>90 tank</title>
	<style type="text/css">
		body {
			margin: 0;
			width: 100vw;
			height: 100vh;
		}
		#canvas {
			margin: 0 auto;
			display: block;
			/*border: 1px solid #234;*/
			box-sizing: border-box;
		}
	</style>
</head>
<body>
	<canvas id="canvas">您的浏览器不支持本游戏！
		创建一个系统的规则比较困难。不知道什么样的规则才是合适的。
	</canvas>
	<script type="text/javascript" src="./canvasCore.js"></script>
	<script type="text/javascript">
		let canvas = document.querySelector('#canvas')
		let context = canvas.getContext('2d')
		let {log} = console
		let bodyDom = document.querySelector('body')
		let [bodyW, bodyH] = [bodyDom.clientWidth, bodyDom.clientHeight]
		let edgeLength = Math.min(bodyW, bodyH)
		let edgeLengthHalf = edgeLength * 0.5
		canvas.width = edgeLength
		canvas.height = edgeLength

		let tankCanvas = document.createElement('canvas')
		tankCanvas.width = edgeLength
		tankCanvas.height = edgeLength
		let tankContext = tankCanvas.getContext('2d')
		let paintBorder = (ctx = context, lineWidth = 1) => {
			// log(ctx)
			ctx.save()
			ctx.lineWidth = lineWidth
			ctx.beginPath()
			ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)
			ctx.closePath()
			// // ctx.fillStyle = 'grey'
			ctx.strokeStyle = 'red'
			// // ctx.fill()
			ctx.stroke()
			ctx.restore()
		}
		let paintFill = (ctx = context, fillStyle = 'grey') => {
			ctx.save()
			log('ain')
			// ctx.lineWidth = lineWidth
			ctx.beginPath()
			ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)
			// ctx.closePath()
			ctx.fillStyle = fillStyle
			// ctx.strokeStyle = 'red'
			ctx.fill()
			// ctx.stroke()
			ctx.restore()
		}
		let tankPainter = {
			paint: (sprite, context) => {
				context.save()
				// 底壳
				context.strokeStyle = '#222'
				context.beginPath()
				context.rect(edgeLength * 0.1, edgeLength * 0.1, edgeLength * 0.8, edgeLength * 0.85)
				context.fillStyle = '#333'
				context.fill()
				context.stroke()
				// 履带
				context.beginPath()
				context.fillStyle = '#666'
				context.rect(0, 0, edgeLength * 0.25, edgeLength)
				context.rect(edgeLength * 0.75, 0, edgeLength * 0.25, edgeLength)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#777'
				context.rect(edgeLength * 0.025, edgeLength * 0.05, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.24, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.43, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.62, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.81, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.05, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.24, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.43, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.62, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.81, edgeLength * 0.2, edgeLength * 0.1)
				context.fill()
				context.stroke()
				// 机舱
				context.beginPath()
				context.fillStyle = '#bbb'
				context.rect(edgeLength * 0.1, edgeLength * 0.15, edgeLength * 0.8, edgeLength * 0.8)
				context.fill()
				context.stroke()
				// 炮塔
				context.beginPath()
				context.fillStyle = '#ddd'
				context.rect(edgeLength * 0.3, edgeLength * 0.4, edgeLength * 0.4, edgeLength * 0.4)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#eee'
				context.arc(edgeLength * 0.5, edgeLength * 0.6, edgeLength * 0.18, 0, 2*Math.PI, true)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#eee'
				// context.lineWidth = edgeLength * 0.02
				context.rect(edgeLength * 0.45, 0, edgeLength * 0.1, edgeLength * 0.5)
				context.fill()
				context.stroke()
				context.beginPath()
				// 炮塔
				// 星级
				context.fill()
				context.stroke()
				context.restore()
			}
		}
		// let tankOffset = new Sprite({
		// 	name: 'tankOffset',
		// 	// left: 50,
		// 	// top: 50,
		// 	// vx: 30,
		// 	// width: 25,
		// }, tankPainter,
		// // [{
		// // 	execute: function (sprite, context, fps) {
		// // 		sprite.left += sprite.vx * fps / 1000
		// // 		if (sprite.left > edgeLength) {
		// // 			sprite.left = 50
		// // 		}
		// // 	}
		// // }]
		// )
		let tankOffset = new OffsetCanvasSprite({name: 'tankOffsetSprite'}, tankPainter, [], edgeLength, edgeLength)
		tankOffset.setDirection({x: 1, y: 0})
		tankOffset.setDirection({x: 0, y: -1})
		tankOffset.setDirection({x: -1, y: 0})
		log('tankOffset', tankOffset)
		tankOffset.setDirection(new Vector(1, 0))
		log('tankOffset', tankOffset.getCanvas(new Vector(1, 0)))
		// 原本的tank
		// context.rotate(Math.PI / 2)
		// context.translate(0, -edgeLength) // 先旋转，按旋转后的绘图环境再位移。
		// tankOffset.paint(context)
		// 向右的tank
		// tankContext.rotate(Math.PI / 2)
		// tankContext.translate(0, -edgeLength)
		// tankOffset.paint(tankContext)
		// context.drawImage(tankCanvas, 0, 0, edgeLength, edgeLength, 10, 10, edgeLength * 0.1, edgeLength * 0.1)
		// 四个方向的tank
		context.drawImage(tankOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLength, 70, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(0, -1)), 0, 0, edgeLength, edgeLength, 130, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas({x: 0, y: -1}), 0, 0, edgeLength, edgeLength, 130, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(-1, 0)), 0, 0, edgeLength, edgeLength, 190, 10, edgeLength * 0.1, edgeLength * 0.1)

		let brickPainter = {
			paint: (sprite, context) => {
				context.save()
				// 第一行
				context.fillStyle = '#9b3d3d'
				context.strokeStyle = '#333'
				context.lineWidth = edgeLength * 0.01
				context.beginPath()
				context.moveTo(0, 0)
				context.lineTo(edgeLength * 0.25, 0)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.25)
				context.lineTo(0, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.rect(edgeLength * 0.25, 0, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.moveTo(edgeLength, 0)
				context.lineTo(edgeLength * 0.75, 0)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.25)
				context.lineTo(edgeLength, edgeLength * 0.25)
				context.fill()
				context.stroke()
				// 第二行
				context.beginPath()
				context.rect(0, edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.25)
				context.rect(edgeLength * 0.5, edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				// 第三行
				context.beginPath()
				context.moveTo(0, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.75)
				context.lineTo(0, edgeLength * 0.75)
				context.fill()
				context.stroke()
				context.beginPath()
				context.rect(edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.moveTo(edgeLength, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.75)
				context.lineTo(edgeLength, edgeLength * 0.75)
				context.fill()
				context.stroke()
				// 第四行
				context.beginPath()
				context.rect(0, edgeLength * 0.75, edgeLength * 0.5, edgeLength * 0.25)
				context.rect(edgeLength * 0.5, edgeLength * 0.75, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.restore()
			}
		}
		// let brick = new Sprite({
		// 	name: 'brick'
		// }, brickPainter, [])
		let brickOffset = new OffsetCanvasSprite({name: 'brick'}, brickPainter, [], edgeLength, edgeLength)
		// 砖头
		// brick.paint(context)
		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 80, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 70, 80, edgeLength * 0.1, edgeLength * 0.1)

		let shellPainter = {
			paint: (sprite, context) => {
				// 只绘制正方向的一个图形。
				// 在使用图形时旋转。
				if (sprite.direction.x === 0 && sprite.direction.y === 1) {
					log(sprite.direction.x, sprite.direction.y, '3456')
					let lineWidth = sprite.width * 0.15
					let lineWidthHalf = lineWidth / 2
					let [linerBoxX, linerBoxY, linerBoxW, linerBoxH] = [lineWidthHalf, lineWidthHalf, sprite.width - lineWidthHalf, sprite.height - lineWidthHalf]
					context.save()				
					context.fillStyle = '#dee3eb'
					context.strokeStyle = '#333'
					context.lineWidth = lineWidth
					context.beginPath()
					// context.moveTo(edgeLength * 0.25, edgeLength)
					// context.lineTo(edgeLength * 0.25, edgeLength * 0.5)
					// context.quadraticCurveTo(edgeLength * 0.25, 0, edgeLength * 0.5, 0)
					// context.quadraticCurveTo(edgeLength * 0.75, 0, edgeLength * 0.75, edgeLength * 0.5)
					// context.lineTo(edgeLength * 0.75, edgeLength)

					// context.moveTo(sprite.left + lineWidthHalf, sprite.top + sprite.height - lineWidthHalf)
					// context.lineTo(sprite.left + lineWidthHalf, sprite.top + sprite.height * 0.5)
					// context.quadraticCurveTo(sprite.left + lineWidthHalf, sprite.top + lineWidthHalf, sprite.left + sprite.width * 0.5, sprite.top + lineWidthHalf)
					// context.quadraticCurveTo(sprite.left + sprite.width - lineWidthHalf, sprite.top + lineWidthHalf, sprite.left + sprite.width - lineWidthHalf, sprite.top + sprite.height * 0.5)
					// context.lineTo(sprite.left + sprite.width - lineWidthHalf, sprite.top + sprite.height - lineWidthHalf)

					context.moveTo(linerBoxX, linerBoxH)
					context.lineTo(linerBoxX, linerBoxH / 2)
					context.quadraticCurveTo(linerBoxX, linerBoxY, linerBoxW / 2, linerBoxY)
					context.quadraticCurveTo(linerBoxW, linerBoxY, linerBoxW, linerBoxH / 2)
					context.lineTo(linerBoxW, linerBoxH)
					context.closePath()
					context.fill()
					context.stroke()
					context.restore()
					// paintBorder(context, 50)
				} else if (this.direction.x === 1 && this.direction.y === 0) {
					// paintFill(context)
					log('1, 0', 'strin')
				} else if (this.direction.x === 0 && this.direction.y === -1) {
					log('0, -1', 'sdfa')
				} else if (this.direction.x === -1 && this.direction.y === 0) {
					log('-1, 0', 'sdfe')
				}
			}
		}
		// let shell = new Sprite({
		// 	name: 'shell',
		// 	width: edgeLength * 0.5,
		// 	height: edgeLength,
		// }, shellPainter, [])
		// shell.paint(context)
		let shellOffset = new OffsetCanvasSprite({
			name: 'shell',
			width: edgeLengthHalf,
			height: edgeLength,
			// direction: new Vector(0, -1)
		}, shellPainter, [], edgeLength, edgeLength)
		shellOffset.setDirection(new Vector(1, 0))
		shellOffset.setDirection(new Vector(0, -1))
		shellOffset.setDirection(new Vector(-1, 0))
		// 炮弹
		// context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 0, 0, edgeLength, edgeLength)
		// context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, 0, 0, edgeLength, edgeLengthHalf)
		// context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, 0, 0, edgeLengthHalf, edgeLength)
		// context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, 0, 0, edgeLength, edgeLengthHalf)
		context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, 10, 150, edgeLengthHalf * 0.1, edgeLength * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, 70, 150, edgeLength * 0.1, edgeLengthHalf * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, 130, 150, edgeLengthHalf * 0.1, edgeLength * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, 190, 150, edgeLength * 0.1, edgeLengthHalf * 0.1)
		context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, 10, 220, edgeLengthHalf * 0.025, edgeLength * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, 70, 220, edgeLength * 0.025, edgeLengthHalf * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, 130, 220, edgeLengthHalf * 0.025, edgeLength * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, 190, 220, edgeLength * 0.025, edgeLengthHalf * 0.025)

		// 绘制静态画面
		// paintFill()
		paintBorder()



		



		class ShellSprite extends Sprite {
			constructor(spriteOpt, painter, behaviors) {
				super(spriteOpt, painter, behaviors)
				this.level = spriteOpt.level || 0
			}
		}
		class tankSprite extends Sprite{
			constructor(spriteOpt, painter, behaviors) {
				super(spriteOpt, painter, behaviors)
				this.level = spriteOpt.level || 0
			}
			fire() {
				let v = 0
				switch(this.level) {
					case 0:
					default:
						v = 45 // new Vector()
						break
					case 1:
						v = 60
						break
					case 2:
						v = 70
						break
					case 3:
						v = 80
						break
				}
				v = new Vector(this.direction.x * v, -this.direction.y * v)
				let shellW = edgeLength * 0.025 * 0.5
				let shellH = shellW * 2
				let l // = this.left + this.width * 0.5 - shellW * 0.5
				let t // = this.top
				let shellDirction = new Vector(this.direction.x, this.direction.y)
				if (this.direction.x === 0 && this.direction.y === 1) {
					l = this.left + this.width * 0.5 - shellW * 0.5
					t = this.top
				} else if (this.direction.x === 1 && this.direction.y === 0) {
					l = this.left + this.height - shellH
					t = this.top + this.height * 0.5 - shellW * 0.5
				} else if (this.direction.x === 0 && this.direction.y === -1) {
					l = this.left + this.width * 0.5 - shellW * 0.5
					t = this.top + this.height - shellH
				} else if (this.direction.x === -1 && this.direction.y === 0) {
					l = this.left
					t = this.top + this.height * 0.5 - shellW * 0.5
				}
				return new ShellSprite({
					name: 'shell',
					top: t, // this.top,
					left: l, // this.left,
					width: shellW, // this.width * 0.5,
					height: shellH, // this.height,
					v,
					direction: this.direction,
					animating: true
					// : this.,
					// top: this.top,
					// top: this.top,
					// spriteOpt.direction
				},
				// shellPainter,
				{
					paint: (sprite, context) => {
						// context.drawImage(shellOffset.getCanvas(sprite.direction), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
						let {x, y} = sprite.direction
						if (x === 0 && y == 1) {
							context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, sprite.left, sprite.top, edgeLengthHalf * 0.025, edgeLength * 0.025)
						} else if (x === 1 && y === 0) {
							context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, sprite.left, sprite.top, edgeLength * 0.025, edgeLengthHalf * 0.025)
						} else if (x === 0 && y === -1) {
							context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, sprite.left, sprite.top, edgeLengthHalf * 0.025, edgeLength * 0.025)
						} else {
							context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, sprite.left, sprite.top, edgeLength * 0.025, edgeLengthHalf * 0.025)
						}
					}
				},
				[{
					execute: (sprite, context, fps) => {
						sprite.left += sprite.v.x * fps / 1000
						sprite.top += sprite.v.y * fps / 1000
						if (sprite.left > edgeLength - sprite.width || sprite.left < 0 || sprite.top < 0 || sprite.top > edgeLength - sprite.height) {
							// sprite.visible = false
							sprite.animating = false
						}
					}
				}])
				// return shellOffset.offsetSprite // .offsetSprite.v = new Vector(45, 0)
				// return new Sprite()
			}
		}
		// let tank = new Sprite({
		let tank = new tankSprite({
			name: 'tank',
			left: edgeLength * 0.5,
			top: edgeLength * 0.5,
			width: edgeLength * 0.1,
			height: edgeLength * 0.1,
			// vx: 0,
			// vy: 0,
			v: new Vector(0, 0)
		}, {
			paint: (sprite, context) => {
				// context.drawImage(tankCanvas, 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
				context.drawImage(tankOffset.getCanvas(sprite.direction), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
				
			}
		}, [
		{
			execute: (sprite, context, fps) => {
				// log(sprite, fps)
				sprite.left += sprite.v.x * fps / 1000
				sprite.top += sprite.v.y * fps / 1000
				if (sprite.left > edgeLength - sprite.width) {
					sprite.left = edgeLength - sprite.width
				}
				if (sprite.top > edgeLength - sprite.width) {
					sprite.top = edgeLength - sprite.width
				}
				if (sprite.left < 0) {
					sprite.left = 0
				}
				if (sprite.top < 0) {
					sprite.top = 0
				}
			}
		}
		])
		// log('tank', tank)
		// let test = new Sprite({}, {paint: (sprite, context) => {
		// 	log('paint')
		// }}, [])
		// log('test', test)
		// test.paint()
		// log()



		let lastTimeForCalcFps = 0
		const calcFps = () => {
			let now = +new Date()
			let fps = 1000 / (now - lastTimeForCalcFps)
			log(now, lastTimeForCalcFps, fps)
			lastTimeForCalcFps = now
			return fps
		}
		let fps, animateId

		let game = new Game('tank90', '#canvas', paintBorder)
		game.setSprite(tank)
		game.setKeyListener(38, (e) => {
			tank.animating = true
			tank.v = new Vector(0, -30)
			tank.direction = new Vector(0, 1)
		}, true)
		game.setKeyListener(38, (e) => {
			tank.animating = true
			tank.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(40, (e) => {
			tank.animating = true
			tank.v = new Vector(0, 30)
			tank.direction = new Vector(0, -1)
		})
		game.setKeyListener(40, (e) => {
			tank.animating = true
			tank.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(37, (e) => {
			tank.animating = true
			tank.v = new Vector(-30, 0)
			tank.direction = new Vector(-1, 0)
		})
		game.setKeyListener(37, (e) => {
			tank.animating = true
			tank.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(39, (e) => {
			tank.animating = true
			tank.v = new Vector(30, 0)
			tank.direction = new Vector(1, 0)
		})
		game.setKeyListener(39, (e) => {
			tank.animating = true
			tank.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(32, (e) => {
			let t = tank.fire()
			log(t)
			game.setSprite(t)

						// context.drawImage(shellOffset.getCanvas(sprite.direction), 0, 0, edgeLength * 1, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
		})
		// let drawMap = () => {
		// 	// log('drawMap')
		// }
		// let draw = () => {
		// 	log('draw')
		// 	paintBorder()
		// 	// drawMap()
		// 	tank.update(context, fps)
		// 	tank.paint(context)
		// }
		// let animate = (time) => {
		// 	context.clearRect(0, 0, edgeLength, edgeLength)
		// 	fps = calcFps()
		// 	draw()
		// 	animateId = requestNextAnimateionFrame(animate)
		// }
		let start = () => {
			// animateId = requestNextAnimateionFrame(animate)
			game.start()
		}
		let stop = () => {
			// game.animating = false
			// game.start()
			// cancelNextAnimationFrame(animateId)
		}
		let flag = false
		canvas.onclick = (e) => {
			flag = !flag
			if (flag) {
				start()
			} else {
				stop()
			}
		}
		window.onblur = (e) => {
			if (flag) {
				flag = false
				stop()
			}
		}

		log(game)

		// log(tankOffset)

	</script>
</body>
</html>