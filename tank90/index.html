<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>90 tank</title>
	<style type="text/css">
		body {
			margin: 0;
			width: 100vw;
			height: 100vh;
		}
		#canvas {
			margin: 0 auto;
			display: block;
			/*border: 1px solid #234;*/
			box-sizing: border-box;
		}
	</style>
</head>
<body>
	<canvas id="canvas">您的浏览器不支持本游戏！
		创建一个系统的规则比较困难。不知道什么样的规则才是合适的。
	</canvas>
	<script type="text/javascript" src="./canvasCore.js"></script>
	<script type="text/javascript">
		let canvas = document.querySelector('#canvas')
		let context = canvas.getContext('2d')
		let {log} = console
		let bodyDom = document.querySelector('body')
		let [bodyW, bodyH] = [bodyDom.clientWidth, bodyDom.clientHeight]
		let edgeLength = Math.min(bodyW, bodyH)
		canvas.width = edgeLength
		canvas.height = edgeLength

		let tankCanvas = document.createElement('canvas')
		tankCanvas.width = edgeLength
		tankCanvas.height = edgeLength
		let tankContext = tankCanvas.getContext('2d')
		let paintBorder = () => {
			context.save()
			context.rect(0, 0, edgeLength, edgeLength)
			// // context.fillStyle = 'grey'
			context.strokeStyle = 'red'
			// // context.fill()
			context.stroke()
			context.restore()
		}

		class OffsetCanvasSprite {
			// constructor({name = '', left: 0, top: 0, width: 0, height: 0, vx: 0, vy: 0, visible: true, animating: false, direction: new Vector(0, 1)}, painter, behaviors, width, height) {
			// constructor({name = '', left = 0, top = 0, width = 0, height = 0, vx = 0, vy = 0, visible = true, animating = false, direction = new Vector(0, 1)}, painter, behaviors, cwidth, cheight) {
			constructor(spriteOpt, painter, behaviors, cwidth, cheight) {
				this.memo = new Map()
				this.width = cwidth
				this.height = cheight
				this.offsetSprite = new Sprite(spriteOpt, painter, behaviors)
				let v = spriteOpt.direction || new Vector(0, 1)
				this.direction = v
				this.setDirection(v)
			}
			setDirection(v) {
				if (!Vector.prototype.isPrototypeOf(v)) {
					v = new Vector(v.x, v.y)
				}
				let n = v.normalize()
				if (!this.memo.has(`${n.x}-${n.y}`)) {
					let offsetCanvas = document.createElement('canvas')
					offsetCanvas.width = this.width
					offsetCanvas.height = this.height
					let offsetContext = offsetCanvas.getContext('2d')
					// 当前只支持4个方向
					if (n.x === 0 && n.y === 1) {} else if (n.x === 1 && n.y === 0) {
						offsetContext.rotate(Math.PI / 2)
						offsetContext.translate(0, -this.height)
					} else if (n.x === 0 && n.y === -1) {
						offsetContext.rotate(Math.PI)
						offsetContext.translate(-this.width, -this.height)
					} else if (n.x === -1 && n.y === 0) {
						offsetContext.rotate(Math.PI / -2)
						offsetContext.translate(-this.width, 0)
					}
					this.offsetSprite.paint(offsetContext)
					this.memo.set(`${n.x}-${n.y}`, offsetCanvas)
				}
			}
			getCanvas(v = new Vector(0, 1)) {
				return this.memo.get(`${v.x}-${v.y}`)
				// let c = this.memo.get(`${v.x}-${v.y}`)
				// if (c) {
				// 	return c
				// } else {
				// 	this.setDirection(v)
				// 	return this.getCanvas(v)
				// }
			}
		}
		let painter = {
			paint: (sprite, context) => {
				context.save()
				// 底壳
				context.strokeStyle = '#222'
				context.beginPath()
				context.rect(edgeLength * 0.1, edgeLength * 0.1, edgeLength * 0.8, edgeLength * 0.85)
				context.fillStyle = '#333'
				context.fill()
				context.stroke()
				// 履带
				context.beginPath()
				context.fillStyle = '#666'
				context.rect(0, 0, edgeLength * 0.25, edgeLength)
				context.rect(edgeLength * 0.75, 0, edgeLength * 0.25, edgeLength)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#777'
				context.rect(edgeLength * 0.025, edgeLength * 0.05, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.24, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.43, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.62, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.81, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.05, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.24, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.43, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.62, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.81, edgeLength * 0.2, edgeLength * 0.1)
				context.fill()
				context.stroke()
				// 机舱
				context.beginPath()
				context.fillStyle = '#bbb'
				context.rect(edgeLength * 0.1, edgeLength * 0.15, edgeLength * 0.8, edgeLength * 0.8)
				context.fill()
				context.stroke()
				// 炮塔
				context.beginPath()
				context.fillStyle = '#ddd'
				context.rect(edgeLength * 0.3, edgeLength * 0.4, edgeLength * 0.4, edgeLength * 0.4)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#eee'
				context.arc(edgeLength * 0.5, edgeLength * 0.6, edgeLength * 0.18, 0, 2*Math.PI, true)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#eee'
				// context.lineWidth = edgeLength * 0.02
				context.rect(edgeLength * 0.45, 0, edgeLength * 0.1, edgeLength * 0.5)
				context.fill()
				context.stroke()
				context.beginPath()
				// 炮塔
				context.fill()
				context.stroke()
				context.restore()
			}
		}

		// let tankOffset = new Sprite({
		// 	name: 'tankOffset',
		// 	// left: 50,
		// 	// top: 50,
		// 	// vx: 30,
		// 	// width: 25,
		// }, painter,
		// // [{
		// // 	execute: function (sprite, context, fps) {
		// // 		sprite.left += sprite.vx * fps / 1000
		// // 		if (sprite.left > edgeLength) {
		// // 			sprite.left = 50
		// // 		}
		// // 	}
		// // }]
		// )
		let tankOffset = new OffsetCanvasSprite({name: 'tankOffsetSprite'}, painter, [], edgeLength, edgeLength)
		tankOffset.setDirection({x: 1, y: 0})
		tankOffset.setDirection({x: 0, y: -1})
		tankOffset.setDirection({x: -1, y: 0})
		// log('tankOffset', tankOffset)
		// tankOffset.setDirection(new Vector(1, 0))
		// log('tankOffset', tankOffset.getCanvas(new Vector(1, 0)))

		// 绘制静态画面
		paintBorder()

		// 原本的tank
		// context.rotate(Math.PI / 2)
		// context.translate(0, -edgeLength) // 先旋转，按旋转后的绘图环境再位移。
		// tankOffset.paint(context)

		// 向右的tank
		// tankContext.rotate(Math.PI / 2)
		// tankContext.translate(0, -edgeLength)
		// tankOffset.paint(tankContext)
		// context.drawImage(tankCanvas, 0, 0, edgeLength, edgeLength, 10, 10, edgeLength * 0.1, edgeLength * 0.1)

		context.drawImage(tankOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLength, 70, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(0, -1)), 0, 0, edgeLength, edgeLength, 130, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas({x: 0, y: -1}), 0, 0, edgeLength, edgeLength, 130, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(-1, 0)), 0, 0, edgeLength, edgeLength, 190, 10, edgeLength * 0.1, edgeLength * 0.1)








		let tank = new Sprite({
			name: 'tank',
			left: edgeLength * 0.5,
			top: edgeLength * 0.5,
			width: edgeLength * 0.1,
			height: edgeLength * 0.1,
			vx: 0,
			vy: 0,
			// direction: 
		}, {
			paint: (sprite, context) => {
				// context.drawImage(tankCanvas, 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
				context.drawImage(tankOffset.getCanvas(sprite.direction), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
				
			}
		}, [
		{
			execute: (sprite, context, fps) => {
				if (tank.animating) {
					sprite.left += sprite.vx * fps / 1000
					sprite.top += sprite.vy * fps / 1000
					if (sprite.left > edgeLength - sprite.width) {
						sprite.left = edgeLength - sprite.width
					}
					if (sprite.top > edgeLength - sprite.width) {
						sprite.top = edgeLength - sprite.width
					}
					if (sprite.left < 0) {
						sprite.left = 0
					}
					if (sprite.top < 0) {
						sprite.top = 0
					}
				}
			}
		}
		])



		let lastTimeForCalcFps = 0
		const calcFps = () => {
			let now = +new Date()
			let fps = 1000 / (now - lastTimeForCalcFps)
			lastTimeForCalcFps = now
			return fps
		}
		let fps, animateId


		let draw = () => {
			log('draw')
			paintBorder()
			tank.update(context, fps)
			tank.paint(context)
		}
		let animate = (time) => {
			context.clearRect(0, 0, edgeLength, edgeLength)
			fps = calcFps()
			draw()
			animateId = requestNextAnimateionFrame(animate)
		}
		let start = () => {
			animateId = requestNextAnimateionFrame(animate)
		}
		let stop = () => {
			cancelNextAnimationFrame(animateId)
		}
		let flag = false
		canvas.onclick = (e) => {
			flag = !flag
			if (flag) {
				start()
			} else {
				stop()
			}
		}

		// tankOffset.paint(tankContext)
		let fn = () => {
			let radian = tank.direction.radian()
			log('radian', radian)
			if (!radian || radian > 6) {
				// null
			} else if (radian > 1 && radian < 3) {
				tankContext.rotate(Math.PI / 2)
				tankContext.translate(0, -edgeLength)
				tankOffset.paint(tankContext)
			} else if (radian > 3 && radian < 4) {
				tankContext.rotate(Math.PI)
				tankContext.translate(-edgeLength, -edgeLength)
			} else if (radian > 4 && radian < 6) {
				tankContext.rotate(Math.PI / -2)
				tankContext.translate(-edgeLength, 0)
			}
			tankOffset.paint(tankContext)
		}

		let game = new Game('tank90', '#canvas')
		game.setKeyListener(38, (e) => {
			// log(38, '上donw', e)
			tank.animating = true
			tank.vy = -30
			tank.vx = 0
			tank.direction = new Vector(0, 1)
			// fn()
		}, true)
		game.setKeyListener(38, (e) => {
			// log(38, '上up', e)
			tank.animating = true
			tank.vy = 0
			tank.vx = 0
		}, false)
		game.setKeyListener(40, (e) => {
			// log(40, '下', e)
			tank.animating = true
			tank.vy = 30
			tank.vx = 0
			tank.direction = new Vector(0, -1)
			// fn()
			// tankContext.rotate(Math.PI)
			// tankContext.translate(-edgeLength, -edgeLength)
			// tankOffset.paint(tankContext)
		})
		game.setKeyListener(40, (e) => {
			// log(40, '下', e)
			tank.animating = true
			tank.vy = 0
			tank.vx = 0
		}, false)
		game.setKeyListener(37, (e) => {
			// log(37, '左', e)
			tank.animating = true
			tank.vx = -30
			tank.vy = 0
			tank.direction = new Vector(-1, 0)
			// fn()
		})
		game.setKeyListener(37, (e) => {
			// log(37, '左', e)
			tank.animating = true
			tank.vx = 0
			tank.vy = 0
		}, false)
		game.setKeyListener(39, (e) => {
			// log(39, '右', e)
			tank.animating = true
			tank.vx = 30
			tank.vy = 0
			tank.direction = new Vector(1, 0)
			// fn()
		})
		game.setKeyListener(39, (e) => {
			// log(39, '右', e)
			tank.animating = true
			tank.vx = 0
			tank.vy = 0
		}, false)
		log(game)

		// log(tankOffset)

	</script>
</body>
</html>