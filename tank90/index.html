<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>90 tank</title>
	<style type="text/css">
		body {
			margin: 0;
			width: 100vw;
			height: 100vh;
		}
		#canvas {
			margin: 0 auto;
			display: block;
			/*border: 1px solid #234;*/
			box-sizing: border-box;
		}
	</style>
</head>
<body>
	<canvas id="canvas">您的浏览器不支持本游戏！
		创建一个系统的规则比较困难。不知道什么样的规则才是合适的。
	</canvas>
	<script type="text/javascript" src="./canvasCore.js"></script>
	<script type="text/javascript">
		/*
		tank发射炮弹的速率
		坦克可升级
		随机出现礼物
		绘制场景
		可碰撞
		把Game搞成一个基础类，然后其他该基础类扩展新的类
		*/
		let canvas = document.querySelector('#canvas')
		let context = canvas.getContext('2d')
		let {log} = console
		let bodyDom = document.querySelector('body')
		let [bodyW, bodyH] = [bodyDom.clientWidth, bodyDom.clientHeight]
		let edgeLength = Math.min(bodyW, bodyH)
		let edgeLengthHalf = edgeLength * 0.5
		let [edgeLength01, edgeLength02, edgeLength03, edgeLength04, edgeLength05, edgeLength06, edgeLength07, edgeLength08, edgeLength09] = [edgeLength * 0.1, edgeLength * 0.2, edgeLength * 0.3, edgeLength * 0.4, edgeLength * 0.5, edgeLength * 0.6, edgeLength * 0.7, edgeLength * 0.8, edgeLength * 0.9]
		canvas.width = edgeLength
		canvas.height = edgeLength

		let tankCanvas = document.createElement('canvas')
		tankCanvas.width = edgeLength
		tankCanvas.height = edgeLength
		let tankContext = tankCanvas.getContext('2d')
		let paintBorder = (ctx = context, lineWidth = 1) => {
			// log(ctx)
			ctx.save()
			ctx.lineWidth = lineWidth
			ctx.beginPath()
			ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)
			ctx.closePath()
			// // ctx.fillStyle = 'grey'
			ctx.strokeStyle = 'red'
			// // ctx.fill()
			ctx.stroke()
			ctx.restore()
		}
		let paintFill = (ctx = context, fillStyle = 'grey') => {
			ctx.save()
			// log('ain')
			// ctx.lineWidth = lineWidth
			ctx.beginPath()
			ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)
			// ctx.closePath()
			ctx.fillStyle = fillStyle
			// ctx.strokeStyle = 'red'
			ctx.fill()
			// ctx.stroke()
			ctx.restore()
		}
		let paintStop = (ctx = context, fillStyle = 'red') => {
			let [cw, ch] = [ctx.canvas.width, ctx.canvas.height]
			// log('paintStop', cw, ch)
			ctx.save()
			ctx.rect(0, 0, cw, ch)
			ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'
			ctx.fill()
			ctx.beginPath()
			ctx.fillStyle = fillStyle
			ctx.textAlign = 'center'
			ctx.font = '100px serif'
			ctx.fillText('stop', cw * 0.5, ch * 0.5)
			// ctx.fill()
			// ctx.stroke()
			ctx.restore()
		}
		let tankOffsetPainter = {
			paint: (sprite, context) => {
				context.save()
				// 底壳
				context.strokeStyle = '#222'
				context.beginPath()
				context.rect(edgeLength * 0.1, edgeLength * 0.1, edgeLength * 0.8, edgeLength * 0.85)
				context.fillStyle = '#333'
				context.fill()
				context.stroke()
				// 履带
				context.beginPath()
				context.fillStyle = '#666'
				context.rect(0, 0, edgeLength * 0.25, edgeLength)
				context.rect(edgeLength * 0.75, 0, edgeLength * 0.25, edgeLength)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#777'
				context.rect(edgeLength * 0.025, edgeLength * 0.05, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.24, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.43, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.62, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.81, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.05, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.24, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.43, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.62, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.81, edgeLength * 0.2, edgeLength * 0.1)
				context.fill()
				context.stroke()
				// 机舱
				context.beginPath()
				context.fillStyle = '#bbb'
				context.rect(edgeLength * 0.1, edgeLength * 0.15, edgeLength * 0.8, edgeLength * 0.8)
				context.fill()
				context.stroke()
				// 炮塔
				context.beginPath()
				context.fillStyle = '#ddd'
				context.rect(edgeLength * 0.3, edgeLength * 0.4, edgeLength * 0.4, edgeLength * 0.4)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#eee'
				context.arc(edgeLength * 0.5, edgeLength * 0.6, edgeLength * 0.18, 0, 2*Math.PI, true)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#eee'
				// context.lineWidth = edgeLength * 0.02
				context.rect(edgeLength * 0.45, 0, edgeLength * 0.1, edgeLength * 0.5)
				context.fill()
				context.stroke()
				context.beginPath()
				// 炮塔
				// 星级
				context.fill()
				context.stroke()
				context.restore()
			}
		}
		let tankOffset = new OffsetCanvasSprite({name: 'tankOffsetSprite'}, tankOffsetPainter, [], edgeLength, edgeLength)
		tankOffset.setDirection({x: 1, y: 0})
		tankOffset.setDirection({x: 0, y: -1})
		tankOffset.setDirection({x: -1, y: 0})
		tankOffset.setDirection(new Vector(1, 0))
		// 四个方向的tank
		context.drawImage(tankOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLength, 70, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(0, -1)), 0, 0, edgeLength, edgeLength, 130, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas({x: 0, y: -1}), 0, 0, edgeLength, edgeLength, 130, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(-1, 0)), 0, 0, edgeLength, edgeLength, 190, 10, edgeLength * 0.1, edgeLength * 0.1)

		let brickPainter = {
			paint: (sprite, context) => {
				context.save()
				// 第一行
				context.fillStyle = '#9b3d3d'
				context.strokeStyle = '#333'
				context.lineWidth = edgeLength * 0.01
				context.beginPath()
				context.moveTo(0, 0)
				context.lineTo(edgeLength * 0.25, 0)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.25)
				context.lineTo(0, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.rect(edgeLength * 0.25, 0, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.moveTo(edgeLength, 0)
				context.lineTo(edgeLength * 0.75, 0)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.25)
				context.lineTo(edgeLength, edgeLength * 0.25)
				context.fill()
				context.stroke()
				// 第二行
				context.beginPath()
				context.rect(0, edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.25)
				context.rect(edgeLength * 0.5, edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				// 第三行
				context.beginPath()
				context.moveTo(0, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.75)
				context.lineTo(0, edgeLength * 0.75)
				context.fill()
				context.stroke()
				context.beginPath()
				context.rect(edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.moveTo(edgeLength, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.75)
				context.lineTo(edgeLength, edgeLength * 0.75)
				context.fill()
				context.stroke()
				// 第四行
				context.beginPath()
				context.rect(0, edgeLength * 0.75, edgeLength * 0.5, edgeLength * 0.25)
				context.rect(edgeLength * 0.5, edgeLength * 0.75, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.restore()
			}
		}
		let brickOffset = new OffsetCanvasSprite({name: 'brick'}, brickPainter, [], edgeLength, edgeLength)
		// 砖头
		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 80, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 70, 80, edgeLength * 0.1, edgeLength * 0.1)

		let shellPainter = {
			paint: (sprite, context) => {
				// 只绘制正方向的一个图形。
				// 在使用图形时旋转。
				if (sprite.direction.x === 0 && sprite.direction.y === 1) {
					let lineWidth = sprite.width * 0.15
					let lineWidthHalf = lineWidth / 2
					let [linerBoxX, linerBoxY, linerBoxW, linerBoxH] = [lineWidthHalf, lineWidthHalf, sprite.width - lineWidthHalf, sprite.height - lineWidthHalf]
					context.save()				
					context.fillStyle = '#dee3eb'
					context.strokeStyle = '#333'
					context.lineWidth = lineWidth
					context.beginPath()
					// context.moveTo(edgeLength * 0.25, edgeLength)
					// context.lineTo(edgeLength * 0.25, edgeLength * 0.5)
					// context.quadraticCurveTo(edgeLength * 0.25, 0, edgeLength * 0.5, 0)
					// context.quadraticCurveTo(edgeLength * 0.75, 0, edgeLength * 0.75, edgeLength * 0.5)
					// context.lineTo(edgeLength * 0.75, edgeLength)

					// context.moveTo(sprite.left + lineWidthHalf, sprite.top + sprite.height - lineWidthHalf)
					// context.lineTo(sprite.left + lineWidthHalf, sprite.top + sprite.height * 0.5)
					// context.quadraticCurveTo(sprite.left + lineWidthHalf, sprite.top + lineWidthHalf, sprite.left + sprite.width * 0.5, sprite.top + lineWidthHalf)
					// context.quadraticCurveTo(sprite.left + sprite.width - lineWidthHalf, sprite.top + lineWidthHalf, sprite.left + sprite.width - lineWidthHalf, sprite.top + sprite.height * 0.5)
					// context.lineTo(sprite.left + sprite.width - lineWidthHalf, sprite.top + sprite.height - lineWidthHalf)

					context.moveTo(linerBoxX, linerBoxH)
					context.lineTo(linerBoxX, linerBoxH / 2)
					context.quadraticCurveTo(linerBoxX, linerBoxY, linerBoxW / 2, linerBoxY)
					context.quadraticCurveTo(linerBoxW, linerBoxY, linerBoxW, linerBoxH / 2)
					context.lineTo(linerBoxW, linerBoxH)
					context.closePath()
					context.fill()
					context.stroke()
					context.restore()
					// paintBorder(context, 50)
				} else if (this.direction.x === 1 && this.direction.y === 0) {
					// paintFill(context)
					log('1, 0', 'strin')
				} else if (this.direction.x === 0 && this.direction.y === -1) {
					log('0, -1', 'sdfa')
				} else if (this.direction.x === -1 && this.direction.y === 0) {
					log('-1, 0', 'sdfe')
				}
			}
		}
		let shellOffset = new OffsetCanvasSprite({
			name: 'shell',
			width: edgeLengthHalf,
			height: edgeLength,
		}, shellPainter, [], edgeLength, edgeLength)
		shellOffset.setDirection(new Vector(1, 0))
		shellOffset.setDirection(new Vector(0, -1))
		shellOffset.setDirection(new Vector(-1, 0))
		// 炮弹
		context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, 10, 150, edgeLengthHalf * 0.1, edgeLength * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, 70, 150, edgeLength * 0.1, edgeLengthHalf * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, 130, 150, edgeLengthHalf * 0.1, edgeLength * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, 190, 150, edgeLength * 0.1, edgeLengthHalf * 0.1)
		context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, 10, 220, edgeLengthHalf * 0.025, edgeLength * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, 70, 220, edgeLength * 0.025, edgeLengthHalf * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, 130, 220, edgeLengthHalf * 0.025, edgeLength * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, 190, 220, edgeLength * 0.025, edgeLengthHalf * 0.025)

		// 绘制静态画面
		// paintFill()
		paintBorder()



		



		class ShellSprite extends Sprite {
			constructor(spriteOpt, painter, behaviors, category) {
				super(spriteOpt, painter, behaviors, category)
				this.level = spriteOpt.level || 0
			}
		}
		class tankSprite extends Sprite{
			constructor(spriteOpt, painter, behaviors, category) {
				super(spriteOpt, painter, behaviors, category)
				this.level = spriteOpt.level || 0
			}
			fire() {
				let v = 0
				switch(this.level) {
					case 0:
					default:
						v = 45 // new Vector()
						break
					case 1:
						v = 60
						break
					case 2:
						v = 70
						break
					case 3:
						v = 80
						break
				}
				v = new Vector(this.direction.x * v, -this.direction.y * v)
				let shellW = edgeLength * 0.025 * 0.5
				let shellH = shellW * 2
				let l // = this.left + this.width * 0.5 - shellW * 0.5
				let t // = this.top
				let shellDirction = new Vector(this.direction.x, this.direction.y)
				// 起始位置在炮管中
				// if (this.direction.x === 0 && this.direction.y === 1) {
				// 	l = this.left + this.width * 0.5 - shellW * 0.5
				// 	t = this.top
				// } else if (this.direction.x === 1 && this.direction.y === 0) {
				// 	l = this.left + this.height - shellH
				// 	t = this.top + this.height * 0.5 - shellW * 0.5
				// } else if (this.direction.x === 0 && this.direction.y === -1) {
				// 	l = this.left + this.width * 0.5 - shellW * 0.5
				// 	t = this.top + this.height - shellH
				// } else if (this.direction.x === -1 && this.direction.y === 0) {
				// 	l = this.left
				// 	t = this.top + this.height * 0.5 - shellW * 0.5
				// }
				// 起始位置在炮管前
				if (this.direction.x === 0 && this.direction.y === 1) {
					l = this.left + this.width * 0.5 - shellW * 0.5
					t = this.top - shellH
				} else if (this.direction.x === 1 && this.direction.y === 0) {
					l = this.left + this.height
					t = this.top + this.height * 0.5 - shellW * 0.5
				} else if (this.direction.x === 0 && this.direction.y === -1) {
					l = this.left + this.width * 0.5 - shellW * 0.5
					t = this.top + this.height
				} else if (this.direction.x === -1 && this.direction.y === 0) {
					l = this.left - shellH
					t = this.top + this.height * 0.5 - shellW * 0.5
				}
				return new ShellSprite({
					name: 'shell' + Math.floor(Math.random() * 10000),
					top: t, // this.top,
					left: l, // this.left,
					width: shellW, // this.width * 0.5,
					height: shellH, // this.height,
					v,
					direction: this.direction,
					animating: true,
					crashGraphPoints: [new Point(l, t), new Point(l + shellW, t), new Point(l + shellW, t + shellH), new Point(l, t + shellH)]
				},
				// shellPainter,
				{
					paint: (sprite, context) => {
						// context.drawImage(shellOffset.getCanvas(sprite.direction), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
						let {x, y} = sprite.direction
						if (x === 0 && y == 1) {
							context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, sprite.left, sprite.top, edgeLengthHalf * 0.025, edgeLength * 0.025)
						} else if (x === 1 && y === 0) {
							context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, sprite.left, sprite.top, edgeLength * 0.025, edgeLengthHalf * 0.025)
						} else if (x === 0 && y === -1) {
							context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, sprite.left, sprite.top, edgeLengthHalf * 0.025, edgeLength * 0.025)
						} else {
							context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, sprite.left, sprite.top, edgeLength * 0.025, edgeLengthHalf * 0.025)
						}
					}
				},
				[{
					execute: (sprite, context, fps) => {
						// 修改可见图形位置
						sprite.left += sprite.v.x * fps / 1000
						sprite.top += sprite.v.y * fps / 1000
						if (sprite.left > edgeLength - sprite.width || sprite.left < 0 || sprite.top < 0 || sprite.top > edgeLength - sprite.height) {
							// sprite.visible = false
							sprite.animating = false
							game.removeSprite(sprite)
						}
						// 修改碰撞图形位置
						sprite.crashGraphPoints = [
							new Point(sprite.left, sprite.top),
							new Point(sprite.left + sprite.width, sprite.top),
							new Point(sprite.left + sprite.width, sprite.top + sprite.height),
							new Point(sprite.left, sprite.top + sprite.height)
						]
					}
				}], 'shell')
			}
		}
		class brickSprite extends Sprite {
			constructor(spriteOpt, painter, behaviors, category) {
				super(spriteOpt, painter, behaviors, category)
			}
		}
		let tankPainter = {
			paint: (sprite, context) => {
				context.drawImage(tankOffset.getCanvas(sprite.direction), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}
		let tankBehaviors = [{
			execute: (sprite, context, fps) => {
				// sprite.move({x: sprite.v.x * fps / 1000, y: sprite.v.y * fps / 1000})
				// // 修改可见图形位置
				sprite.left += sprite.v.x * fps / 1000
				sprite.top += sprite.v.y * fps / 1000
				if (sprite.left > edgeLength - sprite.width) {
					sprite.left = edgeLength - sprite.width
				}
				if (sprite.top > edgeLength - sprite.width) {
					sprite.top = edgeLength - sprite.width
				}
				if (sprite.left < 0) {
					sprite.left = 0
				}
				if (sprite.top < 0) {
					sprite.top = 0
				}
				// 修改碰撞图形位置
				sprite.crashGraphPoints = [
					new Point(sprite.left, sprite.top),
					new Point(sprite.left + sprite.width, sprite.top),
					new Point(sprite.left + sprite.width, sprite.top + sprite.height),
					new Point(sprite.left, sprite.top + sprite.height),
				]
			}
		}]
		let tank0 = new tankSprite({
			name: 'tank0',
			left: edgeLength05,
			top: edgeLength09,
			// left: edgeLength08 + edgeLength01 * 0.5,
			// top: edgeLength05 + edgeLength01 * 0.5,
			width: edgeLength01,
			height: edgeLength01,
			v: new Vector(0, 0),
			crashGraphPoints: [
				new Point(edgeLength05, edgeLength09),
				new Point(edgeLength06, edgeLength09),
				new Point(edgeLength06, edgeLength),
				new Point(edgeLength05, edgeLength),
				// new Point(edgeLength08 + edgeLength01 * 0.5, edgeLength05 + edgeLength01 * 0.5), 
				// new Point(edgeLength09 + edgeLength01 * 0.5, edgeLength05 + edgeLength01 * 0.5), 
				// new Point(edgeLength09 + edgeLength01 * 0.5, edgeLength06 + edgeLength01 * 0.5), 
				// new Point(edgeLength08 + edgeLength01 * 0.5, edgeLength06 + edgeLength01 * 0.5),
			]
		}, tankPainter, tankBehaviors, 'tank')
		let tank1 = new tankSprite({
			name: 'tank1',
			left: edgeLength04,
			top: 0,
			width: edgeLength01,
			height: edgeLength01,
			v: new Vector(0, 0),
			direction: new Vector(0, -1),
			crashGraphPoints: [
				new Point(edgeLength04, 0),
				new Point(edgeLength05, 0),
				new Point(edgeLength05, edgeLength01),
				new Point(edgeLength04, edgeLength01),
			]
		}, tankPainter, tankBehaviors, 'tank')
		let brick0 = new brickSprite({
			name: 'brick0',
			left: edgeLength04,
			top: edgeLength04,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [new Point(edgeLength04, edgeLength04), new Point(edgeLength04 + edgeLength01, edgeLength04), new Point(edgeLength04 + edgeLength01, edgeLength04 + edgeLength01), new Point(edgeLength04, edgeLength04 + edgeLength01)]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let brick1 = new brickSprite({
			name: 'brick1',
			left: edgeLength05,
			top: edgeLength04,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength05, edgeLength04),
				new Point(edgeLength06, edgeLength04),
				new Point(edgeLength06, edgeLength05),
				new Point(edgeLength05, edgeLength05),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let brick2 = new brickSprite({
			name: 'brick2',
			left: edgeLength04,
			top: edgeLength05,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength04, edgeLength05),
				new Point(edgeLength05, edgeLength05),
				new Point(edgeLength05, edgeLength06),
				new Point(edgeLength04, edgeLength06)
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let brick3 = new brickSprite({
			name: 'brick3',
			left: edgeLength05,
			top: edgeLength05,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength05, edgeLength05), 
				new Point(edgeLength06, edgeLength05), 
				new Point(edgeLength06, edgeLength06), 
				new Point(edgeLength05, edgeLength06), 
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let brick4 = new brickSprite({
			name: 'brick4',
			left: edgeLength09,
			top: edgeLength05,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength09, edgeLength05), 
				new Point(edgeLength, edgeLength05), 
				new Point(edgeLength, edgeLength06), 
				new Point(edgeLength09, edgeLength06), 
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		
		class GameTank extends Game {
			constructor(gameName, canvasId, effectDraw,
			option = {
				showTime: false
			}, crashCb) {
				super(gameName, canvasId, effectDraw, option = {showTime: false}, crashCb)
			}
			detectCrash() {
				let tankList = this.spritesCategory.get('tank') || []
				let shellList = this.spritesCategory.get('shell') || []
				let brickList = this.spritesCategory.get('brick') || []
				// shell vs brick+tank
				let shellCrashedObjList = shellList.map(shell => {
					let crashedObjList = brickList.concat(tankList).filter(item => item.crashGraph.collidesWith(shell.crashGraph))
					if (crashedObjList.length) {
						return {
							origin: shell,
							targets: crashedObjList
						}
					} else {
						return
					}
				}).filter(item => item)
				// tank vs brick
				let tankCrashedObjList = tankList.map(tank => {
					let crashedObjList = brickList.filter(item => item.crashGraph.collidesWith(tank.crashGraph))
					if (crashedObjList.length) {
						return {origin: tank, targets: crashedObjList}
					} else {
						return
					}
				}).filter(item => item)
				if (shellCrashedObjList.length || tankCrashedObjList.length) {
					// this.crashCb(shellCrashedObjList, tankCrashedObjList)
					this.crashCb(shellCrashedObjList.concat(tankCrashedObjList))
				}
			}
		}
		let centerPoint = (left, top, width, height) => {
			return new Point(left + width, top + height)
		}
		let crashCb = (crashedObjList) => {
			crashedObjList.map(({origin, targets}) => {
				switch (origin.category) {
					case 'tank':
						// 让坦克退回去
						if (!origin.v.magnitude()) { break }
						let overlapMList
						// 分水平、竖直
						if (origin.v.x === 0 && origin.v.y) { // 竖直
							overlapMList = targets.map(target => {
								let shouldM = target.height
								let realM = Math.abs(target.top - origin.top)
								let overlapM = shouldM - realM
								return overlapM
							})
						} else if (origin.v.x && origin.v.y === 0) { // 水平
							overlapMList = targets.map(target => {
								let shouldM = target.width
								let realM = Math.abs(target.left - origin.left)
								let overlapM = shouldM - realM
								return overlapM
							})
						}
						// 取最大重叠量
						let m = Math.max.apply(null, overlapMList)
						// 移动
						origin.move(origin.v.opposite().setMagnitude(m))
						break
					case 'shell':
						// 爆炸
						game.removeSprite(origin)
						targets.forEach(t => game.removeSprite(t))
						break
				}
			})
		}
		let game = new GameTank('tank90', '#canvas', paintBorder, {
			showTime: false
		}, crashCb)
		game.setSprite(tank0)
		game.setSprite(tank1)
		game.setSprite(brick0)
		game.setSprite(brick1)
		game.setSprite(brick2)
		game.setSprite(brick3)
		game.setSprite(brick4)
		game.setKeyListener(38, (e) => {
			tank0.animating = true
			tank0.v = new Vector(0, -30)
			tank0.direction = new Vector(0, 1)
		}, true)
		game.setKeyListener(38, (e) => {
			tank0.animating = true
			tank0.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(40, (e) => {
			tank0.animating = true
			tank0.v = new Vector(0, 30)
			tank0.direction = new Vector(0, -1)
		})
		game.setKeyListener(40, (e) => {
			tank0.animating = true
			tank0.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(37, (e) => {
			tank0.animating = true
			tank0.v = new Vector(-30, 0)
			tank0.direction = new Vector(-1, 0)
		})
		game.setKeyListener(37, (e) => {
			tank0.animating = true
			tank0.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(39, (e) => {
			tank0.animating = true
			tank0.v = new Vector(30, 0)
			tank0.direction = new Vector(1, 0)
		})
		game.setKeyListener(39, (e) => {
			tank0.animating = true
			tank0.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(32, (e) => {
			game.setSprite(tank0.fire())
		})

		// a
		game.setKeyListener(65, (e) => {
			tank1.animating = true
			tank1.v = new Vector(-30, 0)
			tank1.direction = new Vector(-1, 0)
		})
		game.setKeyListener(65, (e) => {
			tank1.animating = true // false
			tank1.v = new Vector(0, 0)
		}, false)
		// s
		game.setKeyListener(83, (e) => {
			tank1.animating = true
			tank1.v = new Vector(0, 30)
			tank1.direction = new Vector(0, -1)
		})
		game.setKeyListener(83, (e) => {
			tank1.animating = true // false
			tank1.v = new Vector(0, 0)
		}, false)
		// d
		game.setKeyListener(68, (e) => {
			tank1.animating = true
			tank1.v = new Vector(30, 0)
			tank1.direction = new Vector(1, 0)
		})
		game.setKeyListener(68, (e) => {
			tank1.animating = true // false
			tank1.v = new Vector(0, 0)
		}, false)
		// w
		game.setKeyListener(87, (e) => {
			tank1.animating = true
			tank1.v = new Vector(0, -30)
			tank1.direction = new Vector(0, 1)
		})
		game.setKeyListener(87, (e) => {
			tank1.animating = true // false
			tank1.v = new Vector(0, 0)
		}, false)
		game.setKeyListener(70, (e) => {
			game.setSprite(tank1.fire())
		})
		// let drawMap = () => {
		// 	// log('drawMap')
		// }
		// let draw = () => {
		// 	log('draw')
		// 	paintBorder()
		// 	// drawMap()
		// 	tank.update(context, fps)
		// 	tank.paint(context)
		// }
		// let animate = (time) => {
		// 	context.clearRect(0, 0, edgeLength, edgeLength)
		// 	fps = calcFps()
		// 	draw()
		// 	animateId = requestNextAnimateionFrame(animate)
		// }
		let start = () => {
			// animateId = requestNextAnimateionFrame(animate)
			game.start()
			// game.detectCrash()
			// triangle.collidesWith(quadrangle)
			// log(brick4)
			// log(tank)
			// log(brick4.crashGraph.collidesWith(tank.crashGraph))
			// log(brick3.crashGraph.collidesWith(tank.crashGraph))

		}
		let stop = () => {
			// game.end()
			game.animating = false
			paintStop()
			// game.animating = false
			// game.start()
			// cancelNextAnimationFrame(animateId)
		}
		let flag = false
		canvas.onclick = (e) => {
			flag = !flag
			if (flag) {
				start()
			} else {
				stop()
			}
		}
		window.onblur = (e) => {
			if (flag) {
				flag = false
				stop()
			}
		}

		log(game)

		// log(tankOffset)

	</script>
</body>
</html>