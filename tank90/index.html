<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>90 tank</title>
	<style type="text/css">
		body {
			margin: 0;
			width: 100vw;
			height: 100vh;
		}
		#canvas {
			margin: 0 auto;
			display: block;
			/*border: 1px solid #234;*/
			box-sizing: border-box;
		}
	</style>
</head>
<body>
	<canvas id="canvas">您的浏览器不支持本游戏！
		创建一个系统的规则比较困难。不知道什么样的规则才是合适的。
	</canvas>
	<a href="/tank90/readme.html">readme</a>
	<script type="text/javascript" src="./canvasCore.js"></script>
	<script type="text/javascript">
		/*
		tank发射炮弹的速率
		游戏参数可以设置
		结束游戏
		*/
		let canvas = document.querySelector('#canvas')
		let context = canvas.getContext('2d')
		let {log} = console
		let bodyDom = document.querySelector('body')
		let [bodyW, bodyH] = [bodyDom.clientWidth, bodyDom.clientHeight]
		let edgeLength = Math.min(bodyW, bodyH)
		let edgeLengthHalf = edgeLength * 0.5
		let [edgeLength01, edgeLength02, edgeLength03, edgeLength04, edgeLength05, edgeLength06, edgeLength07, edgeLength08, edgeLength09] = [edgeLength * 0.1, edgeLength * 0.2, edgeLength * 0.3, edgeLength * 0.4, edgeLength * 0.5, edgeLength * 0.6, edgeLength * 0.7, edgeLength * 0.8, edgeLength * 0.9]
		let edgeLengthStone = edgeLength01 * 0.5
		canvas.width = edgeLength
		canvas.height = edgeLength

		let tankCanvas = document.createElement('canvas')
		tankCanvas.width = edgeLength
		tankCanvas.height = edgeLength
		let tankContext = tankCanvas.getContext('2d')
		let paintBorder = (ctx = context, lineWidth = 1) => {
			// log(ctx)
			ctx.save()
			ctx.lineWidth = lineWidth
			ctx.beginPath()
			ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)
			ctx.closePath()
			// // ctx.fillStyle = 'grey'
			ctx.strokeStyle = 'red'
			// // ctx.fill()
			ctx.stroke()
			ctx.restore()
			
		}
		let paintTank0Point = (ctx = context) => {
			ctx.save()
			// log(tank0.left, tank0.top)
			ctx.beginPath()
			ctx.rect(tank0.left - 2, tank0.top - 2, 4, 4)
			ctx.fillStyle = 'grey'
			ctx.closePath()
			ctx.fill()
			ctx.restore()
		}
		let paintFill = (ctx = context, fillStyle = 'grey') => {
			ctx.save()
			// log('ain')
			// ctx.lineWidth = lineWidth
			ctx.beginPath()
			ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height)
			// ctx.closePath()
			ctx.fillStyle = fillStyle
			// ctx.strokeStyle = 'red'
			ctx.fill()
			// ctx.stroke()
			ctx.restore()
		}
		let paintStop = (ctx = context, fillStyle = 'red') => {
			let [cw, ch] = [ctx.canvas.width, ctx.canvas.height]
			ctx.save()
			ctx.rect(0, 0, cw, ch)
			ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'
			ctx.fill()
			ctx.beginPath()
			ctx.fillStyle = fillStyle
			ctx.textAlign = 'center'
			ctx.font = '100px serif'
			ctx.fillText('stop', cw * 0.5, ch * 0.5)
			// ctx.fill()
			// ctx.stroke()
			ctx.restore()
		}
		let paintEnd = (ctx = context, winner) => {
			ctx.save()
			let [cw, ch] = [ctx.canvas.width, ctx.canvas.height]
			ctx.rect(0, 0, cw, ch)
			ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'
			ctx.fill()
			ctx.beginPath()
			ctx.fillStyle = 'red'
			ctx.textAlign = 'center'
			ctx.font = '100px serif'
			// ctx.rect(0, 0, cw, ch)
			// ctx.fillText('winner', cw * 0.5, ch * 0.5)
			ctx.fillText(`winner: \n${winner}`, cw * 0.5, ch * 0.5)
			ctx.restore()
		}

		let tankOffsetPainter = {
			paint: (sprite, context) => {
				context.save()
				// 底壳
				context.strokeStyle = '#222'
				context.beginPath()
				context.rect(edgeLength * 0.1, edgeLength * 0.1, edgeLength * 0.8, edgeLength * 0.85)
				context.fillStyle = '#333'
				context.fill()
				context.stroke()
				// 履带
				context.beginPath()
				context.fillStyle = '#666'
				context.rect(0, 0, edgeLength * 0.25, edgeLength)
				context.rect(edgeLength * 0.75, 0, edgeLength * 0.25, edgeLength)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#777'
				context.rect(edgeLength * 0.025, edgeLength * 0.05, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.24, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.43, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.62, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.025, edgeLength * 0.81, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.05, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.24, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.43, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.62, edgeLength * 0.2, edgeLength * 0.1)
				context.rect(edgeLength * 0.775, edgeLength * 0.81, edgeLength * 0.2, edgeLength * 0.1)
				context.fill()
				context.stroke()
				// 机舱
				context.beginPath()
				context.fillStyle = '#bbb'
				context.rect(edgeLength * 0.1, edgeLength * 0.15, edgeLength * 0.8, edgeLength * 0.8)
				context.fill()
				context.stroke()
				// 炮塔
				context.beginPath()
				context.fillStyle = '#ddd'
				context.rect(edgeLength * 0.3, edgeLength * 0.4, edgeLength * 0.4, edgeLength * 0.4)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#eee'
				context.arc(edgeLength * 0.5, edgeLength * 0.6, edgeLength * 0.18, 0, 2*Math.PI, true)
				context.fill()
				context.stroke()
				context.beginPath()
				context.fillStyle = '#eee'
				// context.lineWidth = edgeLength * 0.02
				context.rect(edgeLength * 0.45, 0, edgeLength * 0.1, edgeLength * 0.5)
				context.fill()
				context.stroke()
				context.beginPath()
				// 炮塔
				// 星级
				context.fill()
				context.stroke()
				context.restore()
			}
		}
		let tankOffset = new OffsetCanvasSprite({name: 'tankOffsetSprite'}, tankOffsetPainter, [], edgeLength, edgeLength)
		tankOffset.setDirection({x: 1, y: 0})
		tankOffset.setDirection({x: 0, y: -1})
		tankOffset.setDirection({x: -1, y: 0})
		tankOffset.setDirection(new Vector(1, 0))
		// 四个方向的tank
		context.drawImage(tankOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLength, 70, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(0, -1)), 0, 0, edgeLength, edgeLength, 130, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas({x: 0, y: -1}), 0, 0, edgeLength, edgeLength, 130, 10, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(tankOffset.getCanvas(new Vector(-1, 0)), 0, 0, edgeLength, edgeLength, 190, 10, edgeLength * 0.1, edgeLength * 0.1)

		let brickPainter = {
			paint: (sprite, context) => {
				context.save()
				// 第一行
				context.fillStyle = '#9b3d3d'
				context.strokeStyle = '#333'
				context.lineWidth = edgeLength * 0.01
				context.beginPath()
				context.moveTo(0, 0)
				context.lineTo(edgeLength * 0.25, 0)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.25)
				context.lineTo(0, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.rect(edgeLength * 0.25, 0, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.moveTo(edgeLength, 0)
				context.lineTo(edgeLength * 0.75, 0)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.25)
				context.lineTo(edgeLength, edgeLength * 0.25)
				context.fill()
				context.stroke()
				// 第二行
				context.beginPath()
				context.rect(0, edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.25)
				context.rect(edgeLength * 0.5, edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				// 第三行
				context.beginPath()
				context.moveTo(0, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.25, edgeLength * 0.75)
				context.lineTo(0, edgeLength * 0.75)
				context.fill()
				context.stroke()
				context.beginPath()
				context.rect(edgeLength * 0.25, edgeLength * 0.5, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.beginPath()
				context.moveTo(edgeLength, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.5)
				context.lineTo(edgeLength * 0.75, edgeLength * 0.75)
				context.lineTo(edgeLength, edgeLength * 0.75)
				context.fill()
				context.stroke()
				// 第四行
				context.beginPath()
				context.rect(0, edgeLength * 0.75, edgeLength * 0.5, edgeLength * 0.25)
				context.rect(edgeLength * 0.5, edgeLength * 0.75, edgeLength * 0.5, edgeLength * 0.25)
				context.fill()
				context.stroke()
				context.restore()
			}
		}
		let brickOffset = new OffsetCanvasSprite({name: 'brick'}, brickPainter, [], edgeLength, edgeLength)
		// 砖头
		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 80, edgeLength * 0.1, edgeLength * 0.1)
		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 70, 80, edgeLength * 0.1, edgeLength * 0.1)

		let shellPainter = {
			paint: (sprite, context) => {
				// 只绘制正方向的一个图形。
				// 在使用图形时旋转。
				if (sprite.direction.x === 0 && sprite.direction.y === 1) {
					let lineWidth = sprite.width * 0.15
					let lineWidthHalf = lineWidth / 2
					let [linerBoxX, linerBoxY, linerBoxW, linerBoxH] = [lineWidthHalf, lineWidthHalf, sprite.width - lineWidthHalf, sprite.height - lineWidthHalf]
					context.save()				
					context.fillStyle = '#dee3eb'
					context.strokeStyle = '#333'
					context.lineWidth = lineWidth
					context.beginPath()
					// context.moveTo(edgeLength * 0.25, edgeLength)
					// context.lineTo(edgeLength * 0.25, edgeLength * 0.5)
					// context.quadraticCurveTo(edgeLength * 0.25, 0, edgeLength * 0.5, 0)
					// context.quadraticCurveTo(edgeLength * 0.75, 0, edgeLength * 0.75, edgeLength * 0.5)
					// context.lineTo(edgeLength * 0.75, edgeLength)

					// context.moveTo(sprite.left + lineWidthHalf, sprite.top + sprite.height - lineWidthHalf)
					// context.lineTo(sprite.left + lineWidthHalf, sprite.top + sprite.height * 0.5)
					// context.quadraticCurveTo(sprite.left + lineWidthHalf, sprite.top + lineWidthHalf, sprite.left + sprite.width * 0.5, sprite.top + lineWidthHalf)
					// context.quadraticCurveTo(sprite.left + sprite.width - lineWidthHalf, sprite.top + lineWidthHalf, sprite.left + sprite.width - lineWidthHalf, sprite.top + sprite.height * 0.5)
					// context.lineTo(sprite.left + sprite.width - lineWidthHalf, sprite.top + sprite.height - lineWidthHalf)

					context.moveTo(linerBoxX, linerBoxH)
					context.lineTo(linerBoxX, linerBoxH / 2)
					context.quadraticCurveTo(linerBoxX, linerBoxY, linerBoxW / 2, linerBoxY)
					context.quadraticCurveTo(linerBoxW, linerBoxY, linerBoxW, linerBoxH / 2)
					context.lineTo(linerBoxW, linerBoxH)
					context.closePath()
					context.fill()
					context.stroke()
					context.restore()
					// paintBorder(context, 50)
				} else if (this.direction.x === 1 && this.direction.y === 0) {
					// paintFill(context)
					log('1, 0', 'strin')
				} else if (this.direction.x === 0 && this.direction.y === -1) {
					log('0, -1', 'sdfa')
				} else if (this.direction.x === -1 && this.direction.y === 0) {
					log('-1, 0', 'sdfe')
				}
			}
		}
		let shellOffset = new OffsetCanvasSprite({
			name: 'shell',
			width: edgeLengthHalf,
			height: edgeLength,
		}, shellPainter, [], edgeLength, edgeLength)
		shellOffset.setDirection(new Vector(1, 0))
		shellOffset.setDirection(new Vector(0, -1))
		shellOffset.setDirection(new Vector(-1, 0))
		// 炮弹
		context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, 10, 150, edgeLengthHalf * 0.1, edgeLength * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, 70, 150, edgeLength * 0.1, edgeLengthHalf * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, 130, 150, edgeLengthHalf * 0.1, edgeLength * 0.1)
		context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, 190, 150, edgeLength * 0.1, edgeLengthHalf * 0.1)
		context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, 10, 220, edgeLengthHalf * 0.025, edgeLength * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, 70, 220, edgeLength * 0.025, edgeLengthHalf * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, 130, 220, edgeLengthHalf * 0.025, edgeLength * 0.025)
		context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, 190, 220, edgeLength * 0.025, edgeLengthHalf * 0.025)
		// 石头
		let stoneOffsetPainter = {
			paint: (sprite, context) => {
				context.save()
				let grd
				grd = context.createLinearGradient(0, 0, sprite.width * 0.5, 0)
				context.fillStyle = 'gray'
				context.strokeStyle = '#333'
				// 
				context.beginPath()
				grd.addColorStop(0, '#777')
				grd.addColorStop(1, '#fff')
				context.moveTo(0, 0)
				context.lineTo(sprite.width * 0.5, sprite.height * 0.5)
				context.lineTo(0, sprite.height)
				context.fillStyle = grd
				context.fill()
				context.closePath()
				// 
				context.beginPath()
				grd = context.createLinearGradient(sprite.width * 0.5, 0, sprite.width, 0)
				grd.addColorStop(0, '#fff')
				grd.addColorStop(1, '#777')
				context.moveTo(sprite.width, 0)
				context.lineTo(sprite.width * 0.5, sprite.height * 0.5)
				context.lineTo(sprite.width, sprite.height)
				context.fillStyle = grd
				context.fill()
				context.closePath()
				// 
				context.beginPath()
				grd = context.createLinearGradient(0, 0, 0, sprite.height * 0.5)
				grd.addColorStop(0, '#777')
				grd.addColorStop(1, '#fff')
				context.moveTo(0, 0)
				context.lineTo(sprite.width * 0.5, sprite.height * 0.5)
				context.lineTo(sprite.width, 0)
				context.fillStyle = grd
				context.fill()
				context.closePath()
				// 
				context.beginPath()
				grd = context.createLinearGradient(0, sprite.height * 0.5, 0, sprite.height)
				grd.addColorStop(0, '#fff')
				grd.addColorStop(1, '#777')
				context.moveTo(0, sprite.height)
				context.lineTo(sprite.width * 0.5, sprite.height * 0.5)
				context.lineTo(sprite.width, sprite.height)
				context.fillStyle = grd
				context.fill()
				context.closePath()
				context.beginPath()
				context.rect(sprite.width * 0.2, sprite.height * 0.2, sprite.width * 0.6, sprite.height * 0.6)
				context.fillStyle = '#ddd'
				context.fill()
				context.restore()
			}
		}
		let stoneOffset = new OffsetCanvasSprite({
			name: 'stoneOffset',
			width: edgeLength,
			height: edgeLength,
		}, stoneOffsetPainter, [], edgeLength, edgeLength)
		// context.drawImage(stoneOffset.getCanvas(), 0,0, edgeLength, edgeLength, 0, 0, edgeLength, edgeLength)
		context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 290, edgeLength01 * 0.5, edgeLength01 * 0.5)
		context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 70, 290, edgeLength01 * 0.5, edgeLength01 * 0.5)
		// surprise
		let starOffsetPainter = {
			paint: (sprite, context) => {
				let lineWidth = sprite.width * 0.02
				context.save()
				context.fillStyle = 'orange'
				context.strokeStyle = '#333'
				context.lineWidth = lineWidth
				// 利用非零原则
				context.beginPath()
				context.moveTo(0, edgeLength05 * 0.7)
				context.lineTo(edgeLength, edgeLength05 * 0.7)
				context.lineTo(edgeLength05 * 0.4, edgeLength)
				context.lineTo(edgeLength05, 0)
				context.lineTo(edgeLength - edgeLength05 * 0.4, edgeLength)
				context.closePath()
				context.fill()
				context.stroke()
				context.restore()
			}
		}
		let starOffset = new OffsetCanvasSprite({
			name: 'starOffset',
			width: edgeLength,
			height: edgeLength,
		}, starOffsetPainter, [], edgeLength, edgeLength)
		context.drawImage(starOffset.getCanvas(), 0, 0, edgeLength, edgeLength, 10, 360, edgeLength01, edgeLength01)
		// 绘制静态画面
		// paintFill()
		paintBorder()



		



		class ShellSprite extends Sprite {
			constructor(spriteOpt, painter, behaviors, category) {
				super(spriteOpt, painter, behaviors, category)
				this.level = spriteOpt.level || 0
				this.origin = spriteOpt.origin
				// 可把v设置为不可修改的
				switch (this.level) {
					case 0:
					default:
						this.v = new Vector(this.direction.x, -this.direction.y).setMagnitude(60)
						break
					case 1:
						this.v = new Vector(this.direction.x, -this.direction.y).setMagnitude(80)
						break
					case 2:
						this.v = new Vector(this.direction.x, -this.direction.y).setMagnitude(100)
						break
					case 3:
						this.v = new Vector(this.direction.x, -this.direction.y).setMagnitude(120)
						break
				}
			}
		}
		class TankSprite extends Sprite{
			constructor(spriteOpt, painter, behaviors, category) {
				super(spriteOpt, painter, behaviors, category)
				this._level = spriteOpt.level || 0
				this.level = this._level
				switch (spriteOpt.level) {
					case 0:
					default:
						this.vm = 30
						break
					case 1:
						this.vm = 45
						break
					case 2:
						this.vm = 60
						break
					case 3:
						this.vm = 70
						break
				}
				// init width / height
				// this.width = edgeLength01 * (1 + this.level / 10)
				// this.height = this.width
				// init crashGraphPoints
				// this.crashGraphPoints = [
				// 	new Point(this.left, this.top),
				// 	new Point(this.left + this.width, this.top),
				// 	new Point(this.left + this.width, this.top + this.height),
				// 	new Point(this.left, this.top + this.height),
				// ]
			}
			get level () {
				return this._level
			}
			set level (v) {
				this._level = v
				this.width = edgeLength01 * (1 + this._level / 10)
				this.height = this.width
				this.crashGraphPoints = [
					new Point(this.left, this.top),
					new Point(this.left + this.width, this.top),
					new Point(this.left + this.width, this.top + this.height),
					new Point(this.left, this.top + this.height)
				]
			}
			launch(vDirection) {
				this.v = vDirection.setMagnitude(this.vm)
			}
			stop () {
				this.v = new Vector(0, 0)
			}
			upgrade() {
				// 最小0，最大3
				// if (this.level < 3) {
				// 	this.level++
				// }
				this.level = Math.min(this.level + 1, 3)
				switch (this.level) {
					case 0:
					default:
						this.vm = 30
						break
					case 1:
						this.vm = 45
						break
					case 2:
						this.vm = 60
						break
					case 3:
						this.vm = 70
						break
				}
				// calc width/height
				// this.width = edgeLength01 * (1 + this.level / 2)
				// this.height = this.width
				// // calc crashGraphPoints
				// this.crashGraphPoints = [

				// ]
			}
			fire() {
				// 2022.01.10后删除 start
				// let vm = 0
				// switch(this.level) {
					// 	case 0:
					// 	default:
					// 		vm = 30 // new Vector()
					// 	case 1:
					// 		vm = 45 // new Vector()
					// 		break
					// 	case 2:
					// 		vm = 60
					// 		break
					// 	case 3:
					// 		vm = 70
					// 		break
					// 		// break
					// 		// v = 80
					// 		// break
					// }
					// let v = new Vector(this.direction.x, -this.direction.y).setMagnitude(vm)
					// let v = new Vector(this.direction.x * v, -this.direction.y * v)
				// 2022.01.10后删除 end
				let shellW = edgeLength * 0.025 * 0.5
				let shellH = shellW * 2
				let l // = this.left + this.width * 0.5 - shellW * 0.5
				let t // = this.top
				let shellDirction = new Vector(this.direction.x, this.direction.y)
				// 起始位置在炮管前
				if (this.direction.x === 0 && this.direction.y === 1) {
					l = this.left + this.width * 0.5 - shellW * 0.5
					t = this.top - shellH
				} else if (this.direction.x === 1 && this.direction.y === 0) {
					l = this.left + this.height
					t = this.top + this.height * 0.5 - shellW * 0.5
				} else if (this.direction.x === 0 && this.direction.y === -1) {
					l = this.left + this.width * 0.5 - shellW * 0.5
					t = this.top + this.height
				} else if (this.direction.x === -1 && this.direction.y === 0) {
					l = this.left - shellH
					t = this.top + this.height * 0.5 - shellW * 0.5
				}
				return new ShellSprite({
					name: 'shell' + Math.floor(Math.random() * 10000),
					top: t, // this.top,
					left: l, // this.left,
					width: shellW, // this.width * 0.5,
					height: shellH, // this.height,
					// v,
					direction: this.direction,
					animating: true,
					level: this.level,
					crashGraphPoints: [new Point(l, t), new Point(l + shellW, t), new Point(l + shellW, t + shellH), new Point(l, t + shellH)],
					origin: this
				},
				{
					paint: (sprite, context) => {
						let {x, y} = sprite.direction
						if (x === 0 && y == 1) {
							context.drawImage(shellOffset.getCanvas(), 0, 0, edgeLengthHalf, edgeLength, sprite.left, sprite.top, edgeLengthHalf * 0.025, edgeLength * 0.025)
						} else if (x === 1 && y === 0) {
							context.drawImage(shellOffset.getCanvas(new Vector(1, 0)), 0, 0, edgeLength, edgeLengthHalf, sprite.left, sprite.top, edgeLength * 0.025, edgeLengthHalf * 0.025)
						} else if (x === 0 && y === -1) {
							context.drawImage(shellOffset.getCanvas(new Vector(0, -1)), edgeLengthHalf, 0, edgeLengthHalf, edgeLength, sprite.left, sprite.top, edgeLengthHalf * 0.025, edgeLength * 0.025)
						} else {
							context.drawImage(shellOffset.getCanvas(new Vector(-1, 0)), 0, edgeLengthHalf, edgeLength, edgeLengthHalf, sprite.left, sprite.top, edgeLength * 0.025, edgeLengthHalf * 0.025)
						}
					}
				},
				[{
					execute: (sprite, context, fps) => {
						// 修改可见图形位置
						sprite.left += sprite.v.x * fps / 1000
						sprite.top += sprite.v.y * fps / 1000
						if (sprite.left > edgeLength - sprite.width || sprite.left < 0 || sprite.top < 0 || sprite.top > edgeLength - sprite.height) {
							game.removeSprite(sprite)
						}
						// 修改碰撞图形位置
						sprite.crashGraphPoints = [
							new Point(sprite.left, sprite.top),
							new Point(sprite.left + sprite.width, sprite.top),
							new Point(sprite.left + sprite.width, sprite.top + sprite.height),
							new Point(sprite.left, sprite.top + sprite.height)
						]
					}
				}], 'shell')
			}
		}
		class BrickSprite extends Sprite {
			constructor(spriteOpt, painter, behaviors, category) {
				super(spriteOpt, painter, behaviors, category)
			}
		}
		class StoneSprite extends Sprite{
			constructor(spriteOpt, parinter, behaviors, category) {
				super(spriteOpt, parinter, behaviors, category)
			}
		}
		class StartSprte extends Sprite{
			constructor(spriteOpt, parinter, behaviors, category) {
				super(spriteOpt, parinter, behaviors, category)
			}
		}
		let tankPainter = {
			paint: (sprite, context) => {
				context.drawImage(tankOffset.getCanvas(sprite.direction), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}
		let tankBehaviors = [{
			execute: (sprite, context, fps) => {
				// sprite.move({x: sprite.v.x * fps / 1000, y: sprite.v.y * fps / 1000})
				// // 修改可见图形位置
				sprite.left += sprite.v.x * fps / 1000
				sprite.top += sprite.v.y * fps / 1000
				if (sprite.left > edgeLength - sprite.width) {
					sprite.left = edgeLength - sprite.width
				}
				if (sprite.top > edgeLength - sprite.width) {
					sprite.top = edgeLength - sprite.width
				}
				if (sprite.left < 0) {
					sprite.left = 0
				}
				if (sprite.top < 0) {
					sprite.top = 0
				}
				// 修改碰撞图形位置
				sprite.crashGraphPoints = [
					new Point(sprite.left, sprite.top),
					new Point(sprite.left + sprite.width, sprite.top),
					new Point(sprite.left + sprite.width, sprite.top + sprite.height),
					new Point(sprite.left, sprite.top + sprite.height),
				]
			}
		}]
		let tank0 = new TankSprite({
			name: 'tank0',
			left: edgeLength06,
			top: edgeLength09,
			// left: edgeLength08 + edgeLength01 * 0.5,
			// top: edgeLength05 + edgeLength01 * 0.5,
			// width: edgeLength01,
			// height: edgeLength01,
			// v: new Vector(0, 0),
			level: 0,
			// vm: 30,
			// 升级后变大
			// crashGraphPoints: [
			// 	new Point(edgeLength06, edgeLength09),
			// 	new Point(edgeLength07, edgeLength09),
			// 	new Point(edgeLength07, edgeLength),
			// 	new Point(edgeLength06, edgeLength),
			// 	// new Point(edgeLength08 + edgeLength01 * 0.5, edgeLength05 + edgeLength01 * 0.5), 
			// 	// new Point(edgeLength09 + edgeLength01 * 0.5, edgeLength05 + edgeLength01 * 0.5), 
			// 	// new Point(edgeLength09 + edgeLength01 * 0.5, edgeLength06 + edgeLength01 * 0.5), 
			// 	// new Point(edgeLength08 + edgeLength01 * 0.5, edgeLength06 + edgeLength01 * 0.5),
			// ]
		}, tankPainter, tankBehaviors, 'tank')
		let tank1 = new TankSprite({
			name: 'tank1',
			left: edgeLength03,
			top: 0,
			// width: edgeLength01,
			// height: edgeLength01,
			// v: new Vector(0, 0),
			level: 0,
			direction: new Vector(0, -1),
			// crashGraphPoints: [
			// 	new Point(edgeLength03, 0),
			// 	new Point(edgeLength04, 0),
			// 	new Point(edgeLength04, edgeLength01),
			// 	new Point(edgeLength03, edgeLength01),
			// ]
		}, tankPainter, tankBehaviors, 'tank')
		let brick0 = new BrickSprite({
			name: 'brick0',
			left: edgeLength04,
			top: edgeLength04,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [new Point(edgeLength04, edgeLength04), new Point(edgeLength04 + edgeLength01, edgeLength04), new Point(edgeLength04 + edgeLength01, edgeLength04 + edgeLength01), new Point(edgeLength04, edgeLength04 + edgeLength01)]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let brick1 = new BrickSprite({
			name: 'brick1',
			left: edgeLength05,
			top: edgeLength04,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength05, edgeLength04),
				new Point(edgeLength06, edgeLength04),
				new Point(edgeLength06, edgeLength05),
				new Point(edgeLength05, edgeLength05),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let brick2 = new BrickSprite({
			name: 'brick2',
			left: edgeLength04,
			top: edgeLength05,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength04, edgeLength05),
				new Point(edgeLength05, edgeLength05),
				new Point(edgeLength05, edgeLength06),
				new Point(edgeLength04, edgeLength06)
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let brick3 = new BrickSprite({
			name: 'brick3',
			left: edgeLength05,
			top: edgeLength05,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength05, edgeLength05), 
				new Point(edgeLength06, edgeLength05), 
				new Point(edgeLength06, edgeLength06), 
				new Point(edgeLength05, edgeLength06), 
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		// let brick4 = new BrickSprite({
		// 	name: 'brick4',
		// 	left: edgeLength08,
		// 	top: edgeLength05,
		// 	width: edgeLength01,
		// 	height: edgeLength01,
		// 	crashGraphPoints: [
		// 		new Point(edgeLength08, edgeLength05), 
		// 		new Point(edgeLength, edgeLength05), 
		// 		new Point(edgeLength, edgeLength06), 
		// 		new Point(edgeLength08, edgeLength06), 
		// 	]
		// }, {
		// 	paint: (sprite, context) => {
		// 		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
		// 	}
		// }, [], 'brick')
		let brick5 = new BrickSprite({
			name: 'brick5',
			left: edgeLength09,
			top: edgeLength05,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength09, edgeLength05), 
				new Point(edgeLength, edgeLength05), 
				new Point(edgeLength, edgeLength06), 
				new Point(edgeLength09, edgeLength06), 
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let brick6 = new BrickSprite({
			name: 'brick6',
			left: edgeLength05,
			top: 0,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength05, 0), 
				new Point(edgeLength06, 0), 
				new Point(edgeLength06, edgeLength01), 
				new Point(edgeLength05, edgeLength01), 
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		// let brick7 = new BrickSprite({
		// 	name: 'brick7',
		// 	left: edgeLength05,
		// 	top: edgeLength01,
		// 	width: edgeLength01,
		// 	height: edgeLength01,
		// 	crashGraphPoints: [
		// 		new Point(edgeLength05, edgeLength01), 
		// 		new Point(edgeLength06, edgeLength01), 
		// 		new Point(edgeLength06, edgeLength02), 
		// 		new Point(edgeLength05, edgeLength02), 
		// 	]
		// }, {
		// 	paint: (sprite, context) => {
		// 		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
		// 	}
		// }, [], 'brick')
		let brick8 = new BrickSprite({
			name: 'brick8',
			left: 0,
			top: edgeLength04,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(0, edgeLength04), 
				new Point(edgeLength01, edgeLength04), 
				new Point(edgeLength01, edgeLength05), 
				new Point(0, edgeLength05), 
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		// let brick9 = new BrickSprite({
		// 	name: 'brick9',
		// 	left: edgeLength01,
		// 	top: edgeLength04,
		// 	width: edgeLength01,
		// 	height: edgeLength01,
		// 	crashGraphPoints: [
		// 		new Point(edgeLength01, edgeLength04), 
		// 		new Point(edgeLength02, edgeLength04), 
		// 		new Point(edgeLength02, edgeLength05), 
		// 		new Point(edgeLength01, edgeLength05), 
		// 	]
		// }, {
		// 	paint: (sprite, context) => {
		// 		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
		// 	}
		// }, [], 'brick')
		// let brick10 = new BrickSprite({
		// 	name: 'brick10',
		// 	left: edgeLength04,
		// 	top: edgeLength08,
		// 	width: edgeLength01,
		// 	height: edgeLength01,
		// 	crashGraphPoints: [
		// 		new Point(edgeLength04, edgeLength08), 
		// 		new Point(edgeLength05, edgeLength08), 
		// 		new Point(edgeLength05, edgeLength09), 
		// 		new Point(edgeLength04, edgeLength09), 
		// 	]
		// }, {
		// 	paint: (sprite, context) => {
		// 		context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
		// 	}
		// }, [], 'brick')
		let brick11 = new BrickSprite({
			name: 'brick11',
			left: edgeLength04,
			top: edgeLength09,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength04, edgeLength09), 
				new Point(edgeLength05, edgeLength09), 
				new Point(edgeLength05, edgeLength), 
				new Point(edgeLength04, edgeLength), 
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(brickOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'brick')
		let stone0 = new StoneSprite({
			name: 'stone0',
			left: edgeLength06 - edgeLengthStone,
			top: edgeLength06,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength06 - edgeLengthStone, edgeLength06),
				new Point(edgeLength06, edgeLength06),
				new Point(edgeLength06, edgeLength06 + edgeLengthStone),
				new Point(edgeLength06 - edgeLengthStone, edgeLength06 + edgeLengthStone),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone1 = new StoneSprite({
			name: 'stone1',
			left: edgeLength06,
			top: edgeLength06,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength06, edgeLength06),
				new Point(edgeLength06 + edgeLengthStone, edgeLength06),
				new Point(edgeLength06 + edgeLengthStone, edgeLength06 + edgeLengthStone),
				new Point(edgeLength06, edgeLength06 + edgeLengthStone),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone2 = new StoneSprite({
			name: 'stone2',
			left: edgeLength06 + edgeLengthStone,
			top: edgeLength06,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength06 + edgeLengthStone, edgeLength06),
				new Point(edgeLength07, edgeLength06),
				new Point(edgeLength07, edgeLength06 + edgeLengthStone),
				new Point(edgeLength06 + edgeLengthStone, edgeLength06 + edgeLengthStone),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone3 = new StoneSprite({
			name: 'stone3',
			left: edgeLength06,
			top: edgeLength04,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength06, edgeLength04),
				new Point(edgeLength06 + edgeLengthStone, edgeLength04),
				new Point(edgeLength06 + edgeLengthStone, edgeLength04 + edgeLengthStone),
				new Point(edgeLength06, edgeLength04 + edgeLengthStone),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone4 = new StoneSprite({
			name: 'stone4',
			left: edgeLength06,
			top: edgeLength04 - edgeLengthStone,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength06, edgeLength04 - edgeLengthStone),
				new Point(edgeLength06 + edgeLengthStone, edgeLength04 - edgeLengthStone),
				new Point(edgeLength06 + edgeLengthStone, edgeLength04),
				new Point(edgeLength06, edgeLength04),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone5 = new StoneSprite({
			name: 'stone5',
			left: edgeLength06,
			top: edgeLength03,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength06, edgeLength03),
				new Point(edgeLength06 + edgeLengthStone, edgeLength03),
				new Point(edgeLength06 + edgeLengthStone, edgeLength03 + edgeLengthStone),
				new Point(edgeLength06, edgeLength03 + edgeLengthStone),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone6 = new StoneSprite({
			name: 'stone6',
			left: edgeLength03,
			top: edgeLength04 - edgeLengthStone,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength03, edgeLength04 - edgeLengthStone),
				new Point(edgeLength03 + edgeLengthStone, edgeLength04 - edgeLengthStone),
				new Point(edgeLength03 + edgeLengthStone, edgeLength04),
				new Point(edgeLength03, edgeLength04),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone7 = new StoneSprite({
			name: 'stone7',
			left: edgeLength03 + edgeLengthStone,
			top: edgeLength04 - edgeLengthStone,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength03 + edgeLengthStone, edgeLength04 - edgeLengthStone),
				new Point(edgeLength04, edgeLength04 - edgeLengthStone),
				new Point(edgeLength04, edgeLength04),
				new Point(edgeLength03 + edgeLengthStone, edgeLength04),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone8 = new StoneSprite({
			name: 'stone8',
			left: edgeLength04,
			top: edgeLength04 - edgeLengthStone,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength04, edgeLength04 - edgeLengthStone),
				new Point(edgeLength04 + edgeLengthStone, edgeLength04 - edgeLengthStone),
				new Point(edgeLength04 + edgeLengthStone, edgeLength04),
				new Point(edgeLength04, edgeLength04),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone9 = new StoneSprite({
			name: 'stone9',
			left: edgeLength04 - edgeLengthStone,
			top: edgeLength06 - edgeLengthStone,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength04 - edgeLengthStone, edgeLength06 - edgeLengthStone),
				new Point(edgeLength04, edgeLength06 - edgeLengthStone),
				new Point(edgeLength04, edgeLength06),
				new Point(edgeLength04 - edgeLengthStone, edgeLength06),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone10 = new StoneSprite({
			name: 'stone10',
			left: edgeLength04 - edgeLengthStone,
			top: edgeLength06,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength04 - edgeLengthStone, edgeLength06),
				new Point(edgeLength04, edgeLength06),
				new Point(edgeLength04, edgeLength06 - edgeLengthStone),
				new Point(edgeLength04 - edgeLengthStone, edgeLength06 - edgeLengthStone),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let stone11 = new StoneSprite({
			name: 'stone11',
			left: edgeLength04 - edgeLengthStone,
			top: edgeLength06 + edgeLengthStone,
			width: edgeLengthStone,
			height: edgeLengthStone,
			crashGraphPoints: [
				new Point(edgeLength04 - edgeLengthStone, edgeLength06 + edgeLengthStone),
				new Point(edgeLength04, edgeLength06 + edgeLengthStone),
				new Point(edgeLength04, edgeLength07),
				new Point(edgeLength04 - edgeLengthStone, edgeLength07),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(stoneOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
			}
		}, [], 'stone')
		let star = new StartSprte({
			name: 'star',
			left: edgeLength01,
			top: edgeLength01,
			width: edgeLength01,
			height: edgeLength01,
			crashGraphPoints: [
				new Point(edgeLength01, edgeLength01),
				new Point(edgeLength02, edgeLength01),
				new Point(edgeLength02, edgeLength02),
				new Point(edgeLength01, edgeLength02),
			]
		}, {
			paint: (sprite, context) => {
				context.drawImage(starOffset.getCanvas(), 0, 0, edgeLength, edgeLength, sprite.left, sprite.top, sprite.width, sprite.height)
				context.save()
				context.rect(sprite.left, sprite.top, sprite.width, sprite.height)
				context.strokeStyle = 'green'
				context.stroke()
				context.restore()
			}
		}, [], 'surprise')


		


		
		class GameTank extends Game {
			constructor(gameName, canvasId, effectDrawList,
			option = {
				showTime: false
			}, crashCb) {
				super(gameName, canvasId, effectDrawList, option = {showTime: false}, crashCb)
			}
			detectCrash() {
				// tank shell brick stone surprise
				let tankList = this.spritesCategory.get('tank') || []
				let shellList = this.spritesCategory.get('shell') || []
				let brickList = this.spritesCategory.get('brick') || []
				let stoneList = this.spritesCategory.get('stone') || []
				let surpriseList = this.spritesCategory.get('surprise') || []
				// shell vs tank / brick / stone
				// 可优化
				let shellCrashedObjList = shellList.map(shell => {
					let crashedObjList = tankList.concat(brickList, stoneList).filter(item => item.crashGraph.collidesWith(shell.crashGraph))
					if (crashedObjList.length) {
						return {
							origin: shell,
							targets: crashedObjList
						}
					} else {
						return
					}
				}).filter(item => item)
				// tank vs brick / stone / surprise
				let tankCrashedObjList = tankList.map(tank => {
					let crashedObjList = brickList.concat(stoneList, surpriseList).filter(item => item.crashGraph.collidesWith(tank.crashGraph))
					if (crashedObjList.length) {
						return {origin: tank, targets: crashedObjList}
					} else {
						return
					}
				}).filter(item => item)
				if (shellCrashedObjList.length || tankCrashedObjList.length) {
					// this.crashCb(shellCrashedObjList, tankCrashedObjList)
					this.crashCb(shellCrashedObjList.concat(tankCrashedObjList))
				}
			}
		}
		let centerPoint = (left, top, width, height) => {
			return new Point(left + width, top + height)
		}
		// let levelUp = (tank, surprise) => {
		// 	// log('levelUp', tank, surprise)
		// 	// log(tank.level)
		// 	tank.level++
		// 	// log(tank.level)
		// }
		let crashCb = (crashedObjList) => {
			// tank brick stone shell surprise
			// shell vs
			// log('crashedObjList', crashedObjList)
			crashedObjList.map(({origin, targets}) => {
				switch (origin.category) {
					case 'tank':
						// tank vs brick / stone / surprise
						// 让坦克退回去
						if (!origin.v.magnitude()) { break }
						let overlapMList
						let obstacles = [], surprise = []
						targets.forEach(t => {
							if (['brick', 'stone'].includes(t.category)) {
								obstacles.push(t)
							}
							if (t.category === 'surprise') {
								surprise.push(t)
							}
						})
						// 分方向
						if (origin.v.x === 0 && origin.v.y > 0) { // 向下
							overlapMList = obstacles.map(target => {
								return origin.height - Math.abs(target.top - origin.top)
							})
						} else if (origin.v.x === 0 && origin.v.y < 0) { // 向上
							overlapMList = obstacles.map(target => {
								return target.height - Math.abs(target.top - origin.top)
							})
						} else if (origin.v.x > 0 && origin.v.y === 0) { // 向右
							overlapMList = obstacles.map(target => {
								return origin.width - Math.abs(target.left - origin.left)
							})
						} else if (origin.v.x < 0 && origin.v.y === 0) { // 向左
							overlapMList = obstacles.map(target => {
								return target.width - Math.abs(target.left - origin.left)
							})
						}
						// 取最大重叠量
						// log('overlapMList', overlapMList)
						let m = Math.max.apply(null, overlapMList.length ? overlapMList : [0])
						// 移动
						// log('m', m)
						origin.move(origin.v.opposite().setMagnitude(m))
						// 升级
						surprise.forEach(s => {
							// levelUp(origin, s)
							origin.upgrade()
							game.removeSprite(s)
						})
						break
					case 'shell':
						// shell vs tank / brick / stone
						// 爆炸
						game.removeSprite(origin)
						targets.forEach(t => {
							switch(t.category) {
								case 'tank':
									end(origin.origin)
								case 'brick':
								case 'surprise':
									game.removeSprite(t)
									break
								case 'stone':
								default:
									break
							}
						})
						
						break
				}
			})
		}
		let end = (winner) => {
			game.end()
			paintEnd(undefined, winner.name)
		}
		
		let game = new GameTank('tank90', '#canvas', [paintBorder, 
			// paintTank0Point
			], {
			showTime: false
		}, crashCb)
		game.setSprite(tank0)
		game.setSprite(tank1)
		game.setSprite(brick0)
		game.setSprite(brick1)
		game.setSprite(brick2)
		game.setSprite(brick3)
		// game.setSprite(brick4)
		game.setSprite(brick5)
		game.setSprite(brick6)
		// game.setSprite(brick7)
		game.setSprite(brick8)
		// game.setSprite(brick9)
		// game.setSprite(brick10)
		game.setSprite(brick11)
		game.setSprite(stone0)
		game.setSprite(stone1)
		game.setSprite(stone2)
		game.setSprite(stone3)
		game.setSprite(stone4)
		game.setSprite(stone5)
		game.setSprite(stone6)
		game.setSprite(stone7)
		game.setSprite(stone8)
		game.setSprite(stone9)
		game.setSprite(stone10)
		game.setSprite(stone11)
		// game.setSprite(stone11)
		// game.setSprite(star) // for test
		game.setKeyListener(38, (e) => { // 上
			// tank0.animating = true
			tank0.direction = new Vector(0, 1)
			let vDirection = new Vector(0, -1) // 使用单位向量表示运动方向
			tank0.launch(vDirection)
			// tank0.v = new Vector(0, -30)
			// tank0.direction = new Vector(0, 1)
		}, true)
		game.setKeyListener(38, (e) => {
			// tank0.animating = false
			tank0.stop()
			// tank0.v = new Vector(0, 0)
			// log(tank0.left, tank0.top)

		}, false)
		game.setKeyListener(40, (e) => { // 下
			// tank0.animating = true
			// tank0.v = new Vector(0, 30)
			// tank0.direction = new Vector(0, -1)
			tank0.direction = new Vector(0, -1)
			tank0.launch(new Vector(0, 1))
		})
		game.setKeyListener(40, (e) => {
			// tank0.animating = true
			// tank0.v = new Vector(0, 0)
			// log(tank0.left, tank0.top)
			tank0.stop()
		}, false)
		game.setKeyListener(37, (e) => { // 左
			// tank0.animating = true
			// tank0.v = new Vector(-30, 0)
			// tank0.direction = new Vector(-1, 0)
			tank0.direction = new Vector(-1, 0)
			tank0.launch(new Vector(-1, 0))
		})
		game.setKeyListener(37, (e) => {
			// tank0.animating = true
			// tank0.v = new Vector(0, 0)
			// log(tank0.left, tank0.top)
			tank0.stop()
		}, false)
		game.setKeyListener(39, (e) => { // 右
			// tank0.animating = true
			// tank0.v = new Vector(30, 0)
			// tank0.direction = new Vector(1, 0)
			tank0.direction = new Vector(1, 0)
			tank0.launch(new Vector(1, 0))
		})
		game.setKeyListener(39, (e) => {
			// tank0.animating = true
			// tank0.v = new Vector(0, 0)
			// log(tank0.left, tank0.top)
			tank0.stop()
		}, false)
		game.setKeyListener(32, (e) => {
			game.setSprite(tank0.fire())
		})

		// a
		game.setKeyListener(65, (e) => {
			// tank1.animating = true
			// tank1.v = new Vector(-30, 0)
			// tank1.direction = new Vector(-1, 0)
			tank1.direction = new Vector(-1, 0)
			tank1.launch(new Vector(-1, 0))
		})
		game.setKeyListener(65, (e) => {
			// tank1.animating = true // false
			// tank1.v = new Vector(0, 0)
			tank1.stop()
		}, false)
		// s
		game.setKeyListener(83, (e) => {
			// tank1.animating = true
			// tank1.v = new Vector(0, 30)
			// tank1.direction = new Vector(0, -1)
			tank1.direction = new Vector(0, -1)
			tank1.launch(new Vector(0, 1))
		})
		game.setKeyListener(83, (e) => {
			// tank1.animating = true // false
			// tank1.v = new Vector(0, 0)
			tank1.stop()
		}, false)
		// d
		game.setKeyListener(68, (e) => {
			// tank1.animating = true
			// tank1.v = new Vector(30, 0)
			// tank1.direction = new Vector(1, 0)
			tank1.direction = new Vector(1, 0)
			tank1.launch(new Vector(1, 0))
		})
		game.setKeyListener(68, (e) => {
			// tank1.animating = true // false
			// tank1.v = new Vector(0, 0)
			tank1.stop()
		}, false)
		// w
		game.setKeyListener(87, (e) => {
			// tank1.animating = true
			// tank1.v = new Vector(0, -30)
			// tank1.direction = new Vector(0, 1)
			tank1.direction = new Vector(0, 1)
			tank1.launch(new Vector(0, -1))
		})
		game.setKeyListener(87, (e) => {
			// tank1.animating = true // false
			// tank1.v = new Vector(0, 0)
			tank1.stop()
		}, false)
		game.setKeyListener(70, (e) => {
			game.setSprite(tank1.fire())
		})
		// let drawMap = () => {
		// 	// log('drawMap')
		// }
		// let draw = () => {
		// 	log('draw')
		// 	paintBorder()
		// 	// drawMap()
		// 	tank.update(context, fps)
		// 	tank.paint(context)
		// }
		// let animate = (time) => {
		// 	context.clearRect(0, 0, edgeLength, edgeLength)
		// 	fps = calcFps()
		// 	draw()
		// 	animateId = requestNextAnimateionFrame(animate)
		// }
		let createSurprise = () => {
			let p = new Promise((s, j) => {
				// 享元模式
				// star.left = edgeLength * Math.floor(Math.random() * 9) / 10
				// star.top = edgeLength * Math.floor(Math.random() * 9) / 10
				star.left = edgeLength * 0.3
				star.top = edgeLength * 0.4
				star.crashGraphPoints = [
					new Point(star.left, star.top),
					new Point(star.left + star.width, star.top),
					new Point(star.left + star.width, star.top + star.height),
					new Point(star.left, star.top + star.height),
				]
				game.setSprite(star)
				setTimeout(() => {s()}, 2000)
			}).then(() => {
				game.removeSprite(star)
				randomSurprise()
			})
		}
		let randomTime = (duration = 30000) => Math.floor(Math.random() * Math.max(duration, 10000))
		let randomSurpriseTimeId
		let randomSurprise = () => {
			// 随机时间后生成一个惊喜
			// let time = randomTime()
			let time = 2000
			// let time = 0
			randomSurpriseTimeId = setTimeout(() => {
				createSurprise()
				clearTimeout(randomSurpriseTimeId)
			}, time)
		}
		let start = () => {
			// animateId = requestNextAnimateionFrame(animate)
			game.start()
			// game.detectCrash()
			// triangle.collidesWith(quadrangle)
			// log(brick4)
			// log(tank)
			// log(brick4.crashGraph.collidesWith(tank.crashGraph))
			// log(brick3.crashGraph.collidesWith(tank.crashGraph))
			randomSurprise()
			// 异步方法无法暂停
		}
		let stop = () => {
			// game.end()
			game.animating = false
			paintStop()
			clearTimeout(randomSurpriseTimeId)
			// game.animating = false
			// game.start()
			// cancelNextAnimationFrame(animateId)
		}
		let flag = false
		canvas.onclick = (e) => {
			flag = !flag
			if (flag) {
				start()
			} else {
				stop()
			}
		}
		window.onblur = (e) => {
			if (flag) {
				flag = false
				stop()
			}
		}

		log(game)

		// log(tankOffset)

	</script>
</body>
</html>