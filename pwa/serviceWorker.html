<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>service worker</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="service-worker">service worker</h1>
<blockquote>
<p>本质上是web应用、浏览器与网络之间的代理服务器。
是一个注册在指定源和路径下的事件驱动worker
它设计为完全异步，同步api(如(xhr)这好像有问题/localStorage)不能在service worker中使用
只能https承载。本地开发时可以使用<code>localhost</code>。也可以使用 <a href="/jsPackages/ngrok.html">ngrok</a> + <a href="https://www.npmjs.com/package/serve">serve</a><br>
在firefox浏览器的用户隐私模式下，service worker不可用。
webworker / sharedworker 都叫worker。内部都用self指向全局变量。它们都是worker，它管不了主线程里的事。<br>
它在<code>navigator</code>下。即：<code>navigator.serviceWorker</code>。navigator下还有好多东西。发现好多调用原生、硬件的api在这个对象里。<br>
是浏览器和网络之间的虚拟代理。</p>
</blockquote>
<h2 id="feature">feature</h2>
<ol>
<li><a href="https://wicg.github.io/background-sync/spec/">后台同步</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API">信息推送</a>
<ol>
<li>可以实现后端后前端推送信息</li>
<li>需要一个被激活的service worker</li>
<li>可以使用<code>PushManager.subscribe()</code>方法订阅消息。</li>
</ol>
</li>
</ol>
<ul>
<li>在弱网、断网时提供服务</li>
<li>use background sync</li>
<li>use push notification</li>
<li>监听请求</li>
<li>同步消息</li>
</ul>
<h2 id="usage">usage</h2>
<pre><code class="language-js"><span class="hljs-comment">// serviceWorker.js</span>
<span class="hljs-comment">// demo0</span>
<span class="hljs-comment">// this.addEventListener(&#x27;fetch&#x27;, (e) =&gt; {</span>
<span class="hljs-comment">// or</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-comment">// 劫持http响应</span>
    e.<span class="hljs-title function_">respondWith</span>(
        <span class="hljs-comment">// 缓存中是否存在</span>
        caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)
            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
                <span class="hljs-keyword">if</span> (response) {
                    <span class="hljs-keyword">return</span> response <span class="hljs-comment">// 若缓存中存在则返回缓存的数据</span>
                }
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response) <span class="hljs-comment">// 否则请求并返回请求到的数据。</span>
            })
            .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> { <span class="hljs-comment">// 若出错则返回错误。也可以返回自定义response对象</span>
                <span class="hljs-keyword">throw</span> err
                <span class="hljs-comment">// or</span>
                <span class="hljs-comment">// return new Response(...`)</span>
            })
    )
    <span class="hljs-comment">// e.respondWith(caches.match(e.request)) // 只从缓存中取数据</span>
})

<span class="hljs-comment">// demo1</span>
<span class="hljs-comment">// 若缓存中有相应的数据，则返回缓存中的数据。否则请求数据后保存在缓存中，并返回给请求者。</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    event.<span class="hljs-title function_">respondWith</span>(
        caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
            <span class="hljs-comment">// 若缓存中存在则返回，否则请求。</span>
            <span class="hljs-keyword">return</span> response || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
                <span class="hljs-comment">// 此时缓存中没有。</span>
                <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {
                    <span class="hljs-comment">// 把数据添加到缓存中</span>
                    cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, res.<span class="hljs-title function_">clone</span>())
                    <span class="hljs-comment">// 把响应克隆一份后缓存起来。把原始响应返回给调用它的页面。</span>
                    <span class="hljs-comment">// 请求和响应流只能被读取一次。缓存起来的是克隆出来的，返回给页面的是原始的。</span>
                    <span class="hljs-keyword">return</span> res
                })
            })
        })
    )
})

<span class="hljs-comment">// demo2</span>
<span class="hljs-comment">// 更新service worker</span>
<span class="hljs-comment">// 如果你的 service worker 已经被安装，但是刷新页面时有一个新版本的可用，新版的 service worker 会在后台安装，但是还没激活。当不再有任何已加载的页面在使用旧版的 service worker 的时候，新版本才会激活。一旦再也没有更多的这样已加载的页面，新的 service worker 就会被激活。</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    event.<span class="hljs-title function_">waitUntil</span>(
        <span class="hljs-comment">// 使用新版本号，不会与别的版本有冲突</span>
        caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v2&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {
            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([
                <span class="hljs-string">&#x27;/sw-test/&#x27;</span>,
                <span class="hljs-string">&#x27;/sw-test/index.html&#x27;</span>
            ])
        })
    )
})

<span class="hljs-comment">// demo3</span>
<span class="hljs-comment">// 删除旧缓存</span>
<span class="hljs-comment">// activate事件可用于删除旧缓存。  </span>
<span class="hljs-comment">// 每个浏览器对service worker可用缓存空间不同。</span>
<span class="hljs-comment">// 若不控制，则有可能浏览器会全部清空缓存的数据。  </span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> cacheWhiteList = [<span class="hljs-string">&#x27;v2&#x27;</span>]
    event.<span class="hljs-title function_">waitUntil</span>(
        caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keyList</span> =&gt;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(keyList.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
                <span class="hljs-keyword">if</span> (cacheWhiteList.
                <span class="hljs-title function_">includes</span>(key)) {
                    <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(key)
                }
            }))
        })
    )
})

<span class="hljs-comment">// demo4</span>
<span class="hljs-comment">// 推送消息</span>
</code></pre>
<h3 id="使用条件">使用条件</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>chrome</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>firefox</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>xxx</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="生命周期">生命周期</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 下载</td>
<td></td>
<td>由程序触发</td>
<td></td>
</tr>
<tr>
<td>2. 安装</td>
<td>由浏览器触发</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 激活</td>
<td>由浏览器触发</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>注册
    在主线程执行serviceWorkerContainer.register(url[, options])
注册成功
    service worker在ServiceWorkerGlobalScope环境中运行。（其中无法访问dom）可接收事件
安装
    解决oninstall事件。
    常用于缓存资源
激活
    清理生前版本的service worker脚本中使用的资源
    常用于清理、更新缓存
开始控制页面
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// app.js</span>
<span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) {
    navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(   <span class="hljs-comment">// 注册</span>
                                        <span class="hljs-comment">// 注册完成后，sw.js 文件会自动</span>
                                        <span class="hljs-comment">// 1. 下载</span>
                                        <span class="hljs-comment">// 2. 安装</span>
                                        <span class="hljs-comment">// 3. 然后激活。</span>
        <span class="hljs-string">&#x27;url/path.js&#x27;</span>, <span class="hljs-comment">// 相对于origin。一般在根目录。</span>
        {<span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;/path/&#x27;</span>} <span class="hljs-comment">// 指定注册范围。即：能拦截网络调用的路径</span>
    ) <span class="hljs-comment">// 返回一个promise.其值是ServiceWrokerRegistration</span>
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">registration</span>) =&gt;</span> {
        <span class="hljs-comment">// ...</span>
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;catch&#x27;</span>, err)
    })
}
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>) <span class="hljs-comment">// 好像用不到</span>
</code></pre>
<h2 id="更新serviceworker">更新serviceWorker</h2>
<h3 id="何时更新">何时更新</h3>
<ul>
<li>当进入sw控制的页面时</li>
<li>当前已经安装的sw执行<code>navigator.serviceWorker.register()</code>到不同的url时。</li>
<li>当前已经安装的sw执行<code>navigator.serviceWorker.register()</code>改变scope时。最好不要这样做。</li>
<li>当“推送”或“同步”等事件在过去24小时内被触发时——但现在还不用担心这些事件。</li>
</ul>
<h3 id="如何更新">如何更新</h3>
<ul>
<li>如果合适，则使用<code>importScripts</code>一个一个地更新</li>
<li>sw在顶级代码变动会引起生成新指纹。（workbox）</li>
</ul>
<h3 id="手动触发更新">手动触发更新</h3>
<p>上线sw功能时，要开发此功能做为兜底解决方案。</p>
<pre><code class="language-js"><span class="hljs-comment">// 在主线程中执行</span>
<span class="hljs-comment">// 当sw为active状态时更新</span>
navigater.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">ready</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">registration</span>) =&gt;</span> {
    registration.<span class="hljs-title function_">update</span>()
})
</code></pre>
<h3 id="解决方案">解决方案</h3>
<h4 id="解决sw中缓存不更新的问题">解决sw中缓存不更新的问题</h4>
<ol>
<li>在主脚本中引入的sw文件名不用动。</li>
<li>在sw文件中定义当前版本号。</li>
<li>在install事件中使用当前版本号缓存资源。</li>
<li>在activate事件中删除非当前版本号的缓存。</li>
</ol>
<h4 id="一定要考虑清缓存策略">一定要考虑清缓存策略</h4>
<h4 id="对于变动较频繁的接口可使用网络优先解决本地缓存在弱网脱网时使用">对于变动较频繁的接口，可使用“网络优先”解决。本地缓存在弱网、脱网时使用。</h4>
<h3 id="增加版本号">增加版本号</h3>
<h2 id="使用">使用</h2>
<ul>
<li>默认缓存一些文件</li>
<li>开放供用户选择缓存、清缓存的ui交换界面。</li>
<li>开放手动更新sw的功能。</li>
</ul>
<h2 id="api">api</h2>
<h3 id="serviceworkercontainer---navigatorserviceworker">ServiceWorkerContainer   (navigator.serviceWorker)</h3>
<p>ServiceWorkerContainer接口为service worker提供了一个容器般的功能。包括对service worker的注册、卸载、更新、和访问service worker的状态、 以及它们的注册者。
<code>navigator.serviceWorker</code>就是ServiceWorkerContainer</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>controller</td>
<td>当service worker状态为active时，返回ServiceWorkder对象。否则返回null</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ready</td>
<td>返回一个promise，当serviceworker为active状态时promise变为fulfilled状态。该promise永远不会变为rejected状态</td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>register(scriptUrl[, {scope: USVString}])</td>
<td>返回一个ServiceWorkerRegistration（优先）。或返回一个值是ServiceWorkerRegistration的promise</td>
<td>scope指定service worker注册范围。能拦截网络调用的路径范围。只能拦截service worker文件所在的目录及其子目录范围内的请求。（即：最大作用域在它的所在位置。）</td>
<td>经过测试，只能注册一个service worker。后面的会覆盖前面的。</td>
</tr>
<tr>
<td></td>
<td>getRegistration()</td>
<td>根据当前网页的url返回一个ServiceWorkerRegistration或null</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>getRegistrations()</td>
<td>返回所有ServiceWrokerRegistration或null</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>startMessages()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>事件</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>oncontrollerchange</td>
<td>当serviceworker变为active时触发</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>onerror</td>
<td>当serviceworker中出现错误时触发</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>onmessage</td>
<td>当ServiceWorkerContainer对象接收到一个message消息时触发。</td>
<td>message是MessagePort.postMessage()发出的</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="serviceworkerregistration-对象">ServiceWorkerRegistration 对象</h3>
<p>这是一个实验中的功能
它是注册了service worker的注册证（是一个容器）。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td>都是只读</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>scope</td>
<td>返回相对于origin的范围</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>installing</td>
<td>返回处于installing的service worker或null</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>waiting</td>
<td>返回处于waiting的service worker或null</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>active</td>
<td>返回处于activating / activated的service worker或null</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>periodicSync</td>
<td>返回一个PeriodicSyncManager对象，该对象管理阶段性后台同步进程。</td>
<td>周期性执行任务。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>pushManager</td>
<td>返回一个PushManager对象的引用。该对象可用于推送消息给订阅者。getting an active subscription, and accessing push permission status.</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>sync</td>
<td>返回一个SyncManager对象的引用。该对象管理后台同步进程</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>onupdatefound</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>getNotifications(options?: {tag: string})</td>
<td>返回一个值是Notification的promise</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>showNotification(title, options?: {actions: [{action, title, icon}, ...], badge, body, data, dir, icon, image, lang, renotify, requireInteraction, silent, tag, timestamp, vibrate})</td>
<td>创建一个通知</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update(无参数)</td>
<td>ServiceWorkerRegistration接口的update()方法试图更新service worker。它获取worker的脚本URL，如果新worker与当前worker不完全相同，它就安装新worker。如果之前的读取发生在24小时之前，那么worker的读取将绕过任何浏览器缓存。返回一个值是ServiceWorkerRegistration的promise</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>unregister()</td>
<td>注销这个service worker，返回一个值是boolean的promise。boolean表示是否被注销。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="serviceworkerglobalscope">ServiceWorkerGlobalScope</h3>
<p>代表一个service worker的全局变量。<br>
serviceworker中不能使用同步请求，只能使用异步请求。</p>
<p>代表sw的全局可执行环境。</p>
<pre><code class="language-js"><span class="hljs-comment">// 原型链</span>
<span class="hljs-title class_">EventTarget</span> &lt;-- <span class="hljs-title class_">WorkerGlobalScope</span> &lt;-- <span class="hljs-title class_">ServiceWorkerGlobalScope</span>
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td>都是只读</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>caches</td>
<td>使用sw得到CacheStorage</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>clients</td>
<td>返回与当前sw相关连的Clients对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>registration</td>
<td>返回当前sw的注册的ServiceWorkerRegistraion对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>事件</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>activate</td>
<td>当ServiceWorkerRegistration执行active方法里执行。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>contentdalete</td>
<td>当删除条目时触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>fetch</td>
<td>当发出请求时</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>install</td>
<td>当执行install方法时</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>message</td>
<td>当接收到消息时触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>notificationclick</td>
<td>当执行ServiceWorkerRegistration.showNotification()时触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>notificationclose</td>
<td>xx</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>sync</td>
<td>当注册了Syncmanager并连能时触发</td>
<td>不能取消冒泡</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>periodicsync</td>
<td>当注册PeriodicSyncManager时触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>push</td>
<td>当收到一个消息时触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>pushsubscriptionchange</td>
<td>好像是当改变推送订阅者是触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法</td>
<td>全部继承自worker</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>skipWaiting()</td>
<td>强制等待sw成为active状态</td>
<td>Promise<undefined></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>fetch(resource, options?: {method, headers, body, ...})</td>
<td>就是fetch方法</td>
<td>Promise<Response></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>skipWaiting()</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="serviceworker">ServiceWorker</h3>
<ul>
<li>继承自<a href="">worker</a></li>
<li>这是一个实验中的功能</li>
<li>它是服务工作者</li>
<li>允许访问推送通知、后台同步api</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td>都是只读</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>scriptUrl</td>
<td>脚本的url</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>state</td>
<td>返回service worker的状态</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>事件</td>
<td>全是小写</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>onstatechange</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>fetch</td>
<td>当控制范围内的页面有请求时触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>install</td>
<td>安装时触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>activate</td>
<td>激活时触发</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>push</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法</td>
<td>全部继承自worker</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="workerglobalscope">WorkerGlobalScope</h3>
<h3 id="syncmanager">SyncManager</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>事件</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>register(options?: {allowOnBattery, id, idleRequired, maxDelay, minDelay, minPeriod, minRequiredNetwork})</td>
<td>返回一个值为SyncRegistration的promise</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>getTags()</td>
<td>返回一个值为开发者定义的SyncManager注册证的标识的promise</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="periodicsyncmanager">PeriodicSyncManager</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API">https://developer.mozilla.org/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API</a><br>
它的功能正如它的名字：定期同步消息。
以前在项目中使用setInterval实现此功能。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>事件</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>register(tag, options?: {minInterval})</td>
<td>注册一个定期请求实现同步消息。</td>
<td>返回值Promise<undefined></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>getTags()</td>
<td></td>
<td>返回注册证的标记。Promise&lt;string[]&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>unregister(tag)</td>
<td>注销指定的注册证</td>
<td>Promise</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="设置scope的范围">设置scope的范围</h2>
<p>前提：默认最大作用域在它的所在位置。</p>
<ul>
<li>把serviceWorker.js文件放在根目录上。</li>
<li>设置serviceWorker.js的响应头 Service-Worker-Allowed 为 <code>/</code></li>
</ul>
<h2 id="uml">uml</h2>
<h2 id="todo">todo</h2>
<h3 id="messageport"><a href="">MessagePort</a></h3>
<h3 id="名称">名称</h3>
<p>工作线程。</p>
<h3 id="pushmanager"><a href="/pwa/push.html">PushManager</a></h3>
<h3 id="syncmanager-1">SyncManager</h3>
<h3 id="notification">Notification</h3>
<h3 id="storagemanager">StorageManager</h3>
<p>window.navigator.storage
用于管理数据本地存储权限和估算可用存储空间的对象。</p>
<table>
<thead>
<tr>
<th>StorageManager</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>方法</td>
<td></td>
<td></td>
<td>都是返回promise</td>
<td></td>
</tr>
<tr>
<td></td>
<td>estimate()</td>
<td>估算域名下storage manager的总存储空间和已经使用了的存储空间</td>
<td>{quota, usage, usageDetails: {}}</td>
<td></td>
</tr>
<tr>
<td></td>
<td>persist()</td>
<td></td>
<td>返回是否有在本地数据存储的权限</td>
<td></td>
</tr>
<tr>
<td></td>
<td>persisted()</td>
<td></td>
<td>返回是否是盒存储模式</td>
<td></td>
</tr>
<tr>
<td></td>
<td>estimate()</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="sw可用空间">sw可用空间</h4>
<p>||sw可用空间|||||
|-|-|-||||
|chrome|可使用80%的总磁盘空间。StorageManager API可确定最大配额|||||
|ff|可使用50%的可用磁盘空间。最多可用2g|||||
|ie 10|最多250m。当&gt;10m时提示用户|||||
|op||||||
|safri|约1g。当达到限制时，会提示用户，每次可增加200m。|||||</p>
<h4 id="开发者工具">开发者工具</h4>
<h5 id="chrome"><a href="/browser/chromeDevtools.html">chrome</a></h5>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>chrome://inspect/#service-workers</td>
<td>展示当前设备上激活和存储的 service worker等。</td>
</tr>
<tr>
<td>chrome://serviceworker-internals</td>
<td>可以展示更多细节来允许你开始/暂停/调试 worker 的进程。</td>
</tr>
</tbody>
</table>
<h5 id="firefox">firefox</h5>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>about:serviceworkers</td>
<td>查看已注册的SW，也可更新、移除</td>
</tr>
<tr>
<td>检查 Firefox Devtools 的选项 &quot;Enable Service Workers over HTTP (when toolbox is open)&quot;</td>
<td>可绕开https限制。</td>
</tr>
</tbody>
</table>
<h3 id="worker">Worker</h3>
<h3 id="三者关系">三者关系</h3>
<p>ServiceWorkerContainer为service worker提供一个容器般的功能
ServiceWorkerContainer.register() // 返回 ServiceWorkerRegistration
<code>navigator.serviceWorker</code>就是ServiceWorkerContainer</p>
<p>ServiceWorkerRegistration.installing    // 返回service worker
ServiceWorkerRegistration.waiting       // 返回service worker
ServiceWorkerRegistration.active        // 返回service worker</p>
<h3 id="cache"><a href="/frontStore/cache.html">cache</a></h3>
<p>同步的</p>
<h3 id="indexeddb"><a href="/frontStore/indexedDB.html">indexedDB</a></h3>
<p>常在service worker内做数据存储</p>
<h3 id="fetchevent">FetchEvent</h3>
<p>当页面发生提取动作会在service worker作用域（ServiceWorkerGlobalScope）中触发fetch事件<br>
继承自Event</p>
<pre><code class="language-js"><span class="hljs-comment">// 监听方式</span>
<span class="hljs-title class_">ServiceWorkerGlobalScope</span>.<span class="hljs-property">onfetch</span>
<span class="hljs-comment">// or</span>
<span class="hljs-title class_">ServiceWorkerGlobalScope</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>)

<span class="hljs-comment">// demo</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function">() =&gt;</span> {...})
</code></pre>
<h4 id="构造函数">构造函数</h4>
<pre><code class="language-js"><span class="hljs-title class_">FetchEvent</span>.<span class="hljs-title class_">FetchEvent</span>()
</code></pre>
<h4 id="属性">属性</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>属性</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>isReload</td>
<td>返回是否由用户触发</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>request</td>
<td>返回事件控制器的Request</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>clientId</td>
<td>返回事件的id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>respondWith(任何自定义的响应生成代码)</td>
<td>控制返回的Response对象或网络错误。</td>
<td>可用于劫持http<strong>响应</strong>。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>waitUntil(promise)</td>
<td>延长事件的生命周期</td>
<td>无返回值</td>
<td>告诉事件分发器，事件仍在进行，直到promise解决。可用于检测是否完成。</td>
</tr>
<tr>
<td>当event.waitUntil的参数promise变为rejected状态时，会丢弃这个服务工作线程。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="response"><a href="/language/javascript/response.html">response</a></h3>
<h3 id="request"><a href="/language/javascript/request.html">request</a></h3>
<h3 id="pushevent">PushEvent</h3>
<p>它还处理实验阶段</p>
<pre><code class="language-js"><span class="hljs-comment">// 继承关系</span>
<span class="hljs-title class_">Event</span> &lt;--- <span class="hljs-title class_">Extendable</span> &lt;--- <span class="hljs-title class_">PushEvent</span>

<span class="hljs-keyword">new</span> <span class="hljs-title class_">PushEvent</span>(type[, options]) =&gt; <span class="hljs-title class_">PushEvent</span>
type 事件名称
<span class="hljs-attr">options</span>: { <span class="hljs-comment">// 会添加到event对象上。</span>
    data <span class="hljs-comment">// 该属性会被设置为一个新的包含这些字段的PushMessageData对象</span>
}
<span class="hljs-comment">// demo</span>
<span class="hljs-keyword">let</span> myPushEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushEvent</span>(<span class="hljs-string">&#x27;push&#x27;</span>, {<span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;string&#x27;</span>})
myPushEvent.<span class="hljs-property">data</span>.<span class="hljs-title function_">text</span>() <span class="hljs-comment">// &#x27;string&#x27;</span>

<span class="hljs-comment">// serviceWorker.js</span>
self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> obj = event.<span class="hljs-property">data</span>.<span class="hljs-title function_">json</span>() <span class="hljs-comment">// 以json格式提取数据</span>
    <span class="hljs-keyword">if</span> ([<span class="hljs-string">&#x27;subscribe&#x27;</span>, <span class="hljs-string">&#x27;unsubscribe&#x27;</span>].<span class="hljs-title function_">includes</span>(obj.<span class="hljs-property">action</span>)) {
        <span class="hljs-title function_">fireNotification</span>(obj, event)
        port.<span class="hljs-title function_">postMessage</span>(obj)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">&#x27;init&#x27;</span>, <span class="hljs-string">&#x27;chatMsg&#x27;</span>].<span class="hljs-title function_">includes</span>(obj.<span class="hljs-property">action</span>)) {
        port.<span class="hljs-title function_">postMessage</span>(obj)
    }
})
</code></pre>
<p>属性、方法都是从祖先原型上继承的。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="pushmessagedata">PushMessageData</h4>
<p>它处理实验阶段。
它是push api的对象。可以让我们找到从服务器发来的push数据。
其方法、属性可调用多次。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>无属性</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>方法</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>arrayBuffer()</td>
<td>以ArrayBuffer的格式提取数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>blob()</td>
<td>以Blob的格式提取数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>json()</td>
<td>以JSON的格式提取数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>text()</td>
<td>以纯文本的格式提取数据</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="notification-api">Notification API</h3>
<h3 id="windowclient">WindowClient</h3>
<p>该对象是sw的控制范围。</p>
<pre><code class="language-js"><span class="hljs-comment">// 原型链</span>
<span class="hljs-title class_">Client</span> &lt;-- <span class="hljs-title class_">WindowClient</span>
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>focused</td>
<td>指定的windowClient是否被聚焦</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vivibilityState</td>
<td></td>
<td>返回指定windowClient的可见状态</td>
<td>hidden/visible/prerender</td>
<td></td>
<td></td>
</tr>
<tr>
<td>focus()</td>
<td>聚集到当前client</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>navigate(url)</td>
<td>加载指定的url到控制的client的页面</td>
<td>返回一个值为xxx的promise</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="client">Client</h3>
<p>该对象是可执行环境。如worker</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>client的惟一标识</td>
<td>只读</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td>client的种类</td>
<td>只读</td>
<td>window/worker/sharedworker</td>
</tr>
<tr>
<td>url</td>
<td>client的url</td>
<td>只读</td>
<td></td>
</tr>
<tr>
<td>postMessage()</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="title">title</h3>
<h3 id="title-1">title</h3>

            
            
        </body>
        </html>