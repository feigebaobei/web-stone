# overview

Transmission Control Protocol  
一般基于 ip 协议  
是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议。

- TCP 提供可靠交付的服务，保证数据无差错、不丢失、不重复、按序到达。
- TCP 提供全双工通信。
- TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为首部和数据两部分
- 一个 tcp 连接可以传送多个 http 请求和响应。
- 面向连接、字节流。
- 在缓冲区整理好了数据后再交付给应用层。

## 特点

<!-- prettier-ignore-start -->
|     |            |             |  |
| --- | ---- | --- | ------ |
|     | 面向连接   |     全建立连接        |  |
|     | 传输可靠   | 2 个使用 tcp 的应用，在交换数据之前必须建立 tcp 连接。    |  |
|     |            | 应用程序产生的数据长度保持不变。     |  |
|     |            | 当 tcp 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。若不能及时收到确认，则重发这个报文段。tcp 有延迟确认的功能。若此功能未打开，则立即确认。若此功能打开，则由定时器触发确认时间点 |  |
|     |            | tcp 将保持它首部和数据的检验和。若目的端检测数据与检验和有差错，则不确认收到此报文段。     |  |
|     |            | tcp 将收到的数据进行重新排序，以正确顺序交给应用层。      | 如何排序的？ ip 在传输过程中会失序。 |
|     |            | tcp 可以丢弃重复数据。             |  |
|     |            | tcp 的接收端只允许另一端发送接收端的缓冲区所能接纳的数据。可防止较快主机致使较慢主机的缓冲区溢出        |  |
|     | 面向字节流 |  传递的是报文段           |  |
<!-- prettier-ignore-end -->

![tcp头部](/communication-protocol/tcpHeader.png)

源端口(Source Port)  
目的端口(Desination Port)  
序列号(Sequence Number)【数据包的序号】  
确认号(Acknowledgment Number)（序列号+1）【用于指示下一个数据包序号】  
报头的长度(HLEN):以 32 字节为单位的报头长度  
保留域(Reserved)：设置为 0  
编码位(Code Bits):用于控制段的传输（如会话的建立和终止）  
包括：URG、ACK、PSH、RST、SYN、FIN 6 个位  
SYN（synchronous）：请求建立 TCP 连接  
FIN：断开 TCP 连接  
RST：重置 TCP 连接  
ACK：确认、反馈连接情况  
PSH：将数据立刻送到应用层进行处理的命令  
URG：判断紧急指针是否有效的命令  
窗口大小(Windows)：接收方能够继续接收的字节数【控制发送的速度】。只有 16bit，因此最大是 65535 字节。  
校验和(Checksum): 包括 TCP 报头和数据在内的校验和【判断数据传输是否出错】  
紧急指针(Urgent Pointer)：当前序列号到紧急位置的偏移量  
选项(Option)：厂商根据需要自定义的内容  
MAC 地址  
数据(Data)：上层协议数据

# 工作方式

![工作方式](/communication-protocol/tcpProcess.png)

建立连接  
三握  
建立连接是由 tcp 建立的。应用程序不需要担心如何建立。
![三次握手](/communication-protocol/tcp3.png)

1. 客户端发送 syn=1 seq=x 报文给服务器端，进入 SYN_SEND 状态。(SYN 报文段不能携带数据，但消耗一个序号)
2. 服务端收到 syn 报文后回应一个 syn seq=y ack（ack=x+1）报文，进入 SYN_RECV 状态。
3. 客户端收到服务器端的 syn 报文，回应一个 ack（ack=y+1）报文，进入 established 状态。
   （ack 码是前一次的 seq 码+1）

开始传输数据。

终止连接  
四挥  
由 tcp 的半关闭造成的。

1. 某个应用首先调用 close。该端执行“主动关闭”。该端发送一个 fin 分节，表示数据发送完毕。
2. 收到 fin 的对端执行“被动关闭”。
3. 一段时间后，接收到这个文件结束符的应用进程将调用 close 关闭它的套接字。这使得它的 tcp 也发送一个 fin.
4. 接收这个最终 fin 的原发送端 tcp 确认这个 fin.

![四挥](/communication-protocol/4bye.png)

## tcp/ip 的工作过程

1. 在源主机上，应用层将一串应用数据流传送给传输层。
2. 传输层将应用层的数据流截成分组，并加上 TCP 报头形成 TCP 段，送交网络层。
3. 在网络层给 TCP 段加上包括源、目的主机 IP 地址的 IP 报头，生成一个 IP 数据包，并将 IP 数据包送交链路层。
4. 链路层在其 MAC 帧的数据部分装上 IP 数据包，再加上源、目的主机的 MAC 地址和帧头，并根据其目的 MAC 地址，将 MAC 帧发往目的主机或 IP 路由器。
5. 在目的主机，链路层将 MAC 帧的帧头去掉，并将 IP 数据包送交网络层。
6. 网络层检查 IP 报头，如果报头中校验和与计算结果不一致，则丢弃该 IP 数据包；若校验和与计算结果一致，则去掉 IP 报头，将 TCP 段送交传输层。
7. 传输层检查顺序号，判断是否是正确的 TCP 分组，然后检查 TCP 报头数据。若正确，则向源主机发确认信息；若不正确或丢包，则向源主机要求重发信息。
8. 在目的主机，传输层去掉 TCP 报头，将排好顺序的分组组成应用数据流送给应用程序。这样目的主机接收到的来自源主机的字节流，就像是直接接收来自源主机的字节流一样。

# tcp & udp

<!-- prettier-ignore-start -->
|     | tcp  | udp        |     |
| --- | --- | ---- | --- |
|     | 面向连接  | 面向报文。无连接，只要知道对方ip地址就能发送。      |     |
|     | 有连接  | 无连接的数据报服务      |     |
|     | 高可靠性，确保数据传递正确（三握四挥）。不出现乱序、丢失。 | 在传递数据前不建立连接。不对数进行检查与修改。 |     |
|     |  | 有较好的实时性，工作效率高。      |     |
|     |  | 段结构简单，网络开销小。  |     |
||连接后才能通信|不需要双方连接，知道对应ip就能发送信息||
|||数据报<=64k（有效载荷是64k-8）||
||1v1|1v1/1vn/nv1/nvn||
||有分包能力|无分包能力||
<!-- prettier-ignore-end -->

# 指标

<!-- prettier-ignore-start -->
|  |    |     |     |
| ---- | --- | --- | --- |
| RTT 及其偏差（RTT 波动的值、方差，也叫抖动。） | round trip time |     |     |
|  |    |     |     |
|  |    |     |     |
<!-- prettier-ignore-end -->

# 丢包时发生什么

1. 丢包重传

```
client          server
|       syn        |
|----------------->| 1
|                  |
|     syn/ack      |
|<-----------------| 2
|                  |
|        ack       |
|----------------->| 3
|                  |
|                  |
```

1. 先来 3 次握手
2. 数据传递时，服务端每给客户端发一次数据，客户端都回复一个 ack.

```
client          server
|                  |
|    push/ack      |
|----------------->| 4
|        ack       |
|<-----------------| 5
|                  |
|    push/ack      |
|----------------->| 6
|        ack       |
|<-----------------| 7
|                  |
```

1. 再做 4 次挥手

```
client          server
|                  |
|     fin/ack      |
|----------------->| 8
|                  |
|     fin/ack      |服务端确定没有数据发送时，把fin和ack发送一起发给客户端
|<-----------------| 9
|                  |
|        ack       |
|----------------->| 10
|                  |然后各自断开连接
```

当 1 传送失败时，tcp 会重新发送 syn（`Retransmission`）。tcp 尝试 x 次后 tcp 才判定连接失败。
当 3 传送失败时，tcp 会重新发送 syn/ack（`Retransmission`）。因为双方要确认是否都在同一个连接上。不是就不发送数据。
当 4 传送失败时，tcp 连接不会断。程序也不会报错。
tcp 会重新发送数据（`Retransmission`）。tcp 尝试时间间隔会变长。宁可慢一点，也不跳过丢失的数据。即使后续数据已经到达，tcp 也不会交给应用层。tcp 的兜底方式是补齐，而不是绕过它。如果有数据一直无法到达，tcp 会放弃重传，最终断开连接。
Retransmission 是 tcp 重传数据的核心。确定数据完整性。
tcp 对待丢包是，会通过重试可保持连接稳定，确保数据舆不丢失。它是 tcp 作为可靠协议的核心特性之一。

次后 tcp 才判定连接失败。
当 7 传送失败时，tcp 会重新发送数据（`Retransmission`）。tcp 尝试 x 次后 tcp 才判定连接失败。
