<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>data-footstone</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="data-footstone">data-footstone</h1>
<h2 id="overview">overview</h2>
<blockquote>
<p>使用 ts 编写基本的数据结构。</p>
</blockquote>
<h3 id="feature">feature</h3>
<ul>
<li>stack</li>
<li>queue</li>
<li>hashMap</li>
<li>tree</li>
<li>graph 简单</li>
</ul>
<h2 id="install">install</h2>
<p><code>npm i data-footstone</code></p>
<h2 id="usage">usage</h2>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Stack</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;data-footstone&#x27;</span>
<span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>()
s.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
s.<span class="hljs-title function_">toArray</span>() <span class="hljs-comment">// [1,2,3,4]</span>
s.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 4</span>
s.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 3</span>
s.<span class="hljs-title function_">peek</span>() <span class="hljs-comment">// 2</span>
s.<span class="hljs-title function_">isEmpty</span>() <span class="hljs-comment">// false</span>
s.<span class="hljs-title function_">clear</span>() <span class="hljs-comment">// 清空栈</span>
</code></pre>
<h2 id="api">api</h2>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>stack</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new Statck&lt;T&gt;()</code></td>
<td></td>
<td>返回栈实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>stack#toArray() =&gt; T[]</code></td>
<td></td>
<td>返回栈内元素组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>stack#push(...p: T[]) =&gt; number</code></td>
<td></td>
<td>把参数依次入栈，返回栈的长度。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>stack#pop() =&gt; T</code></td>
<td></td>
<td>弹出栈顶元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>stack#peek() =&gt; T</code></td>
<td></td>
<td>返回栈顶元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>stack#isEmpty() =&gt; boolean</code></td>
<td></td>
<td>是否是空栈</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>stack#clear() =&gt; void</code></td>
<td></td>
<td>清空栈</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>stack#size() =&gt; number</code></td>
<td></td>
<td>返回栈大小</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>queue</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new Queue&lt;T&gt;()</code></td>
<td></td>
<td>返回队列实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#enqueue(...p: T[]) =&gt; number</code></td>
<td></td>
<td>把参数依次入队列，返回队列的长度。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#dequeue() =&gt; T</code></td>
<td></td>
<td>出队列</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#toArray() =&gt; T[]</code></td>
<td></td>
<td>队列内的元素组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#getHead() =&gt; T</code></td>
<td></td>
<td>返回队首元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#getTail() =&gt; T</code></td>
<td></td>
<td>返回队尾元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#size() =&gt; number</code></td>
<td></td>
<td>返回队列长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#isEmpty() =&gt; boolean</code></td>
<td></td>
<td>返回队列是否为空</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#clear() =&gt; void</code></td>
<td></td>
<td>清空队列</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>queue#reverse() =&gt; Queue</code></td>
<td></td>
<td>返回反向后的队列</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>PriorityQueue</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new PriorityQueue&lt;T&gt;(defaultPriority: N = 0)</code></td>
<td>defaultPriority 默认优先级</td>
<td>返回优先队列实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.highestPriority() =&gt; number | undefined</code></td>
<td></td>
<td>返回队列中元素的最高优先级</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.lowestPriority() =&gt; number | undefined</code></td>
<td></td>
<td>返回队列中元素的最低优先级</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.enqueue(element: T, priority: N = this.defaultPriority) =&gt; void</code></td>
<td></td>
<td>入优先队列，返回队列的长度。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.dequeue() =&gt; T | undefinde</code></td>
<td></td>
<td>返回出队列的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.getHead() =&gt; T | undefined</code></td>
<td></td>
<td>返回队列首的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.getTail() =&gt; T | undefined</code></td>
<td></td>
<td>返回队列尾的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.size() =&gt; number</code></td>
<td></td>
<td>返回队列的长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.isEmpty() =&gt; number</code></td>
<td></td>
<td>返回队列是否为空</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>priorityQueue.clear() =&gt; void</code></td>
<td></td>
<td>清空队列</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>SingleChain</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new SingleChain&lt;T&gt;(...p: T[])</code></td>
<td>p是由需要加入链表的元素组成的数组</td>
<td>返回单向链表实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain.head</code></td>
<td></td>
<td>返回链首</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain.length</code></td>
<td></td>
<td>返回链表长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#toArray() =&gt; T[]</code></td>
<td></td>
<td>返回由链表的元素组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#createNode(v: T, p: N) =&gt; SingleChainElement[]</code></td>
<td></td>
<td>内部使用的方法。用于创建单向链表的节点。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#append(v: T) =&gt; void</code></td>
<td></td>
<td>追回元素后返回链表长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#insert(v: T, p: N) =&gt; boolean</code></td>
<td></td>
<td>把指定元素插入到指定下标。返回是否插入成功。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#removeAt(p: N) =&gt; T | undefined</code></td>
<td></td>
<td>返回被移删的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#reverseSelft() =&gt; SingleChain</code></td>
<td></td>
<td>使用递归的方式反转链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#reverse() =&gt; SingleChain</code></td>
<td></td>
<td>使用循环的方式反转链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#clear() =&gt; void</code></td>
<td></td>
<td>清空链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#slice(from: N, to: N = this.length) =&gt; void</code></td>
<td></td>
<td>返回指定范围内的元素组成的单向链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>DoublyChain</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new DoublyChain&lt;T&gt;(...p: T[])</code></td>
<td>p是由需要加入链表的元素组成的数组</td>
<td>返回双向链表实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyChain.head</code></td>
<td></td>
<td>返回链首</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyChain.tail</code></td>
<td></td>
<td>返回链尾</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyChain.length</code></td>
<td></td>
<td>返回链表长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyChain#toArray() =&gt; T[]</code></td>
<td></td>
<td>返回由链表的元素组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyChain#append(v: T) =&gt; number</code></td>
<td></td>
<td>追回元素后返回链表长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyChain#insert(v: T, p: N) =&gt; boolean</code></td>
<td></td>
<td>把指定元素插入到指定下标。返回是否插入成功。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyChain#removeAt(p: N) =&gt; T | undefined</code></td>
<td></td>
<td>返回被移删的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyChain#clear() =&gt; void</code></td>
<td></td>
<td>清空链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>SingleCircleChain</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new SingleCircleChain&lt;T&gt;(...p: T[])</code></td>
<td>p是由需要加入链表的元素组成的数组</td>
<td>返回单向循环链表实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleCircleChain.head</code></td>
<td></td>
<td>返回链首</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleCircleChain.tail</code></td>
<td></td>
<td>返回链尾</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleCircleChain.length</code></td>
<td></td>
<td>返回链表长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleCircleChain#toArray() =&gt; T[]</code></td>
<td></td>
<td>返回由链表的元素组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleCircleChain#append(v: T) =&gt; number</code></td>
<td></td>
<td>追回元素后返回链表长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleCircleChain#insert(v: T, p: N) =&gt; boolean</code></td>
<td></td>
<td>把指定元素插入到指定下标。返回是否插入成功。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleCircleChain#removeAt(p: N) =&gt; T | undefined</code></td>
<td></td>
<td>返回被移删的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleCircleChain#clear() =&gt; void</code></td>
<td></td>
<td>清空链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>singleChain#slice(from: N, to: N = this.length) =&gt; void</code></td>
<td></td>
<td>返回指定范围内的元素组成的单向循环链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>DoublyCircleChain</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new DoublyCircleChain&lt;T&gt;(...p: T[])</code></td>
<td>p是由需要加入链表的元素组成的数组</td>
<td>返回双向循环链表实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyCircleChain.head</code></td>
<td></td>
<td>返回链首</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyCircleChain.tail</code></td>
<td></td>
<td>返回链尾</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyCircleChain.length</code></td>
<td></td>
<td>返回链表长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyCircleChain#toArray() =&gt; T[]</code></td>
<td></td>
<td>返回由链表的元素组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyCircleChain#append(v: T) =&gt; number</code></td>
<td></td>
<td>追回元素后返回链表长度</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyCircleChain#insert(v: T, p: N) =&gt; boolean</code></td>
<td></td>
<td>把指定元素插入到指定下标。返回是否插入成功。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyCircleChain#removeAt(p: N) =&gt; T | undefined</code></td>
<td></td>
<td>返回被移删的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>doublyCircleChain#clear() =&gt; void</code></td>
<td></td>
<td>清空链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>HashMap</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>hash方法</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>djb2HashFn: (k: A) =&gt; number</code></td>
<td></td>
<td>1013</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>loseloseHashFn: (k: A) =&gt; number</code></td>
<td></td>
<td>37</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>BinarySearchTree</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new BinarySearchTree&lt;T&gt;()</code></td>
<td></td>
<td>返回BST实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>root: BinarySearchTreeNodeOrNull&lt;T&gt;</code></td>
<td></td>
<td>根节点</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>createNode: (v: T) =&gt; BinarySearchTreeNode&lt;T&gt;</code></td>
<td></td>
<td>返回一个BST节点</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>insert: (v: T) =&gt; void</code></td>
<td></td>
<td>插入一个节点</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>search: (v: T) =&gt; boolean</code></td>
<td></td>
<td>查找树中是否存在指定的值。返回boolean。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>traverse: (fn: Function, order: BinarySearchTreeOrder) =&gt; void</code></td>
<td>`BinarySearchTreeOrder = 'preOrder'</td>
<td>'inOrder'</td>
<td>'postOrder'`。fn的参数是节点的value</td>
<td>使用指定顺序遍历树。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>`min: () =&gt; T</td>
<td>undefined`</td>
<td></td>
<td>返回树中最小的值</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>`max: () =&gt; T</td>
<td>undefined`</td>
<td></td>
<td>返回树中最大的值</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>findMinNode: (node: BinarySearchTreeNodeOrNull&lt;T&gt;) =&gt; BinarySearchTreeNodeOrNull&lt;T&gt;</code></td>
<td></td>
<td>返回指定节点下的最小的节点</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>findMaxNode: (node: BinarySearchTreeNodeOrNull&lt;T&gt;) =&gt; BinarySearchTreeNodeOrNull&lt;T&gt;</code></td>
<td></td>
<td>返回指定节点下的最大的节点</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>remove: (v: T) =&gt; void</code></td>
<td></td>
<td>移除指定值的节点</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>AVLTree</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>RedBackTree</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>``</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>order</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bubbleSort(arr: any[], order = 'asc') =&gt; any[]</code></td>
<td><code>order: 'asc' | 'des'</code></td>
<td>冒泡排序。返回排好序的arr。会改变arr内元素的顺序。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>selectSort(arr: any[], order = 'asc') =&gt; any[]</code></td>
<td><code>order: 'asc' | 'des'</code></td>
<td>选择排序。返回排好序的arr。会改变arr内元素的顺序。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>mergeSort(arr: any[], order = 'asc') =&gt; any[]</code></td>
<td><code>order: 'asc' | 'des'</code></td>
<td>归并排序。返回排好序的arr。会改变arr内元素的顺序。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>insertSort(arr: any[], order = 'asc') =&gt; any[]</code></td>
<td><code>order: 'asc' | 'des'</code></td>
<td>插入排序。返回排好序的arr。会改变arr内元素的顺序。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>quickSort(arr: any[], order = 'asc') =&gt; any[]</code></td>
<td><code>order: 'asc' | 'des'</code></td>
<td>快速排序。返回排好序的数组。不会改变arr内元素的顺序。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>versionOrder(arr: S[]) =&gt; S[]</code></td>
<td></td>
<td>快速排序。返回长序的数组。会改变arr内元素的顺序。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>Fifo</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new Fifo&lt;K, V&gt;(capacity: N) =&gt; Fifo</code></td>
<td>capacity是容量</td>
<td>返回先进先出的实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fifo.capacity</code></td>
<td></td>
<td>容量</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fifo.chain</code></td>
<td></td>
<td>缓存数据的单向链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fifo#get(k: K) =&gt; V | undefined</code></td>
<td></td>
<td>返回缓存中的指定key对应的数据</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fifo#put(k: K, v: V) =&gt; N</code></td>
<td></td>
<td>追加或设置缓存数据后返回缓存的大小</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fifo#size() =&gt; N</code></td>
<td></td>
<td>返回缓存的大小</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fifo#keys() =&gt; K[]</code></td>
<td></td>
<td>返回缓存中的数据中的key组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>fifo#values() =&gt; V[]</code></td>
<td></td>
<td>返回缓存中的数据中的value组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>Lru</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new Lru&lt;K, V&gt;(capacity: N) =&gt; Lru</code></td>
<td>capacity是容量</td>
<td>返回lru实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lru.capacity</code></td>
<td></td>
<td>容量</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lru.chain</code></td>
<td></td>
<td>缓存数据的双向链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lru.map</code></td>
<td></td>
<td>缓存key的表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lru#get(k: K) =&gt; v</code></td>
<td></td>
<td>返回缓存中的指定key对应的数据</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lru#put(k: K, v: V) =&gt; number</code></td>
<td></td>
<td>追加或设置缓存数据后返回缓存的大小</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lru#remove(k: K) =&gt; v | undefined</code></td>
<td></td>
<td>返回被删除的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lru#size() =&gt; number</code></td>
<td></td>
<td>返回缓存的数据条数</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th>Lfu</th>
<th>params</th>
<th>description</th>
<th>type</th>
<th>default</th>
<th>enum</th>
<th>demo</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new Lfu&lt;K, V&gt;(capacity: N) =&gt; Lfu</code></td>
<td>capacity是容量</td>
<td>返回lru实例</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lfu.capacity</code></td>
<td></td>
<td>容量</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lfu.chain</code></td>
<td></td>
<td>缓存数据的双向链表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lfu#get(k: K) =&gt; v</code></td>
<td></td>
<td>返回缓存中的指定key对应的数据</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lfu#put(k: K, v: V) =&gt; number</code></td>
<td></td>
<td>追加或设置缓存数据后返回缓存的大小</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lfu#remove(k: K) =&gt; v | undefined</code></td>
<td></td>
<td>返回被删除的元素</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>待开发</td>
</tr>
<tr>
<td><code>lfu#size() =&gt; number</code></td>
<td></td>
<td>返回缓存的数据条数</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lfu#keys() =&gt; K[]</code></td>
<td></td>
<td>返回缓存中由key组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>lfu#values() =&gt; V[]</code></td>
<td></td>
<td>返回缓存中由value组成的数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="principle">principle</h2>
<p>此包的处理逻辑。</p>
<h3 id="uml">uml</h3>
<pre><code>
</code></pre>
<h2 id="todo">todo</h2>
<blockquote>
<p>我现在正在找工作。我想找一个技术骨干或前端 Leader 的岗位。有团队需要增加人手的可以联系我。18515195415@163.com
未来迭代计划。
未来迭代计划。</p>
</blockquote>

        
        
    </body>
    </html>