- [data-footstone](https://www.npmjs.com/package/data-footstone)
  - stack
  - queue
  - chain
  - hashMap
  - binaryTree
    - bst
    - redBlockTree
    - splayTree
    - B-tree
- [temp](/coursera/dsa/temp.html)
- [sort](https://github.com/feigebaobei/simple/blob/master/packages/data-footstone/src/order.ts)
- [循环](/dsa/circulation.html)
- [递归](/dsa/recursion.html)
- [动态规划](/dsa/temp.html)
- [贪心算法](/dsa/temp.html)
- [基本算法](/dsa/basic.html)
- [tree](/dsa/tree.html)
- [bfs&dfs](/dsa/bfs&dfs.html)
- [temp](/dsa/temp.html)
- [temp](/dsa/temp.html)
- [temp](/dsa/temp.html)
- title
- title
- title
- title

空间复杂度、时间复杂度
Big-O 表示算法在数据量 n 变大时，算法运行时间的复杂度。

O(1)
总是不变，一般不会出现。

O(logn)
很好。

O(n)
大多数情况下可以接受。

O(nlogn)
这就是你使用高效排序设定的。

O(n^2)
需要优化
空间复杂度、时间复杂度可以解决什么？
