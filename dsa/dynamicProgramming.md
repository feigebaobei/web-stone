# 动态规划（英语：Dynamic programming，简称 DP）

动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费不必要的时间。
动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解

## 核心思想与要素

分而治之：将原问题拆解为多个子问题，逐个求解。
记忆化存储：保存已解决的子问题答案，避免重复计算，用空间换时间。
三个基本条件：
最优子结构：大问题的最优解可以由小问题的最优解组合而成。
重叠子问题：递归过程中子问题会被反复计算。
无后效性：某阶段的状态一旦确定，之后决策与如何达到此状态无关。
状态转移方程：定义子问题之间递推关系的数学表达式。

## 动态规划的解题步骤

定义状态：明确 (dp[i]) 或 (dp[i][j]) 的含义（例如：前 (i) 个物品的最大价值）。
找出状态转移方程：寻找小问题与大问题之间的逻辑关系，如：(dp[i]=max(dp[i-1],dp[i-2]+value))。
确定初始状态与边界条件：明确最小子问题的解。
确定计算顺序：通常为自底向上（从基础解到最终解）。

## 常见应用

背包问题（0/1 背包、完全背包）。
最长公共子序列 (LCS)。
最短路径问题 (Dijkstra, Floyd-Warshall)。
斐波那契数列。

## 常见问题

上阶梯

```js
let f = (n) => {
  if (n <= 0) {
    return 1
  }
  let dp = [1, 2]
  for (let i = 3; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}
```

## title

## title
