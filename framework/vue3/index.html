<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>vue</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="vue">vue</h1>
<h2 id="overview">overview</h2>
<blockquote>
<p>渐进式框架</p>
</blockquote>
<h3 id="feature">feature</h3>
<ul>
<li>增强静态 html.不参与build</li>
<li>以 webComponents 嵌入到现有页面中。</li>
<li>spa</li>
<li>ssr</li>
<li>ssg</li>
<li>可开发 desktop / mobile / webgl / terminal</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>sfa</td>
<td>single-file components</td>
<td>单文件组件。<code>*.vue</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="install">install</h2>
<p><code>npm i vue</code></p>
<h3 id="cdn">cdn</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 id="下载并自托管">下载并自托管</h3>
<p>下载 vue 的 js 文件后放在自己的服务器上。在前端项目中使用自己服务器上的 js 文件。</p>
<h3 id="npm">npm</h3>
<p>用于构建大型应用。需要与打包工具一起使用。</p>
<pre><code class="language-shell">npm i vue@next
</code></pre>
<p>创建单文件组件。</p>
<pre><code class="language-shell">npm i -D @vue/compiler-sfc
</code></pre>
<h3 id="cli">cli</h3>
<pre><code class="language-shell">npm i -g @vue/cli  # vue3对应的是@vue/cli v4.5
yarn global add @vue/cli
</code></pre>
<h3 id="vite"><a href="/framework/vue3/vite.html">vite</a></h3>
<p>vue 团队开发的 web 开发构建工具。react 团队都计划使用 vite 取代 cra 了。</p>
<pre><code class="language-shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">npm 6.x</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">npm init vite@latest &lt;project-name&gt; --template vue</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">npm 7+，需要加上额外的双短横线</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">npm init vite@latest &lt;project-name&gt; -- --template vue</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> &lt;project-name&gt;</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">npm install</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">npm run dev</span>
<span class="hljs-meta prompt_">
$ </span><span class="language-bash">yarn create vite &lt;project-name&gt; --template vue</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> &lt;project-name&gt;</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">yarn</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">yarn dev</span>
<span class="hljs-meta prompt_">
$ </span><span class="language-bash">pnpm create vite &lt;project-name&gt; -- --template vue</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> &lt;project-name&gt;</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">pnpm install</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">pnpm dev</span>
</code></pre>
<h2 id="usage">usage</h2>
<p>从创建应用开始</p>
<pre><code class="language-js">&lt;div id=<span class="hljs-string">&quot;&quot;</span>&gt;
    <span class="hljs-title class_">Counter</span>: {{counter}}
    &lt;span v-<span class="hljs-attr">bind</span>:title=<span class="hljs-string">&quot;message&quot;</span>&gt;&lt;<span class="hljs-regexp">/span&gt; /</span><span class="hljs-regexp">/ 绑定属性
    &lt;button v-on:click=&quot;clickHandler&quot;&gt;button&lt;/</span>button&gt;
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;</span></span>
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>str<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;forHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span> <span class="hljs-comment">// 不要把用户输入的数据直接显示，防止xss攻击。</span>
&lt;/div&gt;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Counter</span> = { 
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;str&#x27;</span>,
      <span class="hljs-attr">seen</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">forHtml</span>: <span class="hljs-string">&#x27;&lt;span&gt;hi&lt;/span&gt;&#x27;</span>
    }
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">clickHandler</span>(<span class="hljs-params"></span>) {...}
  }
}
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">Counter</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#id&#x27;</span>)
</code></pre>
<h3 id="创建项目"><a href="/framework/vue3/demo.html">创建项目</a></h3>
<h2 id="性能--优化"><a href="/framework/vue3/performation.html">性能 &amp; 优化</a></h2>
<h2 id="vue3--ts"><a href="/framework/vue3/vue3&amp;ts.html">vue3 + ts</a></h2>
<h2 id="使用方法"><a href="/framework/vue3/wayOfUsing.html">使用方法</a></h2>
<h2 id="principle"><a href="/framework/vue3/principle.html">principle</a></h2>
<h2 id="vue2--vue3"><a href="/framework/vue3/vue2&amp;vue3.html">vue2 &amp; vue3</a></h2>
<h2 id="title">title</h2>
<h2 id="title">title</h2>
<h3 id="组件树">组件树</h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TodoItem</span> = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;li&gt;string&lt;/li&gt;`</span>,
}
<span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({
  <span class="hljs-attr">components</span>: {
    <span class="hljs-comment">// 注册全局组件</span>
    <span class="hljs-title class_">TodoItem</span>,
  },
})
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#id&#x27;</span>)
</code></pre>
<h3 id="运行时--编译器-vs-仅运行时">运行时 + 编译器 vs. 仅运行时</h3>
<pre><code class="language-js"><span class="hljs-comment">// 需要编译器</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;{{hi}}&lt;/div&gt;&#x27;</span>,
})
<span class="hljs-comment">// 不需要编译器</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, <span class="hljs-variable language_">this</span>.<span class="hljs-property">hi</span>)
  },
})
</code></pre>
<p>当在客户端上编译模板时（即：把字符串给 template 选项，或者在元素 dom 内使用 html 为模板），需要完整的构建版本。<br>
打包时使用<code>vue-loader</code>处理<code>*.vue</code>文件为 js。所以在客户端只需要构建版本。</p>
<h2 id="指令">指令</h2>
<ul>
<li>以<code>v-</code>开头。</li>
<li><code>v-bind</code>简写为<code>:</code>
<ul>
<li>支持一个参数，如：<code>:href=&quot;url&quot;</code></li>
<li>动态参数 <code>:[attr]=&quot;url&quot;</code></li>
</ul>
</li>
<li><code>v-on</code>简写为<code>@</code>
<ul>
<li>修饰符，用于<code>v-on</code>指令上。
<ul>
<li><code>.prevent</code> 阻止默认事件</li>
<li>还有好多修饰符</li>
</ul>
</li>
</ul>
</li>
<li>应用于一个根元素上。当多个元素时，会报错。</li>
</ul>
<h3 id="自定义指令">自定义指令</h3>
<p><code>v-dir:[arg]=&quot;value&quot;</code></p>
<ul>
<li>操作 dom</li>
<li>抽象跨组件逻辑</li>
<li>一般无 dom</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 全局</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({})
app.<span class="hljs-title function_">direction</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, {
    <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) { el.<span class="hljs-title function_">focus</span>() }
})
<span class="hljs-comment">// 局部</span>
<span class="hljs-attr">directives</span>: {
    <span class="hljs-attr">focus</span>: { <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) {el.<span class="hljs-title function_">focus</span>()} }
}
<span class="hljs-comment">//使用</span>
&lt;input v-focus /&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>钩子</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>created</td>
<td>在绑定元素的 attribute 或事件监听器被应用之前调用。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>beforeMount</td>
<td>指令第一次绑定到元素并且在挂载父组件之前调用。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mounted</td>
<td>在绑定元素的父组件被挂载后调用。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>在更新包含组件的 VNode 之前调用。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>updated</td>
<td>在包含组件的 VNode 及其子组件的 VNode 更新后调用。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>beforeUnmount</td>
<td>在卸载绑定元素的父组件之前调用</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>unmounted</td>
<td>当指令与元素解除绑定且父组件已卸载时，只调用一次。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>参数都是<code>el/binding/vnode/prevVnode</code></p>
<h2 id="data">data</h2>
<p>在组件中定义了 data 属性（其值是方法）中的数据会被封装在组件实例的<code>$data</code>属性内。（为方便）也在组件实例的顶级属性（与$data兄弟级）中设置了这些属性。因此可以在组件的template中直接使用这些属性。<br>
<code>vm.key</code>、<code>$data.key</code>与<code>vm.$data.key</code>是同一个值。</p>
<h2 id="methods">methods</h2>
<p>vue 为每个方法方法绑定 this 为当前组件。<br>
不要使用箭头函数。否则会引发 this 不正确的问题。</p>
<h3 id="参数">参数</h3>
<p>绑定内联写法中使用<code>$event</code>表示原生事件。</p>
<h2 id="计算">计算</h2>
<p>计算属性的 getter 函数没有副作用，它更易于测试和理解。<br>
包含响应式数据的复杂逻辑</p>
<pre><code class="language-js"><span class="hljs-attr">computed</span>: {
    <span class="hljs-attr">fullName</span>: {
        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {...},
        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) { ... }
    }
}
<span class="hljs-comment">// 设置</span>
vm.<span class="hljs-property">fullName</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>
<span class="hljs-comment">// 获取</span>
vm.<span class="hljs-property">fullName</span>
</code></pre>
<h2 id="watch">watch</h2>
<p>当指定数据改变时执行。<br>
可执行异步操作。<br>
<code>vm.$watch</code></p>
<pre><code class="language-js"><span class="hljs-attr">watch</span>: { <span class="hljs-title function_">question</span>(<span class="hljs-params">nv, ov</span>) { ... } }
</code></pre>
<h2 id="computed--watch--methods">computed &amp; watch &amp; methods</h2>
<p>为什么计算执行同步，watch 执行异步？</p>
<table>
<thead>
<tr>
<th></th>
<th>computed</th>
<th>watch</th>
<th>methods</th>
</tr>
</thead>
<tbody>
<tr>
<td>适用场景</td>
<td>包含响应式数据的复杂逻辑</td>
<td>watch</td>
<td>methods</td>
</tr>
<tr>
<td></td>
<td>会缓存结果</td>
<td>不缓存结果</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td>会缓存结果</td>
<td>当需要变化时执行异步或开销较大的操作</td>
<td>-</td>
</tr>
<tr>
<td>结合使用</td>
<td>computed + methods</td>
<td>watch + methods</td>
<td>methods + methods</td>
</tr>
<tr>
<td></td>
<td>-</td>
<td>侦听器</td>
<td>方法（可复用）</td>
</tr>
<tr>
<td>相同</td>
<td>都是对象</td>
<td>都是对象</td>
<td>都是对象</td>
</tr>
</tbody>
</table>
<h2 id="class--style">class &amp; style</h2>
<p>二者都是样式</p>
<h3 id="class">class</h3>
<pre><code>// 对象语法
&lt;div :class=&quot;{class-name: params}&quot;&gt;
&lt;div :class=&quot;{class-name: params, key: p2}&quot;&gt; // 对象中多个属性就是多个class
// 计算属性
&lt;div :class=&quot;compClass&quot;&gt;
...
computed: {
    compClass() {
        return {color: 'red'}
    }
}
// 数组语法 可以设置多个类
&lt;div :class=&quot;[aC, bC]&quot;&gt;
...
data() {
    return {
        aC: 'aa',
        bC: 'bb',
    }
}
// 组件上使用
&lt;comp class=&quot;a b&quot; /&gt; // 与内部class合并。
</code></pre>
<h3 id="style">style</h3>
<pre><code class="language-js"><span class="hljs-comment">// 对象语法</span>
&lt;div :style=<span class="hljs-string">&quot;{color: dColor}&quot;</span>&gt;
...
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">dColor</span>: <span class="hljs-string">&#x27;red&#x27;</span>
    }
}
&lt;div :style=<span class="hljs-string">&quot;sObj&quot;</span> /&gt;
...
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">sObj</span>: {
            <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>
        }
    }
}
<span class="hljs-comment">// 数组语法 把多个样式对象合并为一个</span>
&lt;div :style=<span class="hljs-string">&quot;[aS, bS]&quot;</span> /&gt;
<span class="hljs-comment">// 多重值 从数组中使用最后一个被浏览器支持的值。</span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;{display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;]}&quot;</span>&gt;</span>
</span></code></pre>
<p>vue 会使用<code>vendor prefix</code>添加样式前缀。</p>
<h2 id="常用指令">常用指令</h2>
<h3 id="条件渲染">条件渲染</h3>
<pre><code class="language-js">v-<span class="hljs-keyword">if</span> v-<span class="hljs-keyword">else</span> 必须紧跟在v-<span class="hljs-keyword">if</span>后面 v-<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>
&lt;template v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;params&quot;</span>&gt;
  用分组。与v-<span class="hljs-keyword">for</span>分开。template不会渲染为可岁元素 v-show
&lt;/template&gt;
</code></pre>
<h3 id="列表渲染-v-for">列表渲染 v-for</h3>
<p>可用<code>v-for=&quot;(item, index) in arr&quot;</code>
也可用<code>v-for=&quot;(item, index) of arr&quot;</code>
可能是 vue 出生是<code>for...of</code>还未出生。vue 使用 for...in 处理循环。后来 for...of 出生了。vue 使用了与其相同的写法，也兼容了以前的写法。</p>
<pre><code class="language-js">&lt;ul&gt;
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;value.id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name) in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
&lt;/ul&gt;
</code></pre>
<p>遍历对象时，是按照<code>Object.keys()</code>遍历的。</p>
<h4 id="数组更新检测">数组更新检测</h4>
<p>vue 把改变数组的方法进行了封装。（为了实现响应式）。</p>
<ul>
<li>push</li>
<li>pop</li>
<li>shift</li>
<li>unshift</li>
<li>splice</li>
<li>sort</li>
<li>reverse</li>
</ul>
<h3 id="v-if--v-for--v-show">v-if &amp; v-for &amp; v-show</h3>
<table>
<thead>
<tr>
<th></th>
<th>v-if</th>
<th>v-for</th>
<th>v-show</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>可以与 templata 标签一起使用</td>
<td>可以与 templata 标签一起使用</td>
<td>不可以与 templata 标签一起使用</td>
</tr>
<tr>
<td></td>
<td>v-if 的优先级大于 v-for</td>
<td>不要在同一元素上使用 v-if v-show</td>
<td></td>
</tr>
<tr>
<td></td>
<td>在编译阶段处理</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="事件">事件</h3>
<p><code>v-on</code>指令会为 dom 添加事件。
react 中是在 vdom 上添加事件的。</p>
<pre><code class="language-js"><span class="hljs-comment">// 绑定方法名</span>
&lt;button @click=<span class="hljs-string">&quot;clickHander&quot;</span>&gt;str&lt;/button&gt;
... <span class="hljs-attr">methods</span>: { <span class="hljs-title function_">clickHander</span>(<span class="hljs-params">event</span>) {...} } <span class="hljs-comment">// 绑定内联方法</span>
&lt;button @click=<span class="hljs-string">&quot;clickHander(&#x27;params&#x27;)&quot;</span>&gt;str&lt;/button&gt;
<span class="hljs-comment">// 得到原生事件</span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;clickHander(&#x27;params&#x27;, $event)&quot;</span>&gt;</span>str<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="hljs-comment">// vue也有硬编码 clickHander(msg, event) {...} // 绑定多个事件</span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;one(&#x27;params&#x27;), two&quot;</span>&gt;</span>str<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
</code></pre>
<h4 id="修饰符">修饰符</h4>
<p>事件修饰符</p>
<ul>
<li>.stop</li>
<li>.prevent</li>
<li>.capture</li>
<li>.self</li>
<li>.once</li>
<li>.passive</li>
</ul>
<p>按键修饰符</p>
<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete (删除和退格键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<p>系统修饰键</p>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<p>严格修饰符</p>
<ul>
<li>.exact</li>
</ul>
<p>鼠标修饰符</p>
<ul>
<li>.left</li>
<li>.right</li>
<li>.middle</li>
</ul>
<p>v-model 的修饰符</p>
<ul>
<li>.lazy // input 事件改为 change 事件</li>
<li>.number // 若能被 parseFloat()处理，则返回 number.否则返回 string.</li>
<li>.trim // 去掉首尾空格</li>
</ul>
<h4 id="vue-事件--react-事件">vue 事件 &amp; react 事件</h4>
<table>
<thead>
<tr>
<th></th>
<th>vue 事件</th>
<th>react 事件</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>绑定到 dom 上</td>
<td>绑定到 vdom 上</td>
</tr>
<tr>
<td></td>
<td>原生 dom 的事件</td>
<td>合成事件</td>
</tr>
<tr>
<td></td>
<td>有原生事件对应的修饰符等</td>
<td>无</td>
</tr>
<tr>
<td></td>
<td>当 vdom(dom)被销毁时，绑定的事件也一起被销毁。</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="表单输入绑定">表单输入绑定</h2>
<p>一般使用<code>v-model</code>。它为表单元素提供了双向数据绑定的语法糖。<br>
当使用输入法时不会在组织文字时触发 input.(可能内部使用了<code>xxxx</code>)</p>
<pre><code class="language-js"><span class="hljs-comment">// text</span>
&lt;input v-model=<span class="hljs-string">&quot;msg&quot;</span> /&gt;
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> {<span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;&#x27;</span>} } <span class="hljs-comment">// textarea</span>
&lt;textarea v-model=<span class="hljs-string">&quot;msg&quot;</span> /&gt;
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">return</span> {<span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;&#x27;</span>}} <span class="hljs-comment">// checkbox</span>
&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;checked&quot;</span> /&gt;
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">return</span> {<span class="hljs-attr">checkbox</span>: <span class="hljs-literal">false</span>}} <span class="hljs-comment">//</span>
一般单个复选框使用boolean,多个复选框使用数组。 <span class="hljs-comment">//</span>
&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> value=<span class="hljs-string">&quot;one&quot;</span> v-model=<span class="hljs-string">&quot;arr&quot;</span> /&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;two&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;arr&quot;</span> /&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;three&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;arr&quot;</span> /&gt;</span></span>
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">return</span> {<span class="hljs-attr">arr</span>: [<span class="hljs-string">&#x27;two&#x27;</span>]}} <span class="hljs-comment">// 设置默认选中值 // radio</span>
&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> value=<span class="hljs-string">&quot;one&quot;</span> id=<span class="hljs-string">&quot;radio&quot;</span> v-model=<span class="hljs-string">&quot;picked&quot;</span> /&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;two&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;picked&quot;</span> /&gt;</span></span>
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">return</span> {<span class="hljs-attr">picked</span>: <span class="hljs-string">&#x27;&#x27;</span>}} <span class="hljs-comment">// radio一般于字符串绑定 // select</span>
&lt;select v-model=<span class="hljs-string">&quot;selected&quot;</span>&gt;
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in arr&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value.v&quot;</span>&gt;</span>{{index}}: {{name}} {{value.label}}<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span>
&lt;/select&gt;
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">return</span> {<span class="hljs-attr">arr</span>: [...], <span class="hljs-attr">selected</span>: <span class="hljs-string">&#x27;&#x27;</span>}} <span class="hljs-comment">//</span>
单选时又是与字符串绑定。官网在多选时使用了字符串。经过测试可以使用数组。感觉数组更适合多选。
</code></pre>
<h3 id="值绑定">值绑定</h3>
<pre><code class="language-js">&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> v-model=<span class="hljs-string">&quot;picked&quot;</span> value=<span class="hljs-string">&quot;a&quot;</span>&gt; <span class="hljs-comment">// 单选框一般与字符串绑定。</span>
&lt;input type=&quot;checkbox&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt; // 多选框可以与字符串、boolean、数组绑定。
&lt;select v-model=&quot;selected&quot;&gt;...&lt;/select&gt; // 下拉选择器可以与字符串、数组绑定。
&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot;&gt; // 绑定真值与假值
&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;a&quot;&gt; // 选中时pick为变量a的值
&lt;select&gt;
    &lt;option :value=&quot;{number: 123}&quot;&gt;12345&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h3 id="如何处理-input--checkbox--radio--select">如何处理 input &amp; checkbox &amp; radio &amp; select</h3>
<table>
<thead>
<tr>
<th></th>
<th>input</th>
<th>checkbox</th>
<th>select</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>text &amp; textarea</td>
<td>checkbox &amp; radio</td>
<td>select</td>
<td></td>
</tr>
<tr>
<td></td>
<td>value + input</td>
<td>checked + change</td>
<td>value + change</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="组件"><a href="/framework/vue3/component.html">组件</a></h2>
<pre><code class="language-js"><span class="hljs-comment">// 创建组件 let app = Vue.createApp({}) // 定义为全局组件</span>
app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }
  },
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
&lt;button @click=&quot;count++&quot;&gt;{{count}}&lt;/button&gt;
`</span>,
})
</code></pre>
<h3 id="props">props</h3>
<p>子组件使用 props 属性接收从父组件来的数据。</p>
<pre><code class="language-js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
&lt;span&gt;{{title}}&lt;/span&gt;
`</span>,
})
</code></pre>
<h3 id="emit">$emit</h3>
<p>用于触发父组件来的事件。</p>
<pre><code class="language-js">&lt;comp-name @event-name=<span class="hljs-string">&quot;fn(p)&quot;</span>&gt;&lt;/comp-name&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;event-name&#x27;)&quot;</span>&gt;</span>sss<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
$emit(<span class="hljs-string">&#x27;event-name&#x27;</span>, params)
</code></pre>
<h3 id="v-model">v-model</h3>
<p>用于 input(text)时，等价于 value + input</p>
<pre><code class="language-js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> :value=<span class="hljs-string">&quot;dValue&quot;</span> @input=<span class="hljs-string">&quot;dValue = $event.target.value&quot;</span> /&gt;
</code></pre>
<p>用于组件时，</p>
<pre><code class="language-js">&lt;comp-name
  :model-value=<span class="hljs-string">&quot;dValue&quot;</span>
  @<span class="hljs-attr">update</span>:model-value=<span class="hljs-string">&quot;dValue = $event&quot;</span>
&gt;&lt;/comp-name&gt;
app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, { <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>], <span class="hljs-attr">emits</span>:
[<span class="hljs-string">&#x27;update:modelValue&#x27;</span>], <span class="hljs-attr">template</span>: <span class="hljs-string">`xxx`</span> })
</code></pre>
<h4 id="为什么命名方式不同">为什么命名方式不同</h4>
<p>html 中不区分大小写。vue 在内部做了命名转化。</p>
<h3 id="插槽">插槽</h3>
<h3 id="动态组件">动态组件</h3>
<pre><code class="language-js">&lt;component :is=<span class="hljs-string">&quot;currentTabComponent&quot;</span> /&gt;
</code></pre>
<p>必须使用<code>&lt;component&gt;</code>标签<br>
currentTabComponent 是</p>
<ul>
<li>已经注册的组件名</li>
<li>一个组件选项对象</li>
</ul>
<h3 id="异步组件">异步组件</h3>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">defineAsyncComponent</span>(
  <span class="hljs-function">() =&gt;</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">s, j</span>) =&gt;</span> {
      <span class="hljs-title function_">s</span>({
        <span class="hljs-attr">template</span>: <span class="hljs-string">`
&lt;div&gt;str&lt;/div&gt;
`</span>,
      })
    })
)
</code></pre>
<h3 id="单文件组件">单文件组件</h3>
<p>使用<a href="/jsPackages/compilerSfc.html"><code>@vue/compiler-sfc</code></a>编译</p>
<h2 id="处理边界情况">处理边界情况</h2>
<p>强制更新 $forceUpdate
低级静态组件 v-once 只求值一次。</p>
<h2 id="过滤--动画"><a href="/framework/vue3/translate.html">过滤 &amp; 动画</a></h2>
<h2 id="api"><a href="/framework/vue3/api.html">api</a></h2>
<p>Vue.createApp({...})<br>
返回一个全局组件。react 在 18 以后也有了创建根组件的方法。<br>
该组件的大部分方法可以链式调用。<br>
除了<code>mount()</code>等。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="vue-组件实例">vue 组件实例</h2>
<ul>
<li>其内置的属性是以<code>$</code>开头的。</li>
<li>保留了以<code>_</code>开头的属性。<br>
尽量不要动这样的属性。</li>
</ul>
<h2 id="生命周期">生命周期</h2>
<p><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="生命周期"></p>
<p>不要在生命周期方法上使用箭头函数，会影响 this 指向。</p>
<table>
<thead>
<tr>
<th></th>
<th>选项式 api</th>
<th>hook inside setup</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>beforeCreate</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td>created</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td>beforeMount</td>
<td>onBeforeMount</td>
</tr>
<tr>
<td></td>
<td>mounted</td>
<td>onMounted</td>
</tr>
<tr>
<td></td>
<td>beforeUpdate</td>
<td>onBeforeUpdate</td>
</tr>
<tr>
<td></td>
<td>updated</td>
<td>onUpdated</td>
</tr>
<tr>
<td></td>
<td>beforeUnmount</td>
<td>onBeforeUnmount</td>
</tr>
<tr>
<td></td>
<td>unmounted</td>
<td>onUnmounted</td>
</tr>
<tr>
<td></td>
<td>errorCaptured</td>
<td>onErrorCaptured</td>
</tr>
<tr>
<td></td>
<td>renderTracked</td>
<td>onRenderTracked</td>
</tr>
<tr>
<td></td>
<td>renderTriggered</td>
<td>onRenderTriggered</td>
</tr>
<tr>
<td></td>
<td>activated</td>
<td>onActivated</td>
</tr>
<tr>
<td></td>
<td>deactivated</td>
<td>onDeactivated</td>
</tr>
</tbody>
</table>
<h2 id="组件间传递数据"><a href="/framework/dataTrasmit/index.html">组件间传递数据</a></h2>
<h2 id="模板引用">模板引用</h2>
<p>就是在父组件上使用<code>ref</code>属性。<br>
然后在 js 中使用<code>this.$refs.xxx</code>或者<code>xxx.value</code></p>
<pre><code>&lt;template&gt;
  // 使用
  &lt;div ref=&quot;root&quot;&gt;...&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import {ref, onMounted} form 'vue'
export default {
    setup() {
        let root = ref(null) // 搞成响应式
        onMounted(() =&gt; {
            clog(root.value) // 获取
        })
        // watch() 和 watchEffect() 在 DOM 挂载或更新之前运行副作用，所以当侦听器运行时，模板引用还未被更新。
        watchEffect(() =&gt; {
            console.log(root.value)
        }, {
            flush: 'post' // 这将在 DOM 更新后运行副作用，确保模板引用与 DOM 保持同步，并引用正确的元素。
        })
    }
}
&lt;/script&gt;
</code></pre>
<h3 id="ref--ref--torefs--refs--ref">ref &amp; :ref &amp; toRefs &amp; $refs &amp; $Ref</h3>
<p>它们都是来自<code>reference</code>.<br>
v2 中只用于模板引用。到 v3 时多了响应式。<br>
vue 中还好多为了兼容以前的功能、逻辑、用法。搞的乱乱的代码。</p>
<table>
<thead>
<tr>
<th></th>
<th>ref</th>
<th>:ref</th>
<th>toRefs</th>
<th>$refs</th>
<th>Ref</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>为基本类型数据做响应式</td>
<td>template 中调用 ref 后，可以模板引用。</td>
<td>把响应式对象解构为多个响应式元素</td>
<td>用于模板引用</td>
<td></td>
</tr>
<tr>
<td>用法</td>
<td><code>let a = ref(null)</code></td>
<td><code>&lt;div ref=&quot;rp&quot; /&gt;</code></td>
<td><code>toRefs(reactiveObject)</code></td>
<td><code>this.$refs.xxx</code>取得模板，得到 dom 元素</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="watch--watcheffect"><a href="/framework/vue3/watch&amp;WatchEffect.html">watch &amp; watchEffect</a></h2>
<h2 id="mixin">mixin</h2>
<p>把可在组件中复用的部分（逻辑、功能）提取成为一个 mixin 对象。</p>
<ul>
<li>data/methods/components/directive 会合并。本组件优先。</li>
<li>生命周期方法都会执行，先执行 mixin 对象里的，再执行本组件里的。</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 定义全局</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({...})
app.<span class="hljs-title function_">mixin</span>({
    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) {...}
})
<span class="hljs-comment">// 定义局部 组件内</span>

</code></pre>
<h2 id="teleport">teleport</h2>
<p>将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置。<br>
挂载到目标元素的内部后面。</p>
<pre><code class="language-js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
&lt;button /&gt;
&lt;teleport to=&quot;body&quot;&gt;
            ...
        &lt;/teleport&gt;
`</span>,
})
</code></pre>
<h2 id="渲染函数">渲染函数</h2>
<p>使用 js 方法（<code>h / createVNode</code>）编写组件。与 sfc 功能等价。<br>
官网举了一个“动态 dom 标签”的例子。<br>
一般用于在组件模版需要更灵活时</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { createApp, h } = <span class="hljs-title class_">Vue</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>()
app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">level</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">level</span>, {}, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-title function_">default</span>())
  },
})
</code></pre>
<pre><code class="language-js"><span class="hljs-title function_">h</span>(
  tag, <span class="hljs-comment">// String | Object | Function  一个html标签名、一个组件、一个异步组件、一个函数式组件</span>
  props, <span class="hljs-comment">// Object</span>
  children <span class="hljs-comment">// String | Array | Object  需要唯一</span>
)
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 所有事件名都是on+大驼峰命名，可以再加大驼峰的事件修饰符。 const {h,</span>
resolveDomponent, resolveDynamicComponent, resolveDirective, withDirectives} =
<span class="hljs-title class_">Vue</span> app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, { <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {...}, <span class="hljs-comment">// 在插槽函数外面调用 let CompNameA</span>
= <span class="hljs-title function_">resolveComponent</span>(<span class="hljs-string">&#x27;comp-name-a&#x27;</span>) <span class="hljs-comment">// 解构全局组件 let CompNameB =</span>
<span class="hljs-title function_">resolveDynamicComponent</span>(<span class="hljs-string">&#x27;comp-name-b&#x27;</span>) <span class="hljs-comment">// 解构全局动态组件 //</span>
&lt;comp-name-b :is=<span class="hljs-string">&quot;xxx&quot;</span> /&gt;
<span class="hljs-comment">// keep-alive transition transition-group teleport</span>
不需要使用resolveComponent处理。直接从<span class="hljs-title class_">Vue</span>中取出后使用。 <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span>
<span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;a-name&#x27;</span>, { <span class="hljs-comment">// v-model modelValue: xxx, &#x27;onUpdate:modelValue&#x27;: v =&gt;</span>
<span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, v), <span class="hljs-comment">// 事件 &#x27;onClickCapture&#x27;: this.fn, }, { //</span>
设置插槽 <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-title function_">default</span>(), <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-title function_">slotName</span>({<span class="hljs-attr">k</span>: v}), <span class="hljs-comment">// 作用域插槽 //</span>
使用插槽 <span class="hljs-attr">slotName</span>: <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> <span class="hljs-title function_">h</span>(...) }) } <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">let</span> pin =
<span class="hljs-title function_">resolveDirective</span>(<span class="hljs-string">&#x27;pin&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">withDirectives</span>(<span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, [ [pin, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;top&#x27;</span>,
{<span class="hljs-attr">animate</span>: <span class="hljs-literal">true</span>}] ])) } })
</code></pre>
<p>当使用<code>@vue/babel-plugin-jsx</code>时，可以在 vue 文件中使用 jsx 语法。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">CompName</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CompName.vue&#x27;</span> <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>({ <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span>
(
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CompName</span>&gt;</span>
        ...
        <span class="hljs-tag">&lt;/<span class="hljs-name">CompName</span>&gt;</span></span>
) } }) app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#root&#x27;</span>)
</code></pre>
<h2 id="插件">插件</h2>
<p>插件是自包含的代码，通常向 Vue 添加全局级功能。它可以是公开 install() 方法的 object，也可以是 function
组件库就是使用公开 install()添加组件的。</p>
<h3 id="编写插件">编写插件</h3>
<pre><code class="language-js"><span class="hljs-comment">// plugins/first.js</span>
<span class="hljs-comment">// 公开install方法</span>
<span class="hljs-comment">// vue会自动调用install()</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">install</span>: (app, options) {...}
}
<span class="hljs-comment">// 当插件是一个方法</span>
<span class="hljs-comment">// vue会自动调用此方法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {...}
</code></pre>
<h3 id="使用插件">使用插件</h3>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Root</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>
<span class="hljs-keyword">import</span> first <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./plugins/first.js&#x27;</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(root)
app.<span class="hljs-title function_">use</span>(first, opt)
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#root&#x27;</span>)
</code></pre>
<h2 id="响应式">响应式</h2>
<ul>
<li>proxy 对象无法对基本类型的数据做响应式，所以 vue3 把基本类型的数据转化为<code>{value: xx}</code>。</li>
<li>基本响应式 api 是 reactive。ref 是基于 reactive 开发出来的。</li>
<li>readonly 可防止修改响应式对象</li>
</ul>
<h3 id="reactive--ref">reactive &amp; ref</h3>
<table>
<thead>
<tr>
<th></th>
<th>reactive</th>
<th>ref</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>用法</td>
<td>reactive(o)</td>
<td>ref(v)</td>
<td></td>
</tr>
<tr>
<td>返回</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>使用 toRefs 可解析为响应式</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="watcheffect"><a href="/framework/vue3/watch&amp;WatchEffect.html">watchEffect</a></h3>
<h2 id="nexttick"><a href="">nextTick</a></h2>
<h2 id="测试"><a href="/framework/vue3/test.html">测试</a></h2>
<h2 id="与-ts-结合使用"><a href="/framework/vue3/tsTogether.html">与 ts 结合使用</a></h2>
<h2 id="api"><a href="/framework/vue3/api.html">api</a></h2>
<h2 id="开发跨端应用"><a href="/framework/vue3/devMobile.html">开发跨端应用</a></h2>
<h2 id="为生产打包"><a href="/framework/vue3/buildTogether.html">为生产打包</a></h2>
<h2 id="状态管理"><a href="/framework/vue3/stateManager.html">状态管理</a></h2>
<h2 id="ssr服务端渲染"><a href="/framework/vue3/ssr.html">ssr(服务端渲染)</a></h2>
<h2 id="安全"><a href="/framework/vue3/safe.html">安全</a></h2>
<h2 id="title">title</h2>
<h2 id="title">title</h2>
<h2 id="title">title</h2>
<h2 id="principle"><a href="/framework/vue3/principle.html">principle</a></h2>
<p>该包负责把<code>*.vue</code>的代码转换为操作 dom 的代码。操作完 dom 后由浏览器根据 dom 显示出来，中间包括大量的重绘、回流。<br>
在<code>mvvm</code>框架流行之间有面向 dom 开发的框架——jquery。它也是操作 dom。然后让浏览器做重绘、回流的工作。<br>
把数据做成可生成 html 代码的 js 代码，然后交给浏览器运行。vue 就做了这一件事。<br>
真传一名话，假传万卷书。如一个道理很庞杂，那就不用学了。它是假的。若只有一句话，那剩下的就是去实践它了。</p>
<h3 id="uml">uml</h3>
<pre><code>
</code></pre>
<h3 id="diff">diff</h3>
<h2 id="confuse">confuse</h2>
<ul>
<li><a href="/framework/vue3/vModel.html">v-model</a></li>
<li><a href="/framework/vue3/forceupdate.html">$forceupdate</a></li>
</ul>
<h2 id="vue-家庭">vue 家庭</h2>
<ul>
<li><a href="">vue2</a></li>
<li><a href="/framework/vue3/vue3.html">vue3</a></li>
<li><a href="">vue-cli</a></li>
<li><a href="">@vue/compiler-sfc</a></li>
<li><a href="/builder/vite/index.html">vite</a></li>
<li><a href="/jsPackages/vueRouter4.html">vue-router@4</a></li>
<li><a href="">@vue/reactivity 响应式核心包</a></li>
<li><a href="/jsPackages/vuex.html">vuex</a></li>
<li><a href="">@vitejs/plugin-vue</a></li>
<li><a href="">vue-loader</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
</ul>
<h2 id="todo">todo</h2>
<blockquote>
<p>自己写一个指令。 V-teleport<br>
v-if/v-for/v-show 等常用指令是如何工作的。<br>
未来迭代计划。<br>
不能够在 setUp 函数中使用 data 和 methods.</p>
</blockquote>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>