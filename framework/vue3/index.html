<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>vue</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="vue">vue</h1>
<h2 id="overview">overview</h2>
<blockquote>
<p>渐进式框架
<a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p>
</blockquote>
<h3 id="feature">feature</h3>
<ul>
<li>增强静态 html.不参与 build</li>
<li>以 webComponents 嵌入到现有页面中。</li>
<li>spa</li>
<li>ssr</li>
<li>ssg</li>
<li>可开发 desktop / mobile / webgl / terminal</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>sfa</td>
<td>single-file components</td>
<td>单文件组件。<code>*.vue</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="install">install</h2>
<p><code>npm i vue</code></p>
<h3 id="cdn">cdn</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 id="下载并自托管">下载并自托管</h3>
<p>下载 vue 的 js 文件后放在自己的服务器上。在前端项目中使用自己服务器上的 js 文件。</p>
<h3 id="npm">npm</h3>
<p>用于构建大型应用。需要与打包工具一起使用。</p>
<pre><code class="language-shell">npm i vue@next
</code></pre>
<p>创建单文件组件。</p>
<pre><code class="language-shell">npm i -D @vue/compiler-sfc
</code></pre>
<h3 id="cli">cli</h3>
<pre><code class="language-shell">npm i -g @vue/cli  # vue3对应的是@vue/cli v4.5
yarn global add @vue/cli
</code></pre>
<h3 id="vite"><a href="/framework/vue3/vite.html">vite</a></h3>
<p>vue 团队开发的 web 开发构建工具。react 团队都计划使用 vite 取代 cra 了。</p>
<pre><code class="language-shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">npm 6.x</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">npm init vite@latest &lt;project-name&gt; --template vue</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">npm 7+，需要加上额外的双短横线</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">npm init vite@latest &lt;project-name&gt; -- --template vue</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> &lt;project-name&gt;</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">npm install</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">npm run dev</span>
<span class="hljs-meta prompt_">
$ </span><span class="language-bash">yarn create vite &lt;project-name&gt; --template vue</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> &lt;project-name&gt;</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">yarn</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">yarn dev</span>
<span class="hljs-meta prompt_">
$ </span><span class="language-bash">pnpm create vite &lt;project-name&gt; -- --template vue</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> &lt;project-name&gt;</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">pnpm install</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">pnpm dev</span>
</code></pre>
<h2 id="usage">usage</h2>
<p>可以使用:</p>
<ul>
<li><a href="">@vue/cli</a></li>
<li><a href="/builder/vite/index.html">vite</a></li>
</ul>
<h3 id="创建一个-vue-应用"><a href="/framework/vue3/demo/createVueApp.html">创建一个 vue 应用</a></h3>
<h3 id="使用-vue-脚本"><a href="/framework/vue3/demo/useVueScript.html">使用 vue 脚本</a></h3>
<ul>
<li>使用全局构建版本。所有 api 都绑定在<code>window.Vue</code>对象上。</li>
<li>使用 esm 构建版本。</li>
</ul>
<h3 id="基本用法"><a href="/framework/vue3/basic.html">基本用法</a></h3>
<h2 id="性能--优化"><a href="/framework/vue3/performation.html">性能 &amp; 优化</a></h2>
<h2 id="vue3--ts"><a href="/framework/vue3/vue3&amp;ts.html">vue3 + ts</a></h2>
<h2 id="principle"><a href="/framework/vue3/principle.html">principle</a></h2>
<h2 id="vue2--vue3"><a href="/framework/vue3/vue2&amp;vue3.html">vue2 &amp; vue3</a></h2>
<h2 id="title">title</h2>
<h2 id="title-1">title</h2>
<h3 id="运行时--编译器-vs-仅运行时">运行时 + 编译器 vs. 仅运行时</h3>
<pre><code class="language-js"><span class="hljs-comment">// 需要编译器</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;{{hi}}&lt;/div&gt;&#x27;</span>,
})
<span class="hljs-comment">// 不需要编译器</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, <span class="hljs-variable language_">this</span>.<span class="hljs-property">hi</span>)
  },
})
</code></pre>
<p>当在客户端上编译模板时（即：把字符串给 template 选项，或者在元素 dom 内使用 html 为模板），需要完整的构建版本。<br>
打包时使用<code>vue-loader</code>处理<code>*.vue</code>文件为 js。所以在客户端只需要构建版本。</p>
<h2 id="指令"><a href="/framework/vue3/directive.html">指令</a></h2>
<h2 id="组件"><a href="/framework/vue3/component.html">组件</a></h2>
<p>html 中不区分大小写。vue 内部转化组件名。</p>
<h3 id="单文件组件"><a href="/framework/vue3/sfc.html">单文件组件</a></h3>
<p>使用<a href="/jsPackages/compilerSfc.html"><code>@vue/compiler-sfc</code></a>编译</p>
<h3 id="data">data</h3>
<p>在组件中定义了 data 属性（其值是方法）中的数据会被封装在组件实例的<code>$data</code>属性内。（为方便）也在组件实例的顶级属性（与$data兄弟级）中设置了这些属性。因此可以在组件的template中直接使用这些属性。<br>
<code>vm.key</code>、<code>$data.key</code>与<code>vm.$data.key</code>是同一个值。</p>
<h3 id="methods">methods</h3>
<p>vue 为每个方法方法绑定 this 为当前组件。<br>
不要使用箭头函数。否则会引发 this 不正确的问题。</p>
<h4 id="参数">参数</h4>
<p>绑定内联写法中使用<code>$event</code>表示原生事件。</p>
<h3 id="计算">计算</h3>
<p>计算属性的 getter 函数没有副作用，它更易于测试和理解。<br>
包含响应式数据的复杂逻辑</p>
<pre><code class="language-js"><span class="hljs-attr">computed</span>: {
    <span class="hljs-attr">fullName</span>: {
        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {...},
        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) { ... }
    }
}
<span class="hljs-comment">// 设置</span>
vm.<span class="hljs-property">fullName</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>
<span class="hljs-comment">// 获取</span>
vm.<span class="hljs-property">fullName</span>
</code></pre>
<h3 id="watch">watch</h3>
<p>当指定数据改变时执行。<br>
可执行异步操作。<br>
<code>vm.$watch</code></p>
<pre><code class="language-js"><span class="hljs-attr">watch</span>: { <span class="hljs-title function_">question</span>(<span class="hljs-params">nv, ov</span>) { ... } }
</code></pre>
<h3 id="computed--watch--methods">computed &amp; watch &amp; methods</h3>
<!-- prettier-ignore-start -->
<p>为什么计算执行同步，watch 执行异步？</p>
<table>
<thead>
<tr>
<th></th>
<th>computed</th>
<th>watch</th>
<th>methods</th>
</tr>
</thead>
<tbody>
<tr>
<td>适用场景</td>
<td>包含响应式数据的复杂逻辑</td>
<td>watch</td>
<td>methods</td>
</tr>
<tr>
<td></td>
<td>会缓存结果</td>
<td>不缓存结果</td>
<td>-</td>
</tr>
<tr>
<td></td>
<td>会缓存结果</td>
<td>当需要变化时执行异步或开销较大的操作</td>
<td>-</td>
</tr>
<tr>
<td>结合使用</td>
<td>computed + methods</td>
<td>watch + methods</td>
<td>methods + methods</td>
</tr>
<tr>
<td></td>
<td>-</td>
<td>侦听器</td>
<td>方法（可复用）</td>
</tr>
<tr>
<td>相同</td>
<td>都是对象</td>
<td>都是对象</td>
<td>都是对象</td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h2 id="生命周期"><a href="/framework/vue3/lifeCircle.html">生命周期</a></h2>
<h2 id="处理边界情况">处理边界情况</h2>
<p>强制更新 $forceUpdate
低级静态组件 v-once 只求值一次。</p>
<h2 id="过滤--动画"><a href="/framework/vue3/translate.html">过滤 &amp; 动画</a></h2>
<h2 id="api"><a href="/framework/vue3/api.html">api</a></h2>
<p>Vue.createApp({...})<br>
返回一个全局组件。react 在 18 以后也有了创建根组件的方法。<br>
该组件的大部分方法可以链式调用。<br>
除了<code>mount()</code>等。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$watch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="slot"><a href="/framework/vue3/slot.html">slot</a></h2>
<p>内容分发。</p>
<ul>
<li>默认内容</li>
<li>具名插槽</li>
<li>动态插槽名</li>
<li>作用域插槽</li>
<li>v-slot #</li>
</ul>
<h2 id="vue-组件实例">vue 组件实例</h2>
<ul>
<li>其内置的属性是以<code>$</code>开头的。</li>
<li>保留了以<code>_</code>开头的属性。<br>
尽量不要动这样的属性。</li>
</ul>
<h2 id="组件间传递数据"><a href="/framework/dataTrasmit/index.html">组件间传递数据</a></h2>
<h2 id="模板引用">模板引用</h2>
<p>就是在父组件上使用<code>ref</code>属性。<br>
然后在 js 中使用<code>this.$refs.xxx</code>或者<code>xxx.value</code></p>
<pre><code>&lt;template&gt;
  // 使用
  &lt;div ref=&quot;root&quot;&gt;...&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import {ref, onMounted} form 'vue'
export default {
    setup() {
        let root = ref(null) // 搞成响应式
        onMounted(() =&gt; {
            clog(root.value) // 获取
        })
        // watch() 和 watchEffect() 在 DOM 挂载或更新之前运行副作用，所以当侦听器运行时，模板引用还未被更新。
        watchEffect(() =&gt; {
            console.log(root.value)
        }, {
            flush: 'post' // 这将在 DOM 更新后运行副作用，确保模板引用与 DOM 保持同步，并引用正确的元素。
        })
    }
}
&lt;/script&gt;
</code></pre>
<p>当ref值为ref类型时不使用<code>:</code>
当ref值为函数类型时使用<code>:</code>
函数的参数是引用的do元素
在v-for中使用时ref的值是数组。<br>
也可以透传给子元素。</p>
<h3 id="ref--ref--torefs--refs--ref">ref &amp; :ref &amp; toRefs &amp; $refs &amp; $Ref</h3>
<p>它们都是来自<code>reference</code>.<br>
v2 中只用于模板引用。到 v3 时多了响应式。<br>
vue 中还好多为了兼容以前的功能、逻辑、用法。搞的乱乱的代码。</p>
<table>
<thead>
<tr>
<th></th>
<th>ref</th>
<th>:ref</th>
<th>toRefs</th>
<th>$refs</th>
<th>Ref</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>为基本类型数据做响应式</td>
<td>template 中调用 ref 后，可以模板引用。</td>
<td>把响应式对象解构为多个响应式元素</td>
<td>用于模板引用</td>
<td></td>
</tr>
<tr>
<td>用法</td>
<td><code>let a = ref(null)</code></td>
<td><code>&lt;div ref=&quot;rp&quot; /&gt;</code></td>
<td><code>toRefs(reactiveObject)</code></td>
<td><code>this.$refs.xxx</code>取得模板，得到 dom 元素</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="watch--watcheffect"><a href="/framework/vue3/watch&amp;WatchEffect.html">watch &amp; watchEffect</a></h2>
<h2 id="mixin">mixin</h2>
<p>把可在组件中复用的部分（逻辑、功能）提取成为一个 mixin 对象。</p>
<ul>
<li>data/methods/components/directive 会合并。本组件优先。</li>
<li>生命周期方法都会执行，先执行 mixin 对象里的，再执行本组件里的。</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 定义全局</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({...})
app.<span class="hljs-title function_">mixin</span>({
    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) {...}
})
<span class="hljs-comment">// 定义局部 组件内</span>

</code></pre>
<h2 id="teleport-应该移入template">teleport 应该移入template</h2>
<p>将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置。<br>
挂载到目标元素的内部后面。</p>
<ul>
<li>to：     移到的目标元素          值是css选择器</li>
<li>disabled:是否禁用teleport功能。</li>
</ul>
<pre><code class="language-js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;button /&gt;
    &lt;teleport to=&quot;body&quot;&gt;
        ...
    &lt;/teleport&gt;
  `</span>,
})
</code></pre>
<h2 id="渲染函数">渲染函数</h2>
<ul>
<li>使用 js 方法（<code>h / createVNode</code>）编写组件。与 sfc 功能等价。</li>
<li>官网举了一个“动态 dom 标签”的例子。</li>
<li>一般用于在组件模版需要更灵活时</li>
<li>h()可创建一个vnode.render()渲染此vnode为真实html.</li>
<li>h()返回vnode.多个vnode组成vdom.</li>
<li>template中的html会经过渲染函数生成vnode</li>
<li>h()是createVNodo()的别名</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { createApp, h } = <span class="hljs-title class_">Vue</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>()
app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">level</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">level</span>, {}, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-title function_">default</span>())
  },
})
</code></pre>
<pre><code class="language-js"><span class="hljs-title function_">h</span>(
  tag, <span class="hljs-comment">// String | Object | Function  一个html标签名、一个组件、一个异步组件、一个函数式组件</span>
  props, <span class="hljs-comment">// Object 为防止歧义，可以设置为null</span>
  children <span class="hljs-comment">// String | Array | Object  需要唯一</span>
)
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 所有事件名都是on+大驼峰命名，可以再加大驼峰的事件修饰符。 </span>
<span class="hljs-keyword">const</span> {
  h,
  resolveDomponent, resolveDynamicComponent, resolveDirective, withDirectives
} = <span class="hljs-title class_">Vue</span>
app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, { 
  <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {...}, <span class="hljs-comment">// 在插槽函数外面调用</span>
  <span class="hljs-keyword">let</span> <span class="hljs-title class_">CompNameA</span> = <span class="hljs-title function_">resolveComponent</span>(<span class="hljs-string">&#x27;comp-name-a&#x27;</span>) <span class="hljs-comment">// 解构全局组件</span>
  <span class="hljs-keyword">let</span> <span class="hljs-title class_">CompNameB</span> = <span class="hljs-title function_">resolveDynamicComponent</span>(<span class="hljs-string">&#x27;comp-name-b&#x27;</span>) <span class="hljs-comment">// 解构全局动态组件 // &lt;comp-name-b :is=&quot;xxx&quot; /&gt;</span>
<span class="hljs-comment">// keep-alive transition transition-group teleport 不需要使用resolveComponent处理。直接从Vue中取出后使用。 </span>
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;a-name&#x27;</span>, {
      <span class="hljs-attr">modelValue</span>: xxx,  <span class="hljs-comment">// v-model </span>
      <span class="hljs-string">&#x27;onUpdate:modelValue&#x27;</span>: <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, v), <span class="hljs-comment">// 事件 </span>
      <span class="hljs-string">&#x27;onClickCapture&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span>,
      }, {
         <span class="hljs-comment">//设置插槽 </span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-title function_">default</span>(), 
        <span class="hljs-comment">// 具名插槽 </span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-title function_">slotName</span>({<span class="hljs-attr">k</span>: v}),
        <span class="hljs-comment">// 作用域插槽</span>
        <span class="hljs-attr">slotName</span>: <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> <span class="hljs-title function_">h</span>(...) 
    }) 
  } 
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) { 
    <span class="hljs-keyword">let</span> pin =<span class="hljs-title function_">resolveDirective</span>(<span class="hljs-string">&#x27;pin&#x27;</span>) 
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">withDirectives</span>(<span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, [
      [pin, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;top&#x27;</span>, {<span class="hljs-attr">animate</span>: <span class="hljs-literal">true</span>}] 
    ]))
  } 
})
</code></pre>
<h2 id="jsx">jsx</h2>
<p>使用jsx写法时需要<code>@vue/babel-plugin-jsx</code>插件。</p>
<pre><code class="language-js"><span class="hljs-comment">// babel.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">presets</span>: [
    <span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>
  ],
  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;@vue/babel-plugin-jsx&#x27;</span>]
}
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">CompName</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CompName.vue&#x27;</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>({
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CompName</span>&gt;</span>
        ...
      <span class="hljs-tag">&lt;/<span class="hljs-name">CompName</span>&gt;</span></span>
    )
  } 
})
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#root&#x27;</span>)
</code></pre>
<h2 id="插件"><a href="/framework/vue3/plugin.html">插件</a></h2>
<h2 id="响应式">响应式</h2>
<ul>
<li>proxy 对象无法对基本类型的数据做响应式，所以 vue3 把基本类型的数据转化为<code>{value: xx}</code>。</li>
<li>基本响应式 api 是 reactive。ref 是基于 reactive 开发出来的。</li>
<li>readonly 可防止修改响应式对象</li>
</ul>
<h3 id="reactive--ref">reactive &amp; ref</h3>
<table>
<thead>
<tr>
<th></th>
<th>reactive</th>
<th>ref</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>用法</td>
<td>reactive(o)</td>
<td>ref(v)</td>
<td></td>
</tr>
<tr>
<td>返回</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>使用 toRefs 可解析为响应式</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="watcheffect"><a href="/framework/vue3/watch&amp;WatchEffect.html">watchEffect</a></h3>
<h2 id="nexttick"><a href="">nextTick</a></h2>
<h2 id="路由"><a href="/framework/vue3/router.html">路由</a></h2>
<h2 id="测试"><a href="/framework/vue3/test.html">测试</a></h2>
<h2 id="与-ts-结合使用"><a href="/framework/vue3/tsTogether.html">与 ts 结合使用</a></h2>
<h2 id="api-1"><a href="/framework/vue3/api.html">api</a></h2>
<h2 id="开发跨端应用"><a href="/framework/vue3/devMobile.html">开发跨端应用</a></h2>
<h2 id="为生产打包"><a href="/framework/vue3/buildTogether.html">为生产打包</a></h2>
<h2 id="状态管理"><a href="/framework/vue3/stateManager.html">状态管理</a></h2>
<h2 id="ssr服务端渲染"><a href="/framework/vue3/ssr.html">ssr(服务端渲染)</a></h2>
<h2 id="安全"><a href="/framework/vue3/safe.html">安全</a></h2>
<h2 id="高阶组件-hoc"><a href="/framework/vue3/hoc.html">高阶组件 hoc</a></h2>
<h2 id="三种写法-template--render-function--jsx"><a href="/framework/vue3/format.html">三种写法 template / render function / jsx</a></h2>
<h2 id="title-2">title</h2>
<h2 id="principle-1"><a href="/framework/vue3/principle.html">principle</a></h2>
<p>该包负责把<code>*.vue</code>的代码转换为操作 dom 的代码。操作完 dom 后由浏览器根据 dom 显示出来，中间包括大量的重绘、回流。<br>
在<code>mvvm</code>框架流行之间有面向 dom 开发的框架——jquery。它也是操作 dom。然后让浏览器做重绘、回流的工作。<br>
把数据做成可生成 html 代码的 js 代码，然后交给浏览器运行。vue 就做了这一件事。<br>
真传一名话，假传万卷书。如一个道理很庞杂，那就不用学了。它是假的。若只有一句话，那剩下的就是去实践它了。</p>
<h3 id="uml">uml</h3>
<pre><code>
</code></pre>
<h3 id="diff">diff</h3>
<h2 id="confuse">confuse</h2>
<ul>
<li><a href="/framework/vue3/vModel.html">v-model</a></li>
<li><a href="/framework/vue3/forceupdate.html">$forceupdate</a></li>
</ul>
<h2 id="vue-家庭">vue 家庭</h2>
<ul>
<li><a href="">vue2</a></li>
<li><a href="/framework/vue3/vue3.html">vue3</a></li>
<li><a href="">vue-cli</a></li>
<li><a href="">create-vue 脚手架</a></li>
<li><a href="/jsPackages/compilerSfc.html">@vue/compiler-sfc</a></li>
<li><a href="/builder/vite/index.html">vite</a></li>
<li><a href="/jsPackages/vueRouter4.html">vue-router@4</a></li>
<li><a href="">@vue/reactivity 响应式核心包</a></li>
<li><a href="/jsPackages/vuex.html">vuex</a></li>
<li><a href="">@vitejs/plugin-vue</a></li>
<li><a href="">vue-loader</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
</ul>
<h2 id="todo">todo</h2>
<blockquote>
<p>v-if/v-for/v-show 等常用指令是如何工作的。<br>
未来迭代计划。<br>
不能够在 setup 函数中使用 data 和 methods.</p>
</blockquote>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>