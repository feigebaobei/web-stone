<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>vue &#x7ec4;&#x4ef6;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="vue-组件">vue 组件</h1>
<ul>
<li>整个 vue 应用由 vue 组件组成的 vue 组件树构成。</li>
<li>组件名
<ul>
<li>PascalCase</li>
<li>支持自闭合</li>
<li>一般用于动态组件、递归组件</li>
</ul>
</li>
<li>title</li>
<li>title</li>
<li>title</li>
</ul>
<h2 id="组件模板">组件模板</h2>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{refObj}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;buttonClickHandle&quot;</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- &lt;slot&gt;&lt;/slot&gt; --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">import</span> { ref, provide, defineComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
  <span class="hljs-keyword">let</span> clog = <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>({
    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>],
    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;eventName&#x27;</span>],
    <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) {
      <span class="hljs-keyword">let</span> refObj = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
      <span class="hljs-keyword">let</span> <span class="hljs-title function_">buttonClickHandle</span> = (<span class="hljs-params"></span>) =&gt; {
        <span class="hljs-title function_">clog</span>(<span class="hljs-string">&#x27;buttonClickHandle&#x27;</span>)
        context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>, <span class="hljs-string">&#x27;str&#x27;</span>)
      }
      <span class="hljs-keyword">return</span> {
        refObj,
        buttonClickHandle,
      }
    },
  })
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h2 id="动态组件">动态组件</h2>
<p>is 的属性值：</p>
<ul>
<li>注册组件时的 name</li>
<li>引入的组件对象</li>
<li>必须使用<code>&lt;component&gt;</code>标签</li>
</ul>
<pre><code class="language-js">&lt;keep-alive&gt; <span class="hljs-comment">// 会使用组件保存在内存中</span>
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span>
&lt;/keep-alive&gt;
</code></pre>
<h2 id="异步组件">异步组件</h2>
<pre><code class="language-js"><span class="hljs-comment">// 局部注册</span>
<span class="hljs-keyword">let</span> { defineAsyncComponent } = <span class="hljs-title class_">Vue</span>
<span class="hljs-keyword">let</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">s, j</span>) =&gt;</span> {
    <span class="hljs-title function_">s</span>({
      <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;str&lt;/div&gt;`</span>,
    })
    <span class="hljs-comment">//   or</span>
    <span class="hljs-comment">// return import(&#x27;./components/AdminPageComponent.vue&#x27;)</span>
  })
})

<span class="hljs-comment">// 全局注册</span>
app.<span class="hljs-title function_">component</span>(
  <span class="hljs-string">&#x27;MyComponent&#x27;</span>,
  <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>))
)

<span class="hljs-comment">// api</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>({
  <span class="hljs-comment">// 加载函数</span>
  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>),
  <span class="hljs-comment">// 加载异步组件时使用的组件</span>
  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>,
  <span class="hljs-comment">// 展示加载组件前的延迟时间，默认为 200ms</span>
  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,
  <span class="hljs-comment">// 加载失败后展示的组件</span>
  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,
  <span class="hljs-comment">// 如果提供了一个 timeout 时间限制，并超时了</span>
  <span class="hljs-comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span>
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,
})
</code></pre>
<p><a href="/framework/vue3/api.html">defineAsyncComponent api</a>
选项式 api 中设置 suspensible:false，则不受<code>&lt;Suspense&gt;</code>控制。</p>
<h2 id="注册">注册</h2>
<p>先注册，再使用。</p>
<table>
<thead>
<tr>
<th></th>
<th>全局注册</th>
<th>局部注册</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>注册在 vue 应用中</td>
<td>注册在当前组件中</td>
<td></td>
</tr>
<tr>
<td></td>
<td>可以 tree-shaking</td>
<td>不可以 tree-shaking</td>
<td></td>
</tr>
<tr>
<td></td>
<td>全局组件可以使用。</td>
<td>只作用于当前组件内。</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-js"><span class="hljs-comment">// 全局注册</span>
<span class="hljs-keyword">import</span> comp <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./comp.vue&#x27;</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({...}).<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, comp)
<span class="hljs-comment">// 局部注册</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-keyword">let</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>({
    <span class="hljs-attr">components</span>: {
        <span class="hljs-string">&#x27;component-a&#x27;</span>: <span class="hljs-title class_">ComponentA</span>,
        <span class="hljs-string">&#x27;component-b&#x27;</span>: <span class="hljs-title class_">ComponentB</span>,
    }
})
<span class="hljs-comment">// 2</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">CA</span> = {...}
<span class="hljs-keyword">let</span> <span class="hljs-variable constant_">CB</span> = {
    <span class="hljs-attr">components</span>: {
        <span class="hljs-string">&#x27;component-a&#x27;</span>: <span class="hljs-variable constant_">CA</span>,
    }
}
<span class="hljs-comment">// 3 esm</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">CA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CA.vue&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">components</span>: {
        <span class="hljs-variable constant_">CA</span>
    }
}
</code></pre>
<p><a href="">为什么全局注册的事件可以在所有组件中使用</a>。<br>
全局注册会使打包体积增大。</p>
<h2 id="接收方式">接收方式</h2>
<ul>
<li>props</li>
<li>emits</li>
<li>attrs
三者都是复数。可能与英语语法有关。</li>
</ul>
<h2 id="props">props</h2>
<p>子组件使用 props 属性接收从父组件来的数据。</p>
<pre><code class="language-js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;span&gt;{{title}}&lt;/span&gt;`</span>,
})
</code></pre>
<pre><code class="language-js"><span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;linkes&#x27;</span>]
<span class="hljs-attr">props</span>: {<span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>， <span class="hljs-attr">links</span>: <span class="hljs-title class_">Number</span>} <span class="hljs-comment">// 这里写构造函数.</span>
<span class="hljs-comment">// 有点类似PropTypes</span>
<span class="hljs-comment">// 把一个对象的所有属性作为prop传入。</span>
&lt;comp-name v-bind=<span class="hljs-string">&quot;obj&quot;</span> /&gt;
    &lt;=&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">comp-name</span> <span class="hljs-attr">:k</span>=<span class="hljs-string">&quot;v&quot;</span> <span class="hljs-attr">:k2</span>=<span class="hljs-string">&quot;v2&quot;</span> /&gt;</span></span>
</code></pre>
<h3 id="内置的类型检查构造函数">内置的类型检查（构造函数）</h3>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Date</li>
<li>Function</li>
<li>Symbol</li>
</ul>
<h3 id="单向数据流">单向数据流</h3>
<p>从父组件到子组件。</p>
<ol>
<li>传递一个初始值</li>
<li>传入后转换</li>
</ol>
<pre><code class="language-js"><span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;size&#x27;</span>],
<span class="hljs-attr">computed</span>: {
    <span class="hljs-title function_">compSize</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>()
    }
}
</code></pre>
<h3 id="验证">验证</h3>
<p>创建实例前验证，此时 data/computed/methods 不可使用。<br>
在父组件中请使用中划线命名，在 props 中请使用小驼峰命名。vue 会进行转化。</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">fn, ln</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = fn
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = ln
}
...
<span class="hljs-attr">props</span>: {
    <span class="hljs-attr">pa</span>: <span class="hljs-title class_">Number</span>,
    <span class="hljs-attr">pb</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],
    <span class="hljs-attr">pc</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Boolean</span>,
        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">pd</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,
        <span class="hljs-attr">default</span>: <span class="hljs-number">10</span>
    },
    <span class="hljs-attr">pe</span>: { <span class="hljs-comment">// 类型是对象是default需要使用方法返回值</span>
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,
        <span class="hljs-title function_">defautl</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> []
        }
    },
    <span class="hljs-attr">pf</span>: {
        <span class="hljs-title function_">validator</span>(<span class="hljs-params">value</span>) {
            <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(value)
        }
    },
    <span class="hljs-attr">pg</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>,
        <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Default function&#x27;</span>
        }
    },
    <span class="hljs-attr">ph</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Person</span> <span class="hljs-comment">// 使用自定义构造函数验证。</span>
        <span class="hljs-comment">// vue会使用instanceo去验证。</span>
    }
}
</code></pre>
<h2 id="emits">emits</h2>
<p>用于接收从父组件来的事件名称。</p>
<pre><code class="language-js"><span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;eventOne&#x27;</span>, <span class="hljs-string">&#x27;eventTwo&#x27;</span>],
<span class="hljs-attr">emits</span>: {
    <span class="hljs-attr">eventOne</span>: <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> { <span class="hljs-comment">// 用于本组件在触发指定事件前的验证。params是为该事件的方法传递的参数。</span>
        <span class="hljs-keyword">return</span> boolean <span class="hljs-comment">// 是否通过验证</span>
    }
}
</code></pre>
<h2 id="v-model">v-model</h2>
<p>它是值与事件的语法糖。</p>
<pre><code class="language-js">&lt;comp-name v-<span class="hljs-attr">model</span>:title=<span class="hljs-string">&quot;param&quot;</span> /&gt;

<span class="hljs-attr">props</span>: {
    <span class="hljs-attr">title</span>: string,
},
<span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:title&#x27;</span>]
$emit(<span class="hljs-string">&#x27;update:title&#x27;</span>, params)
</code></pre>
<h3 id="v-model-的参数">v-model 的参数</h3>
<pre><code>&lt;Comp v-model:title=&quot;value&quot;/&gt;
let emits = defineEmits('update:title')
&lt;!-- or --&gt;
context.emit('update:title', [params])
</code></pre>
<h3 id="多个-v-model-绑定">多个 v-model 绑定</h3>
<pre><code class="language-js">;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comp</span> <span class="hljs-attr">v-model:first</span>=<span class="hljs-string">&quot;v0&quot;</span> <span class="hljs-attr">v-model:second</span>=<span class="hljs-string">&quot;v1&quot;</span> /&gt;</span></span>

context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;update:first&#x27;</span>)
context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;update:second&#x27;</span>)
</code></pre>
<h3 id="v-model-的修饰符">v-model 的修饰符</h3>
<p>这是为 v-model 自定义的修改符</p>
<pre><code class="language-js">&lt;comp-name v-model.<span class="hljs-property">cap</span>=<span class="hljs-string">&quot;params&quot;</span> /&gt;

<span class="hljs-attr">props</span>: {
    <span class="hljs-attr">modelValue</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">modelModifiers</span>: {
        <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> ({})
    }
},
<span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>],
$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, xx)
</code></pre>
<h2 id="attrs">attrs</h2>
<p>用于接收从父组件来的且 props 中未明确定义的属性。</p>
<pre><code class="language-js"><span class="hljs-attr">props</span>: [...],
<span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 会禁止把$attrs属性设置在当前组件的根节点上。默认为true.</span>
v-bind=<span class="hljs-string">&quot;$attrs&quot;</span>
</code></pre>
<ul>
<li>若当前组件为单节点，则把$attrs 全部设置在当前组件的根元素上。</li>
<li>若当前组件为多节点且未明确使用$attrs，则会报错。</li>
</ul>
<h2 id="provide--inject">provide / inject</h2>
<ul>
<li>它们是祖先组件向后代组件传递数据的方式之一。</li>
<li>使用 symbol 类型为 key 可以减少变量名冲突。</li>
</ul>
<p><a href="/framework/dataTrasmit/index.html">组件间传递数据</a></p>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th>provide</th>
<th>inject</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>在祖先组件中提供数据</td>
<td>在后代组件中接收数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td>每个 provide 只提供一个数据</td>
<td>可使用数组接收多个数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td>可提供响应式、非响应式数据</td>
<td>可接收……</td>
<td></td>
</tr>
<tr>
<td></td>
<td>-</td>
<td>可设置默认值</td>
<td></td>
</tr>
<tr>
<td></td>
<td>可设置 readonly</td>
<td></td>
<td>一般在祖先组件中设置只读</td>
</tr>
<tr>
<td></td>
<td>可提供对象、基本类型</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>在 setup</td>
<td>需要引入</td>
<td>需要引入</td>
<td></td>
</tr>
<tr>
<td>不在 setup</td>
<td>选项式 api</td>
<td>选项式 api</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<pre><code class="language-js"><span class="hljs-comment">// 组件中使用</span>
<span class="hljs-title function_">provide</span>(key, value)
<span class="hljs-comment">// 注册组件时提供</span>
app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {...},
    <span class="hljs-comment">// 提供</span>
    <span class="hljs-attr">provide</span>: {<span class="hljs-attr">key</span>: value}
    <span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">key</span>: value}
    }
})
app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-other&#x27;</span>, {
    <span class="hljs-comment">// 接收</span>
    <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;key&#x27;</span>]
})

<span class="hljs-comment">// 或者在setup中提供</span>
<span class="hljs-comment">// xxx.vue</span>
&lt;template&gt;
&lt;/template&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
    <span class="hljs-keyword">import</span> {provide, reactive, ref, readonly} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
        <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">let</span> k = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;str&#x27;</span>)
            <span class="hljs-keyword">let</span> o = <span class="hljs-title function_">reactive</span>({
                <span class="hljs-attr">k0</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">k1</span>: <span class="hljs-literal">true</span>
            })
            <span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params"></span>) =&gt; {...}
            <span class="hljs-keyword">let</span> b = <span class="hljs-title function_">readonly</span>(o)
            <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;k&#x27;</span>, k)
            <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;o&#x27;</span>, o)
            <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;f&#x27;</span>, f)
            <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;b&#x27;</span>, b)
        }
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> {inject} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> defaultValue = <span class="hljs-number">2</span>
    <span class="hljs-keyword">let</span> k = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;k&#x27;</span>, defaultValue)
    <span class="hljs-keyword">let</span> o = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;o&#x27;</span>)
    <span class="hljs-keyword">let</span> f = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;f&#x27;</span>)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h2 id="函数式组件">函数式组件</h2>
<p>当组件模版需要更灵活时一般使用函数式组件。<br>
它可以在通过控制三个参数（tag/props/children），实现组件。</p>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;comp-name&#x27;</span>, {
    <span class="hljs-attr">functoinal</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">createElement, context</span>) {
        <span class="hljs-keyword">let</span> data = {
            <span class="hljs-attr">props</span>: {...},
            <span class="hljs-attr">on</span>: {
                <span class="hljs-title function_">beforeEnter</span>(<span class="hljs-params">el</span>) {...},
                <span class="hljs-title function_">afterEnter</span>(<span class="hljs-params">el</span>) {...}
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;transition&#x27;</span>, data, context.<span class="hljs-property">children</span>)
    }
})
</code></pre>
<h2 id="setup">setup</h2>
<p>vue3 开创此属性（生命周期）是为了解决“关注点分离”问题。<br>
就是把本组件的基本数据、方法、计算等放在 setup()中做。别的仍然与 vue2 时期一样。<br>
在创建组件之前执行 setup 方法。此时 data/computed/methods/refs 都未被解析。（即不能使用）setup 方法暴露的内容可以被本组件的其余部分访问。<br>
所谓的关注点分离就是在 setup 中写基本方法、数据。<br>
setup()内的 this 不是活跃实例的引用。</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">components</span>: {...} <span class="hljs-comment">// 又是复数形式</span>
    <span class="hljs-attr">props</span>: {...},
    <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;props&#x27;</span>, props)
        <span class="hljs-keyword">let</span> repositories = <span class="hljs-title function_">ref</span>([]) <span class="hljs-comment">// 可以通过一个新的 ref 函数会创建一个**响应式引用**使**任何响应式变量**在任何地方起作用。</span>
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
            repositories = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getP</span>(props.<span class="hljs-property">user</span>)
        }
        <span class="hljs-comment">// 需要使用前缀`on`,如：`onMounted`</span>
        <span class="hljs-title function_">onMounted</span>(fn) <span class="hljs-comment">// 在 mounted 是调用 fn</span>
        <span class="hljs-comment">// setup中的watch</span>
        <span class="hljs-comment">// 参数是响应式引用或getter方法和一个回调方法。</span>
        <span class="hljs-title function_">watch</span>(repositories, <span class="hljs-function">(<span class="hljs-params">nv, ol</span>) =&gt;</span> {...})
        <span class="hljs-comment">// 计算</span>
        <span class="hljs-keyword">const</span> searchQuery = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)
        <span class="hljs-keyword">const</span> compSearchQuery = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">return</span> repositories.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span>.<span class="hljs-title function_">includes</span>(searchQuery.<span class="hljs-property">value</span>))
        })
        <span class="hljs-keyword">return</span> {
            repositories,
            fn,
            searchQuery,
            compSearchQuery
        } <span class="hljs-comment">// 这里返回的任何内容可以用于组件的template部分</span>
        <span class="hljs-comment">// 我就发现这儿不一样。</span>
    }
}
</code></pre>
<h3 id="setup-watch--watch">setup watch &amp; watch</h3>
<pre><code class="language-js"><span class="hljs-comment">// vue2</span>
<span class="hljs-comment">// 可能是错的</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">k</span>: <span class="hljs-string">&#x27;0&#x27;</span>
        }
    }
    <span class="hljs-attr">watch</span>: {
        <span class="hljs-title function_">k</span>(<span class="hljs-params">nv, ov</span>) {...}
    }
    <span class="hljs-attr">watch</span>: {
        <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">k</span>, <span class="hljs-comment">// 获取响应式数据的方法</span>
        <span class="hljs-function">(<span class="hljs-params">nv, ov</span>) =&gt;</span> {...}
    }
    <span class="hljs-attr">watch</span>: {
        <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>, <span class="hljs-comment">// 监听一个复杂表达式。就像监听一个未被定义的计算属性</span>
        <span class="hljs-function">(<span class="hljs-params">nv, ov</span>) =&gt;</span> {...}
    }
    <span class="hljs-comment">// const unwatch = vm.$watch(&#x27;k&#x27;, cb) 会返回一个取消监听的方法。用于停止监听。</span>
    <span class="hljs-attr">watch</span>: {
        <span class="hljs-string">&#x27;k&#x27;</span>,
        cb,
        {
            <span class="hljs-attr">deep</span>: boolean <span class="hljs-comment">// 是否深度监听</span>
            <span class="hljs-attr">immediate</span>: boolean <span class="hljs-comment">// 当表达式的值改变时是否立即执行回调</span>
            <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;pre&#x27;</span> | <span class="hljs-string">&#x27;post&#x27;</span> | <span class="hljs-string">&#x27;sync&#x27;</span> <span class="hljs-comment">// 是否深度监听</span>
            <span class="hljs-comment">// pre 在渲染前调用回调</span>
            <span class="hljs-comment">// post 在渲染后调用回调</span>
            <span class="hljs-comment">// sync 回调调用回调</span>
        }
    }
}
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// vue3</span>
<span class="hljs-keyword">import</span> {ref, watch} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
    <span class="hljs-title function_">watch</span>(counter, <span class="hljs-function">(<span class="hljs-params">nv, ov</span>) =&gt;</span> {...})
}
</code></pre>
<h3 id="组合式-api--选项式-api">组合式 api &amp; 选项式 api</h3>
<table>
<thead>
<tr>
<th></th>
<th>组合式 api</th>
<th>选项式 api</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>setup</td>
<td>无 setup</td>
</tr>
<tr>
<td>生命周期函数</td>
<td>是方法。逻辑在方法体内执行。</td>
<td>是方法，参数是回调方法。逻辑在回调方法中执行。</td>
</tr>
<tr>
<td></td>
<td>底层</td>
<td>基于组件式 api 开发的</td>
</tr>
<tr>
<td></td>
<td>它根本不是沉浸式 api.(vue 团队就喜欢做公关)</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="参数">参数</h3>
<ol>
<li>props。它是响应式的。不能解构。</li>
<li>context。非响应式对象。
<ol>
<li>{attrs, slots, emit, expose} // 因 emit 不是名词所有不使用复数</li>
</ol>
</li>
</ol>
<p>当传入新的 props 时组件会更新。（这与 react 的处理逻辑一样）<br>
expose 会返回可在外部组件实例访问的数据。</p>
<pre><code class="language-js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) {
    <span class="hljs-keyword">const</span> k = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
    context.<span class="hljs-title function_">expose</span>({
        <span class="hljs-attr">k</span>: k
    })
    <span class="hljs-keyword">return</span> {...}
}
</code></pre>
<h3 id="如何理解-setup">如何理解 setup</h3>
<ul>
<li>代替了生命周期 beforeCreate / created</li>
<li>用于关注点分离。返回数据和基本的方法。</li>
<li>在组合式 api 中使用。vue2 使用的是选项式 api.</li>
<li>vue 本来是用 setup()去实现模块化的，后来又加入语法糖。结果搞成什么都乱七八糟。</li>
</ul>
<h3 id="在-script-标签中使用-setup">在 script 标签中使用 setup</h3>
<p>这就是组合式 api 的第二种写法。根本不是语法糖，一点方便都没有带给我们。</p>
<pre><code class="language-js">&lt;script setup&gt;
<span class="hljs-keyword">import</span> {
    defineProp, <span class="hljs-comment">// 接收父组件传来的props</span>
    defineEmits, <span class="hljs-comment">// 声明可触发的事件</span>
    useContext, <span class="hljs-comment">// 创建本组件的上下文context</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;eventName&#x27;</span>])
<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({<span class="hljs-attr">k</span>: <span class="hljs-title class_">String</span>})
<span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>()
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>, p)
}
&lt;/script&gt;
</code></pre>
<h2 id="computed">computed</h2>
<p>可以从 Vue 导入的 computed 函数<strong>在 Vue 组件外</strong>创建计算属性。<br>
ref、computed 都是使用<code>.value</code>访问响应式值。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> twiceTheCounter = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> counter.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>) <span class="hljs-comment">// 使用comp.value访问值</span>
counter.<span class="hljs-property">value</span>++
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-property">value</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(twiceTheCounter.<span class="hljs-property">value</span>) <span class="hljs-comment">// 访问twiceTheCounter的值</span>
</code></pre>
<h3 id="参数">参数</h3>
<p>在 vue3.2+新增了<code>onTrack / onTrigger</code>参数。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> plusOne = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>, {
  <span class="hljs-title function_">onTrack</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-comment">// 当 count.value 作为依赖被追踪时触发</span>
    <span class="hljs-keyword">debugger</span>
  },
  <span class="hljs-title function_">onTrigger</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-comment">// 当 count.value 被修改时触发</span>
    <span class="hljs-keyword">debugger</span>
  },
})
<span class="hljs-comment">// 访问 plusOne，应该触发 onTrack</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(plusOne.<span class="hljs-property">value</span>)
<span class="hljs-comment">// 修改 count.value，应该触发 onTrigger</span>
count.<span class="hljs-property">value</span>++
</code></pre>
<h2 id="css">css</h2>
<h3 id="变量注入">变量注入</h3>
<pre><code class="language-js">&lt;script&gt;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>({<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>})
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> state
    }
&lt;/script&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css">
    <span class="hljs-selector-class">.c</span> {
        <span class="hljs-attribute">color</span>: <span class="hljs-built_in">v-bind</span>(<span class="hljs-string">&#x27;state.color&#x27;</span>)
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<h2 id="内置组件">内置组件</h2>
<h3 id="transition--transitiongroup"><a href="/framework/vue3/translate.html">Transition &amp; TransitionGroup</a></h3>
<h3 id="transition">Transition</h3>
<ul>
<li><strong>只是过滤，不是动画。</strong></li>
<li>可以为过滤期设置动画。</li>
<li>设置一个元素进入、离开 dom 时的动画。</li>
</ul>
<p>触发条件：</p>
<ul>
<li>v-if</li>
<li>v-show</li>
<li><code>&lt;component&gt;</code>切换时的动态组件</li>
</ul>
<p><img src="/framework/vue3/transition-classes.f0f7b3c9.png" alt=""></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>v-enter-from</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-enter-active</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-enter-to</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-leave-from</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-leave-active</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>v-leave-to</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 为过渡效果命名。 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Transition</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 命名过渡类名 --&gt;</span>
.xxx-enter-from .xxx-enter-active .xxx-enter-to .xxx-leave-from
.xxx-leave-active .xxx-leave-to
<span class="hljs-comment">&lt;!-- 命名的过渡类 --&gt;</span>
</code></pre>
<h3 id="transitiongroup">TransitionGroup</h3>
<ul>
<li>设置一个列表进入、离开 dom 时的动画。</li>
<li>必须有 tag</li>
<li>成组过渡</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Transition</th>
<th>TransitionGroup</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>使用 tag props 指定容器标签</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>不能过渡模式 mode</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>列表中每个元素都有独一无二的 key</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>过渡 class 会应用于列表中各元素上。</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">TransitionGroup</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">TransitionGroup</span>&gt;</span>
</code></pre>
<h3 id="keepalive">KeepAlive</h3>
<ul>
<li>用于缓存组件。</li>
<li>include &amp; exclude</li>
<li>max.达到最大值使用 lru 处理（最久未使用的组件被移除）。</li>
<li>onActivated() &amp; onDeactivated()</li>
</ul>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 以英文逗号分隔的字符串 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;a,b&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 正则表达式 (需使用 `v-bind`) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;/a|b/&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 数组 (需使用 `v-bind`) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span>
</code></pre>
<h3 id="teleport">Teleport</h3>
<ul>
<li>把指定 dom 元素放在 dom 树的其它位置。</li>
<li>to</li>
<li>disabled</li>
<li>可共享目标</li>
<li>当目标元素匹配多个时，只有第一个有效。</li>
</ul>
<h3 id="suspense">Suspense</h3>
<ul>
<li>用于协调加载异步组件</li>
<li>支持的异步依赖：
<ul>
<li>setup()中有 await()</li>
<li>异步组件</li>
</ul>
</li>
<li>#default &amp; #fallback</li>
<li>pending &amp; resolve &amp; fallback</li>
<li>本身不提供错误处理，可以使用 errorCaptured 事件或<code>onErrorCaptured()</code>钩子。</li>
<li>常常与<code>&lt;Transition&gt;``&lt;Keepalive&gt;</code>结合使用。</li>
</ul>
<h3 id="component">component</h3>
<h3 id="slot">slot</h3>
<h3 id="template">template</h3>
<h2 id="内置的attributes">内置的attributes</h2>
<h3 id="key">key</h3>
<h3 id="ref">ref</h3>
<h3 id="is">is</h3>
<h2 id="todo">todo</h2>
<h3 id="为什么全局注册的事件可以在所有组件中使用">为什么全局注册的事件可以在所有组件中使用</h3>
<p>可能是在 vue 的实例（vdom）中的原型链上挂载了组件。</p>
<h3 id="script-setup做了什么"><code>&lt;script setup&gt;</code>做了什么</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>定义宏</td>
<td>defineProps()</td>
<td>声明可接收的 props</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>defineEmits()</td>
<td>声明暴露的事件</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>组件</td>
<td>引入后直接使用</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>defineEmits()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>defineEmits()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>defineEmits()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>defineEmits()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>把所有 js 代码当作 setup()的方法化。全部暴露出来。</td>
<td>需要从源码中验证。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="script-setup--script"><code>&lt;script setup&gt; &amp; &lt;script&gt;</code></h3>
<p>虽然 vue 官网推荐使用<code>&lt;script setup&gt;</code>，但是我仍喜欢<code>&lt;script&gt;</code> + <code>setup()</code>。因为它模块化更好，语义更好。</p>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th><code>&lt;script setup&gt;</code></th>
<th><code>&lt;script&gt;</code></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>-</td>
<td>必须使用<code>setup(){return{...}}</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>props</td>
<td><code>let props = defineProps(['xxx'])</code></td>
<td><code>props: [...]</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>emits</td>
<td><code>let emits = defineEmits(['xxx'])</code></td>
<td><code>emits: [...]</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>组件</td>
<td>引入后直接在 template 中使用</td>
<td>引入后使用<code>components: {...}</code>注册</td>
<td>template 中使用<code>$emit(...)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>直接使用<code>provide(key, value)</code></td>
<td>在 setup 中使用<code>provide(key, value)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>defineComponent()</code>可以传递给<code>setup()</code>的参数<code>prop</code>的推导</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<p>vue 团队非要搞“语法糖”，结果搞乱了。</p>
<h3 id="title">title</h3>
<h3 id="title">title</h3>
<h3 id="title">title</h3>
<h3 id="title">title</h3>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>