<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>hooks</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="hooks">hooks</h1>
<blockquote>
<p>只能在方法组件的最顶层使用。<br>
以'use'开头。意为只是使用，不是创建。<br>
Hook 可以存在方法组件的顶层和另一个 hook 中。<br>
在 React 的函数组件中调用 Hook<br>
在自定义 Hook 中调用其他 Hook<br>
它是一个特定方法，可以“hook into”react 功能
为方法组件提供生命周期方法功能<br>
从 react v16.8 开始支持 hooks。<br>
内置于 react 中<br>
100%向后兼容<br>
不影响使用 class 组件<br>
不计划代替 class 组件<br>
可以不迁移 class 组件<br>
ellint-plugin-react-hooks 已经内置与 create-react-app 中</p>
</blockquote>
<h2 id="feature">feature</h2>
<ul>
<li>可访问状态</li>
<li>可处理生命周期方法</li>
</ul>
<h2 id="usage">usage</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> [value, setValue] = <span class="hljs-title function_">useState</span>(initValue?)
用于处理组件内的状态
组件更新时返回最近的状态。（它是如何做到的？）
setValus（与useState）都会自动合并更新对象。
内部使用object.<span class="hljs-property">is</span>判断新旧状态是否相同。若相同，则不触发更新。
setValue是异步的。react会打包一批更新为一次更新。
<span class="hljs-title function_">setValue</span>(newValue)
<span class="hljs-title function_">setValue</span>(<span class="hljs-function">(<span class="hljs-params">preValue</span>) =&gt;</span> {...; reture obj}) <span class="hljs-comment">// preValue是当前value的值</span>
<span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {reture obj})
可使用<span class="hljs-title function_">flushSync</span>()强制立即更新。非必要不使用。
<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setValue</span>(...)
})

<span class="hljs-title function_">useEffect</span>(fn, ...listener = [])
用于处理副作用
在componentDidMount/componentDidUpdate/componentWillUnmount时触发。
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {})             =&gt; componentDidMount, componentDidUpdate
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {}, [])         =&gt; componentDidMount
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {}, [p])        =&gt; componentDidMount, 当p改变时
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {               =&gt; componentWillUnMount是执行f
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params"></span>) =&gt; {}
    <span class="hljs-keyword">return</span> f
})
fn中不能直接使用异步方法（<span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span>），需要使用立即执行函数包裹异步方法。
若fn返回一个方法则方法在御载组件前被react框架调用。
listener指定当哪个变量变化（使用浅复制比较）时触发fn.
尽量把不相关的监听写在不同的useEffect里。
当视图更新后执行fn。
fn应该是纯函数。
类似vue的watchEffect
<span class="hljs-comment">// 最好不要执行fn内定义的方法。？</span>
fn只在指定时刻执行，如dep改变时。在useEffect外、组件内的代码会在每次渲染时执行。
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>()
  <span class="hljs-keyword">let</span> signal = controller.<span class="hljs-property">signal</span>
  <span class="hljs-title function_">fetch</span>(url, {signal}).<span class="hljs-title function_">then</span>(...).<span class="hljs-title function_">catch</span>(...)
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    controller.<span class="hljs-title function_">abort</span>()
  }
}, [id])

<span class="hljs-keyword">let</span> value = <span class="hljs-title function_">useContext</span>(myContext)
接收一个 context 对象（<span class="hljs-title class_">React</span>.<span class="hljs-property">createContext</span> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span>&gt; 的 value prop 提供。
示例见上一个页面。
当context的value改变时更新组件

<span class="hljs-keyword">let</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialArg, init?)
init是一个方法。参数是initialArg。初始数据会被设置为<span class="hljs-title function_">init</span>(initialArg)
与useState功能相似。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 <span class="hljs-title class_">Redux</span> 的话，就已经知道它如何工作了。）
<span class="hljs-title function_">dispatch</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;typename&#x27;</span>, <span class="hljs-attr">key</span>: value}) <span class="hljs-comment">// dispatch的参数是action. action.type, action.key</span>
<span class="hljs-comment">// 定义</span>
<span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> res
    <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:
            res = {<span class="hljs-attr">k</span>: state.<span class="hljs-property">k</span> + action.<span class="hljs-property">payload</span>}
        <span class="hljs-attr">default</span>:
            res = state
    }
    <span class="hljs-keyword">return</span> res
}, {<span class="hljs-attr">k</span>: <span class="hljs-number">0</span>}, <span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> p
})
<span class="hljs-comment">// 使用</span>
state.<span class="hljs-property">k</span> <span class="hljs-comment">// 0</span>
<span class="hljs-title function_">dispatch</span>({<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">2</span>})

<span class="hljs-keyword">let</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(fn, ...dependencies)
只有dependencies改变时执行fn。可用于阻止不必要的重新渲染。
返回一个 memoized 回调函数。
只在更新组件时执行。等价于 <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> fn, ...dependencies)
像vue里的computer

<span class="hljs-keyword">let</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(fn, ...dependencies)
返回一个 memoized 值。
与useCallback类似。当dependencies中有值改变时执行fn。
它是在渲染时运行的，不要做任务应该在useEffect中运行的代码。
它只是用于优化性能，不用它，功能照样可以实现。

<span class="hljs-keyword">let</span> refContainer = <span class="hljs-title function_">useRef</span>(initialValue?)
useRef 返回一个可变的 ref 对象，其 .<span class="hljs-property">current</span> 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。
组件重新渲染期间其值一直存在。
改变其值时不会重新渲染组件。
可以使用它：得到dom元素，跟踪状态变化（保存变化前的状态），
遇事不绝，useRef. 责任大，困难多。
<span class="hljs-keyword">let</span> inputEl = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)
&lt;input ref={inputEl} /&gt;
<span class="hljs-keyword">let</span> <span class="hljs-title function_">btClickHandler</span> = (<span class="hljs-params"></span>) =&gt; {
    inputEl.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()
}
&lt;button onClick={btClickHandler}&gt;bt&lt;/button&gt;

<span class="hljs-title function_">useImperativeHandle</span>(ref, createHandle, [deps])
useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用：
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span> () {
    <span class="hljs-keyword">let</span> counterRef = <span class="hljs-title function_">useRef</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">reset</span> = (<span class="hljs-params"></span>) =&gt; {
        counterRef.<span class="hljs-property">current</span>.<span class="hljs-property">resetCount</span> &amp;&amp; counterRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">resetCount</span>()
    }
    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{reset}</span>&gt;</span>reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">MyC</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{counterRef}/</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span> (props, ref) {
    <span class="hljs-keyword">let</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">btClickHandler</span> = (<span class="hljs-params"></span>) =&gt; {
        <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>)
    }
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">resetCount</span> = (<span class="hljs-params"></span>) =&gt; {<span class="hljs-title function_">setCount</span>(<span class="hljs-number">0</span>)}
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-attr">resetCount</span>: resetCount
    })
    <span class="hljs-keyword">return</span> (&lt;div&gt;
        &lt;span&gt;{count}&lt;span&gt;
        &lt;button onClick={btClickHandler}&gt;+1&lt;/button&gt;
    &lt;/div&gt;)
}
export default MyC = React.forwardRef(C)
除了暴露指定的方法外，还可以指定暴露的属性、数据。

useLayoutEffect
其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，
执行顺序：更新变量值 -》 组件重新渲染 -》 执行useLayoutEffect -&gt; 显示渲染结果 -》 执行useEffect
尽可能使用标准的 useEffect 以避免阻塞视觉更新。
与useEffect有相同的触发机制

useDebugValue(value, [fn])
可用于在 React 开发者工具中显示自定义 hook 的标签。
不会

let deferredValue = useDeferredValue(value)
会根据value返回一个复制的deferredValue（延迟数据）。当有急切的更新时要，react会返回原来的值，当更新结束后再使用新值更新组件。
使用它可实现节流、防抖功能。它会在别的更新结束后马上更新。
使用React.useMemo / React.Memo与React.useDeferredValue结合可阻止子组件也参与急切的更新。
function Comp () {
    let query = useSearchQuery(&#x27;&#x27;)
    let deferredValue = useDeferredValue(query)
    let suggestions = useMemo(() =&gt; {
        return &lt;SearchSuggestion query={deferredValue}&gt;
    }, [deferredValue])
    return (
        &lt;SearchInput query={query} /&gt;
        &lt;Suspense fallback=&quot;str&quot;&gt;
            {suggestions}
        &lt;/Suspense&gt;
    )
}

let [isPending, startTransition] = useTransition()
用于降低渲染优先级.
isPending表示是否处理pending状态。
let [isPending, startTransition] = useTransition()
let [search, setSearch] = useState()
let inputChangeHandle = (event) =&gt; {
    startTransition(() =&gt; {
        setSearch(event.target.value)
    })
}
&lt;input type=&quot;text&quot; onChange={inputChangeHandle} /&gt;
&lt;SearchComp searchStr={search}&gt;

let id = useId() // 如 :r1:
返回一个惟一的id.可用于跨平台。string类型。包括:
可以为该返回值id设置前缀、后缀。
不要用于list中的key。该key应该从渲染数据中取得。
let id = useId()
&lt;label htmlFor={id} /&gt;
&lt;input id={id} /&gt;

let state = useSyncExternalStore(subscribe, getSnapshot[, getServerSnapshort])
对任务进行优先级排序并同时执行多个任务。
外部存储：redux/zustand/...
内部存储：useState/props/context/...
可以把外部存储的数据读来和订阅。
react要知道外部数据的变化，搞了这样的hook。
subscribe           当store改变时触发的订阅方法。
getSnapshot         返回当前store的值
getServerSnapshot   在服务器上渲染时，返回当前store的值
eg：let state = useSyncExternalStore(store.subscribe, store.getSnapshot)
详见状态管理

useInsertionEffect(didUpdate)
它与useEffect的用法一样。
它会在所有dom更新前执行。常用于学页面布局。
</code></pre>
<h2 id="useref">useRef</h2>
<table>
<thead>
<tr>
<th></th>
<th>dom 元素</th>
<th>类组件</th>
<th>函数式组件</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>ref</td>
<td>得到对应的 dom</td>
<td>得到 class 组件的实例</td>
<td>得到<code>{current: ...}</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="forwardref">forwardRef</h2>
<p>函数式组件使用 ref 时，需要使用<code>forwardRef</code>包裹。</p>
<pre><code class="language-js"><span class="hljs-comment">// React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点。</span>
<span class="hljs-comment">// 这样我们就将父组件中创建的ref转发进子组件，并赋值给子组件的input元素，进而可以调用它的focus方法。</span>
<span class="hljs-keyword">let</span> <span class="hljs-title class_">InputComp</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> /&gt;</span></span>
})
<span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span> () {
    <span class="hljs-keyword">let</span> inputEl = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">btClickHandler</span> = (<span class="hljs-params"></span>) =&gt; {
        inputEl.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()
    }
    <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">InputComp</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputEl}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{btClickHandler}</span>&gt;</span>bt<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/&gt;</span>
    )
}
</span></code></pre>
<h2 id="api">api</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td>description</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="uml">uml</h2>
<p><a href="https://www.cnblogs.com/bejamin/p/15116546.html">https://www.cnblogs.com/bejamin/p/15116546.html</a></p>
<h2 id="自定义-hook">自定义 hook</h2>
<p><strong>Hook 用途：封装为可多次使用的方法。与 uitl 功能相同。</strong></p>
<p>监听对象改变时输出。</p>
<pre><code class="language-js"><span class="hljs-comment">// 定义</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useLogger</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
  }, [value])
}
<span class="hljs-comment">// 使用</span>
<span class="hljs-title function_">useLogger</span>(stateValue)
</code></pre>
<p>设置表单的初始值、验证规则。</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFormField</span>(<span class="hljs-params">initialVal = <span class="hljs-string">&#x27;&#x27;</span>, rule = () =&gt; <span class="hljs-literal">true</span></span>) {
  <span class="hljs-keyword">const</span> [val, setVal] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(initialVal)
  <span class="hljs-keyword">const</span> [isValid, setValid] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onChange</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-title function_">setVal</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)
    <span class="hljs-title function_">setValid</span>(<span class="hljs-title function_">rule</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>))
  }
  <span class="hljs-comment">//   return [val, onChange, isValid];</span>
  <span class="hljs-keyword">return</span> [val, isValid]
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useFormField
<span class="hljs-comment">// 使用</span>
</code></pre>
<p>xxx</p>
<pre><code class="language-js">useSubmit
</code></pre>
<p>xxx</p>
<pre><code class="language-js">useBoolean
</code></pre>
<p>xxx</p>
<pre><code class="language-js">useLocalStorage
</code></pre>
<p>xxx</p>
<pre><code class="language-js">useFontsize
</code></pre>
<p>xxx</p>
<pre><code class="language-js">useFetch
<span class="hljs-keyword">const</span> <span class="hljs-title function_">useFetch</span> = (<span class="hljs-params">initialUrl, initialParams = {}, skip = <span class="hljs-literal">false</span></span>) =&gt; {
  <span class="hljs-keyword">const</span> [url, updateUrl] = <span class="hljs-title function_">useState</span>(initialUrl)
  <span class="hljs-keyword">const</span> [params, updateParams] = <span class="hljs-title function_">useState</span>(initialParams)
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> [isLoading, setIsLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> [hasError, setHasError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> [errorMessage, setErrorMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)
  <span class="hljs-keyword">const</span> [refetchIndex, setRefetchIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
  <span class="hljs-keyword">const</span> queryString = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(params)
    .<span class="hljs-title function_">map</span>(
      <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> <span class="hljs-built_in">encodeURIComponent</span>(key) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(params[key])
    )
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>)
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">refetch</span> = (<span class="hljs-params"></span>) =&gt;
    <span class="hljs-title function_">setRefetchIndex</span>(<span class="hljs-function">(<span class="hljs-params">prevRefetchIndex</span>) =&gt;</span> prevRefetchIndex + <span class="hljs-number">1</span>)
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-keyword">if</span> (skip) <span class="hljs-keyword">return</span>
      <span class="hljs-title function_">setIsLoading</span>(<span class="hljs-literal">true</span>)
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`<span class="hljs-subst">${url}</span><span class="hljs-subst">${queryString}</span>`</span>)
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>()
        <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {
          <span class="hljs-title function_">setData</span>(result)
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">setHasError</span>(<span class="hljs-literal">true</span>)
          <span class="hljs-title function_">setErrorMessage</span>(result)
        }
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-title function_">setHasError</span>(<span class="hljs-literal">true</span>)
        <span class="hljs-title function_">setErrorMessage</span>(err.<span class="hljs-property">message</span>)
      } <span class="hljs-keyword">finally</span> {
        <span class="hljs-title function_">setIsLoading</span>(<span class="hljs-literal">false</span>)
      }
    }
    <span class="hljs-title function_">fetchData</span>()
  }, [url, params, refetchIndex])
  <span class="hljs-keyword">return</span> {
    data,
    isLoading,
    hasError,
    errorMessage,
    updateUrl,
    updateParams,
    refetch,
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useFetch
</code></pre>
<pre><code class="language-js">useDeepEffect
</code></pre>
<pre><code class="language-js">usePageBottom
</code></pre>
<pre><code class="language-js">useInfinitRoll
</code></pre>
<pre><code class="language-js">useAxios
</code></pre>
<pre><code class="language-js">useBreakPoint
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { useMediaQuery } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@mountain-ui/react-hooks&#x27;</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useViewport</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> isMobile = <span class="hljs-title function_">useMediaQuery</span>(
    <span class="hljs-string">&#x27;screen add (min-width: 1px) and (max-width: 513px)&#x27;</span>
  )
  <span class="hljs-keyword">let</span> isTablet = <span class="hljs-title function_">useMediaQuery</span>(
    <span class="hljs-string">&#x27;screen add (min-width: 514px) and (max-width: 1205px)&#x27;</span>
  )
  <span class="hljs-keyword">return</span> {
    isMobile,
    isTablet,
    <span class="hljs-attr">isDesktop</span>: !isMobile &amp;&amp; !isTablet,
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useViewport
</code></pre>
<pre><code class="language-js">useDeepEffect
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useInterval</span>(<span class="hljs-params">cb = () =&gt; {}, delay = <span class="hljs-number">10</span></span>) {
  <span class="hljs-keyword">let</span> savedCallback = <span class="hljs-title function_">useRef</span>()
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    savedCallback.<span class="hljs-property">current</span> = cb
  }, [cb])
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) {
      savedCallback.<span class="hljs-title function_">current</span>()
    }
    <span class="hljs-keyword">if</span> (delay !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">setInterval</span>(tick, delay)
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id)
    }
  }, [delay])
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useInterval
</code></pre>
<pre><code class="language-js">useDeviceDetect
</code></pre>
<p>得到、设置 ls 里的值。（不能实现监听）</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-params">key, initialValue</span>) {
  <span class="hljs-keyword">const</span> [storedValue, setStoredValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)
      <span class="hljs-keyword">return</span> item ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(item) : initialValue
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">return</span> initialValue
    }
  })
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">setValue</span> = (<span class="hljs-params">value</span>) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> valueToStore =
        value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span> ? <span class="hljs-title function_">value</span>(storedValue) : value
      <span class="hljs-title function_">setStoredValue</span>(valueToStore)
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(valueToStore))
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)
    }
  }
  <span class="hljs-keyword">return</span> [storedValue, setValue]
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useLocalStorage
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useOnline</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [online, setOnline] = <span class="hljs-title function_">useState</span>(navigator.<span class="hljs-property">onLine</span>)
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">offlineHandler</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">setOnline</span>(<span class="hljs-literal">false</span>)
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onlineHandler</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">setOnline</span>(<span class="hljs-literal">true</span>)
  }
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setOnline</span>(navigator.<span class="hljs-property">onLine</span>)
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;online&#x27;</span>, onlineHandler)
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;offline&#x27;</span>, offlineHandler)
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;online&#x27;</span>, onlineHandler)
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;offline&#x27;</span>, offlineHandler)
    }
  }, [])
  <span class="hljs-keyword">return</span> online
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useOnline
</code></pre>
<p>没发现它有独特的用途</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useStore</span>(<span class="hljs-params">key, initValue</span>) {
  <span class="hljs-keyword">let</span> ref = <span class="hljs-title function_">useRef</span>({ key, initValue })
  <span class="hljs-keyword">let</span> <span class="hljs-title function_">setRef</span> = (<span class="hljs-params">key, value</span>) =&gt; {
    ref.<span class="hljs-property">current</span>[key] = value
  }
  <span class="hljs-keyword">let</span> <span class="hljs-title function_">getRef</span> = (<span class="hljs-params">key</span>) =&gt; {
    <span class="hljs-keyword">return</span> ref.<span class="hljs-property">current</span>[key]
  }
  <span class="hljs-keyword">return</span> [getRef, setRef]
}
<span class="hljs-comment">// 使用</span>
<span class="hljs-title function_">useStore</span>(stateValue)
</code></pre>
<p>当依赖项改变时，执行异步方法。</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useAsyncEffect</span>(<span class="hljs-params">fn, deps, ...args</span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    ;(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn</span>(...args)
    })()
  }, deps)
}
</code></pre>
<p>懒加载非首屏的组件。可用于减少打包体积、减小非必要回馈。</p>
<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">usePrefetch</span>(<span class="hljs-params">factory</span>) {
    <span class="hljs-keyword">let</span> [comp, setComp] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>)
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">let</span> comp = <span class="hljs-title function_">lazy</span>(factory)
        <span class="hljs-title function_">setComp</span>(comp)
    }, [factory])
    <span class="hljs-keyword">return</span> comp
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">importModal</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal&#x27;</span>)
<span class="hljs-keyword">let</span> <span class="hljs-title class_">Modal</span> = <span class="hljs-title function_">usePrefetch</span>(importModal) <span class="hljs-comment">// 一定要写成这样，否则会是触发useEffect</span>
isShow &amp;&amp; &lt;<span class="hljs-title class_">Modal</span>&gt;
</code></pre>
<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useGeo</span>(<span class="hljs-params">opts</span>) {
  <span class="hljs-keyword">let</span> [isLoading, setIsLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)
  <span class="hljs-keyword">let</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">let</span> [geo, setGeo] = <span class="hljs-title function_">useState</span>({})
  <span class="hljs-keyword">let</span> isLoad = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">let</span> id
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onSuccess</span>(<span class="hljs-params">event</span>) {
    <span class="hljs-keyword">if</span> (isLoad) {
      <span class="hljs-title function_">setIsLoading</span>(<span class="hljs-literal">false</span>)
      <span class="hljs-title function_">setGeo</span>(event.<span class="hljs-property">coords</span>)
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">opFailure</span>(<span class="hljs-params">error</span>) {
    <span class="hljs-keyword">if</span> (isLoad) {
      <span class="hljs-title function_">setIsLoading</span>(<span class="hljs-literal">false</span>)
      <span class="hljs-title function_">setError</span>(error)
    }
  }
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    navigator.<span class="hljs-property">geolocation</span>.<span class="hljs-title function_">getCurrentPosition</span>(onSuccess, onFailure, opts)
    id = navigator.<span class="hljs-property">geolocation</span>.<span class="hljs-title function_">watchPosition</span>(onSuccess, onFailure, opts)
    isLoad = <span class="hljs-literal">false</span>
    navigator.<span class="hljs-property">geolocation</span>.<span class="hljs-title function_">clearWatch</span>(id)
  }, [opts])
}
<span class="hljs-keyword">let</span> { geo, isLoading, error } = <span class="hljs-title function_">useGeo</span>()(!isLoading &amp;&amp; !error) ? (
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
) : <span class="hljs-literal">null</span>
</code></pre>
<p>节流</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> useThrottle&lt;T&gt;(<span class="hljs-attr">value</span>: T, interval = <span class="hljs-number">500</span>): T {
  <span class="hljs-keyword">const</span> [throttledValue, setThrottledValue] = useState &lt; T &gt; value
  <span class="hljs-keyword">const</span> lastExecuted = useRef &lt; number &gt; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &gt;= lastExecuted.<span class="hljs-property">current</span> + interval) {
      lastExecuted.<span class="hljs-property">current</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
      <span class="hljs-title function_">setThrottledValue</span>(value)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        lastExecuted.<span class="hljs-property">current</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
        <span class="hljs-title function_">setThrottledValue</span>(value)
      }, interval)
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timerId)
    }
  }, [value, interval])
  <span class="hljs-keyword">return</span> throttledValue
}
<span class="hljs-comment">// let cb = useCallback(() =&gt; {</span>
<span class="hljs-comment">//     fn(args)</span>
<span class="hljs-comment">// }, args)</span>
<span class="hljs-keyword">let</span> prevRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>())
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useThrottleFn</span>(<span class="hljs-params">fn, args, delay, opts</span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()
    <span class="hljs-keyword">if</span> (now - prevRef.<span class="hljs-property">current</span> &gt; delay) {
      <span class="hljs-title function_">fn</span>(args)
      prevRef.<span class="hljs-property">current</span> = now
    }
  }, opts)
}
</code></pre>
<p>去抖
指定时长后执行
待测试</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> prevRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>())
<span class="hljs-keyword">let</span> timeoutId = <span class="hljs-title function_">useRef</span>()
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useDebounceFn</span>(<span class="hljs-params">fn, args, delay, opts</span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()
    <span class="hljs-comment">// 先清空</span>
    timeoutId.<span class="hljs-property">current</span> &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timeoutId.<span class="hljs-property">current</span>)
    <span class="hljs-comment">// 再定义</span>
    timeoutId.<span class="hljs-property">current</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">fn</span>(args)
      prevRef.<span class="hljs-property">current</span> = now
    }, delay)
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 卸载时清空</span>
      <span class="hljs-built_in">clearTimeout</span>(timeoutId.<span class="hljs-property">current</span>)
    }
  }, opts)
}
</code></pre>
<p>useFilter</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useFilter</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> [_filter, _setFilter] = <span class="hljs-title class_">React</span>.<span class="hljs-property">useState</span>&lt;{<span class="hljs-string">&quot;key&quot;</span>: {[<span class="hljs-attr">x</span>: string]: {[<span class="hljs-attr">x</span>:string]: any}}}&gt;({<span class="hljs-string">&quot;key&quot;</span>: {}})
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getFilter</span> = (<span class="hljs-params">pageKey: string, tableKey: string</span>) =&gt; {
        <span class="hljs-keyword">const</span> f = _filter[<span class="hljs-string">&#x27;key&#x27;</span>][<span class="hljs-string">`<span class="hljs-subst">${pageKey}</span>_<span class="hljs-subst">${tableKey}</span>`</span>]
        <span class="hljs-keyword">return</span> f;
    }
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setFilter</span> = (<span class="hljs-params">pageKey: string, tableKey: string, values: {[x:string]: any}={}</span>) =&gt; {
        values.<span class="hljs-property">resetCurrentPage</span> = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">const</span> data = _filter.<span class="hljs-property">key</span>;
        data[<span class="hljs-string">`<span class="hljs-subst">${pageKey}</span>_<span class="hljs-subst">${tableKey}</span>`</span>] = values;
        <span class="hljs-title function_">_setFilter</span>({
            <span class="hljs-string">&quot;key&quot;</span>: data
        })
    }
    <span class="hljs-keyword">return</span> { getFilter, setFilter }
}
<span class="hljs-comment">// js</span>
<span class="hljs-keyword">import</span> {useState} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useFilter</span> () {
    <span class="hljs-keyword">let</span> [_filter, _setFilter] = <span class="hljs-title function_">useState</span>({<span class="hljs-attr">key</span>: {}})
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">getFilter</span> = (<span class="hljs-params">k</span>) =&gt; {
        <span class="hljs-keyword">return</span> _filter.<span class="hljs-property">key</span>[k]
    }
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">setFilter</span> = (<span class="hljs-params">k, v</span>) =&gt; {
        <span class="hljs-keyword">let</span> d = _filter.<span class="hljs-property">key</span>
        d[<span class="hljs-string">`<span class="hljs-subst">${k}</span>`</span>] = v
        <span class="hljs-title function_">_setFilter</span>({<span class="hljs-string">&#x27;key&#x27;</span>: d})
    }
    <span class="hljs-keyword">return</span> {getFilter, setFilter}
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useFilter
<span class="hljs-comment">// 作者常把它用于与context结合使用。</span>
<span class="hljs-comment">// let context = React.createContext()</span>
<span class="hljs-comment">// context.Provider value={{...}}</span>
<span class="hljs-comment">// 再在子组件中使用 this.context.xxx</span>
<span class="hljs-comment">// 会触发组件渲染</span>
</code></pre>
<p>useParams</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useParams</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> [_params, _setParams] = <span class="hljs-title class_">React</span>.<span class="hljs-property">useState</span>&lt;{[<span class="hljs-attr">x</span>: string]: {[<span class="hljs-attr">x</span>:string]: any}}&gt;({})
    <span class="hljs-comment">//使用 useRef 渲染周期之前共享数据的存储（state触发重新渲染，ref不会）</span>
    <span class="hljs-keyword">const</span> countRef = <span class="hljs-title class_">React</span>.<span class="hljs-property">useRef</span>&lt;{[<span class="hljs-attr">x</span>: string]: {[<span class="hljs-attr">x</span>:string]: any}}&gt;();
    countRef.<span class="hljs-property">current</span> = _params;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getParams</span> = (<span class="hljs-params">pageKey: string, sectionKey: string</span>) =&gt; {
        <span class="hljs-keyword">const</span> params = countRef.<span class="hljs-property">current</span> || {}
        <span class="hljs-keyword">const</span> f = params[<span class="hljs-string">`<span class="hljs-subst">${pageKey}</span>_<span class="hljs-subst">${sectionKey}</span>`</span>]
        <span class="hljs-keyword">return</span> f;
    }
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setParams</span> = (<span class="hljs-params">pageKey: string, sectionKey: string, value: {[x:string]: any}</span>) =&gt; {
        <span class="hljs-keyword">const</span> params = countRef.<span class="hljs-property">current</span> || {}
        <span class="hljs-title function_">_setParams</span>({
            ...params,
            [<span class="hljs-string">`<span class="hljs-subst">${pageKey}</span>_<span class="hljs-subst">${sectionKey}</span>`</span>]: value
        })

    }
    <span class="hljs-keyword">return</span> { getParams, setParams }
}
<span class="hljs-comment">// 待测试</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useParams</span> () {
    <span class="hljs-keyword">let</span> mapRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">getParams</span> = (<span class="hljs-params">k</span>) =&gt; {
        <span class="hljs-keyword">return</span> mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">get</span>(k)
    }
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">setParams</span> = (<span class="hljs-params">k, v</span>) =&gt; {
        mapRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">set</span>(k, v)
    }
    <span class="hljs-keyword">return</span> {getParams, setParams}
}
</code></pre>
<p>useOnce</p>
<pre><code class="language-js"><span class="hljs-comment">// cf 判断条件的方法。 参数是 dep</span>
<span class="hljs-comment">// fn 若条件满足则执行的方法  参数是args</span>
<span class="hljs-comment">// args   fn方法的参数</span>
<span class="hljs-comment">// dep    依赖</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useOnce</span>(<span class="hljs-params">cf, fn, args, dep</span>) {
  <span class="hljs-keyword">let</span> [hasRun, setHasRun] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cf</span>(dep) &amp;&amp; !hasRun) {
      <span class="hljs-title function_">fn</span>(args)
      <span class="hljs-title function_">setHasRun</span>(<span class="hljs-literal">true</span>)
    }
  }, [dep, args, cf, fn, hasRun])
}
<span class="hljs-comment">// use</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">cf</span> = (<span class="hljs-params">v</span>) =&gt; {
  <span class="hljs-keyword">return</span> v.<span class="hljs-property">length</span> % <span class="hljs-number">3</span> === <span class="hljs-number">2</span>
}
<span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">v</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn&#x27;</span>, v)
}
<span class="hljs-keyword">let</span> [v, setV] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)
<span class="hljs-title function_">useOnce</span>(cf, fn, <span class="hljs-string">&#x27;str&#x27;</span>, v)
</code></pre>
<p>useConstrctor
只运行一次</p>
<pre><code class="language-js"><span class="hljs-comment">// 待测试</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useConstructor</span>(<span class="hljs-params">cb</span>) {
  <span class="hljs-keyword">let</span> init = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">true</span>)
  <span class="hljs-keyword">if</span> (init.<span class="hljs-property">current</span>) {
    <span class="hljs-title function_">cb</span>()
    init.<span class="hljs-property">current</span> = <span class="hljs-literal">false</span>
  }
}
</code></pre>
<p>useApi
显示loading
调用api
只请求一次数据。以后都重用以前的数据。
停止加载</p>
<pre><code class="language-js">useApi = <span class="hljs-function">(<span class="hljs-params">url, options</span>) =&gt;</span> {
  <span class="hljs-comment">// options: {</span>
  <span class="hljs-comment">//   method: 大写</span>
  <span class="hljs-comment">//   headers: {...}</span>
  <span class="hljs-comment">//   body: {...}</span>
  <span class="hljs-comment">//   mode: xx</span>
  <span class="hljs-comment">//   credentialas: {...}</span>
  <span class="hljs-comment">//   ...</span>
  <span class="hljs-comment">// }</span>
  <span class="hljs-keyword">let</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)
  <span class="hljs-keyword">let</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>)
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fetchApi</span> = (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-title function_">fetch</span>(url, options)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>()
      })
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> {
        <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)
        <span class="hljs-title function_">setData</span>(json)
      })
    }
    <span class="hljs-title function_">fetchApi</span>(url, options)
  }, [])
  <span class="hljs-keyword">return</span> {loading, data}
}
</code></pre>
<h2 id="自定义-hooks-的包">自定义 hooks 的包</h2>
<ul>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
<li><a href="">title</a></li>
</ul>
<h2 id="todo">todo</h2>
<h3 id="title">title</h3>
<p>有缓存功能的都可用于性能优化</p>
<h3 id="usestate--useref">useState &amp; useRef</h3>
<table>
<thead>
<tr>
<th></th>
<th>useState</th>
<th>useRef</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>在 ui 更新期间保护自己的数据</td>
<td>在 ui 更新期间保护自己的数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td>可理解为数据钩子</td>
<td>可理解为数据钩子</td>
<td></td>
</tr>
<tr>
<td></td>
<td>会触发重新渲染</td>
<td>不会</td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回[state, setState]</td>
<td>返回一个对象{current: any}</td>
<td></td>
</tr>
<tr>
<td></td>
<td>state 是不可变的。可能使用 setState 去改变</td>
<td>current 属性是可变的</td>
<td></td>
</tr>
<tr>
<td></td>
<td>不可用于访问别的元素</td>
<td>可访问组件、dom</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="usecallback--usememo">useCallback &amp; useMemo</h3>
<table>
<thead>
<tr>
<th></th>
<th>useCallback</th>
<th>useMemo</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>用途</td>
<td>缓存方法</td>
<td>缓存计算结果</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DependencyList</span> = <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">any</span>&gt;

<span class="hljs-keyword">function</span> useCallback&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt;(
  <span class="hljs-attr">callback</span>: T,
  <span class="hljs-attr">deps</span>: <span class="hljs-title class_">DependencyList</span>
): T

<span class="hljs-keyword">function</span> useMemo&lt;T&gt;(<span class="hljs-attr">factory</span>: <span class="hljs-function">() =&gt;</span> T, <span class="hljs-attr">deps</span>: <span class="hljs-title class_">DependencyList</span> | <span class="hljs-literal">undefined</span>): T
</code></pre>
<h3 id="react-use"><a href="https://www.npmjs.com/package/react-use">react-use</a></h3>
<h3 id="mountain-uireact-hooks"><a href="https://www.npmjs.com/package/@mountain-ui/react-hooks">@mountain-ui/react-hooks</a></h3>
<ul>
<li>useBoolean</li>
<li>useDarkMode</li>
<li>useFontSize</li>
<li>useLocalStorage</li>
<li>useMediaQuery</li>
<li>usePrefersDarkMode</li>
<li>useToggle</li>
</ul>
<h3 id="基本结构">基本结构</h3>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useOnline</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useOnline
</code></pre>
<h3 id="title">title</h3>
<h3 id="title">title</h3>
<h2 id="todo">todo</h2>
<h3 id="hook-为什么要在顶层">Hook 为什么要在顶层</h3>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>