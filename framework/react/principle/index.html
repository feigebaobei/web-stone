<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x539f;&#x7406;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="原理">原理</h1>
<p>把 react / react-dom 的原理合并到这个文档中。<br>
<strong>不必学习 react 的每一个细节。我们需要知道它的关键部分。</strong></p>
<h2 id="react-到底做了什么">react 到底做了什么</h2>
<h3 id="核心概念">核心概念</h3>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>recenciliation</td>
<td>调度器，用于处理 diff、更新视图</td>
<td></td>
</tr>
<tr>
<td></td>
<td>root.render(...)</td>
<td>开始渲染视图</td>
<td></td>
</tr>
<tr>
<td></td>
<td>virtual dom</td>
<td>虚拟 dom</td>
<td></td>
</tr>
<tr>
<td></td>
<td>diffing algorithm</td>
<td>diff 算法。通过比较 current/workInProgress,得到最小变动.</td>
<td></td>
</tr>
<tr>
<td></td>
<td>mvc 框架</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>双缓存</td>
<td>current 表示当前展示的 vdom 树。workInProgress 表示本次更新后的 vdom 树。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>fiber</td>
<td>工作单元。根据 ReactElement 元素生成。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ReactElement</td>
<td>使用 React.createElement 方法生成</td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<!-- prettier-ignore-start -->
<h3 id="react-component--react-element--component-instance">React Component &amp; React Element &amp; Component instance</h3>
<table>
<thead>
<tr>
<th></th>
<th>React Component</th>
<th>React Element</th>
<th>Component instance</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>组件。方法或 class</td>
<td>一个基本核心对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回 jsx/ReactElement</td>
<td></td>
<td>class 组件的实例。它是一个对象。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>方法组件，直接调用。class 组件，创建一个实例后调用 render 方法。</td>
<td>可描述一个 dom.也可以描述一个 component instance</td>
<td>有生命周期方法和初始化 state</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>在 class 组件时期用处大</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<h3 id="渲染过程">渲染过程</h3>
<ol>
<li>执行 class 组件的 render 方法或执行方法式组件，生成 Virtual DOM，它保存在内存中。每次执行都是新的<code>ReactElement</code>对象。</li>
<li>同步 vdom 到 real dom。初始化时全部插入。</li>
<li>当组件改变时生成新 vdom</li>
<li>比对 2 个 vdom 的不同。再更新 dom
<ol>
<li>使用 diff 算法比对。也叫 recencilication</li>
</ol>
</li>
</ol>
<h3 id="recenciliation-也叫-diff--diffing">recenciliation (也叫 diff / diffing)</h3>
<p>基于 2 个前提工作：</p>
<ul>
<li>
<p>type 不同表示不同的元素。</p>
</li>
<li>
<p>各子元素的 key 惟一。</p>
</li>
<li>
<p>若 ReactElement 的 type 不同（fiberNode 的 type 来自 ReactElement 对象的 type），则使用新组件及其后代元素。</p>
<ul>
<li>会触发 unmount 生命周期方法</li>
</ul>
</li>
<li>
<p>当 type 相同、属性不同时，更新当前元素，保留其他后代元素。</p>
</li>
</ul>
<h2 id="what-is-react-fiber">what is react fiber</h2>
<ul>
<li>它是一个对象，由<code>ReactElement</code>对象生成。</li>
<li>diff 基于它工作。diff 过程（render phase）是异步的。fiber 是工作单元.</li>
<li>多个 fiber 对象组成树(workInProgress/current)</li>
</ul>
<h3 id="引入fiber的目的">引入fiber的目的</h3>
<ul>
<li>使动画流畅</li>
<li>加快反应速度</li>
</ul>
<h3 id="fiber的功能">fiber的功能</h3>
<ul>
<li>可把工作分块，一个 fiber 对象就是一个工作单元。设置任务优先级。</li>
<li>每一个 ReactElement 都有一个对应的 FiberNode</li>
<li>它是可变对象，在渲染时不会重新创建。</li>
<li>包含组件的状态、dom</li>
<li>提供工作路径、时间表、暂停、打断</li>
<li>使用 createFiberFromTypeAndProps 创建 FiberNode</li>
<li>二叉树结构。child/sibling/return</li>
</ul>
<h3 id="new-reconciler-fiber-出现后">new reconciler (fiber 出现后)</h3>
<ul>
<li>它是一个工作单元</li>
<li>当工作完成时 react process 把工作结果提交。生成新 dom</li>
</ul>
<h3 id="old-reconciler-fiber-出现前">old reconciler (fiber 出现前)</h3>
<ul>
<li>任务是同步的。</li>
<li>工作就像栈。</li>
<li>栈空了才停止工作。</li>
</ul>
<h3 id="fiber--reactelement">Fiber &amp; ReactElement</h3>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th>ReactElement</th>
<th>FiberNode</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>由 jsx 代码生成</td>
<td>由 ReactElement 对象生成</td>
<td></td>
</tr>
<tr>
<td></td>
<td>从 jsx 代码中得到 type/key</td>
<td>从 ReactElement 中取 type/key</td>
<td></td>
</tr>
<tr>
<td></td>
<td>React.createElement</td>
<td>createFiberFromElement / createFiberFromTypeAndProps / createFiber 等</td>
<td></td>
</tr>
<tr>
<td></td>
<td>这是 vdom,代表一个 dom</td>
<td>工作的单元</td>
<td></td>
</tr>
<tr>
<td>功能</td>
<td></td>
<td>1. 寻迹。 2. 暂停。 3. 制定时间表</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>一直使用。若有变动，则修改属性。不销毁（除非删除dom节点）。通常在初次挂载时创建</td>
<td>修改是在 FiberNode 的替补节点上完成的。</td>
</tr>
<tr>
<td>如何 ReactElement =&gt; FiberNode</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<pre><code class="language-js"><span class="hljs-comment">// 常见的创建fiber的方法</span>
<span class="hljs-title function_">createFiberFromElement</span>()
<span class="hljs-title function_">createFiberFromFragment</span>()
<span class="hljs-title function_">createFiberFromText</span>()
</code></pre>
<p>jsx 代码 =&gt; ReactElement =&gt; FiberRootNode/FiberNode</p>
<h3 id="current--workinprogress">current &amp; workInProgress</h3>
<!-- prettier-ignore-start -->
<table>
<thead>
<tr>
<th></th>
<th>current</th>
<th>workInProgress</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>第一次生成的 FiberNode 组成的树和每次更新后生成的树</td>
<td>Fiber 在工作中生成的树</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>可以影响未来的状态和刷新屏幕</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>fiber 的所有工作都是从此树开始</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>由 class 组件的 render 方法返回的或方法组件返回的 ReactElement 创建的</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>完成工作后此树被赋于 current</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>处理所有组件的进程、刷新屏幕。</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>每个节点的 alternate 指向另一棵树（current/workInProgress）上对应的节点</td>
<td></td>
</tr>
<tr>
<td></td>
<td>第一次生成的 fiber tree</td>
<td>第二次生成的</td>
<td></td>
</tr>
<tr>
<td></td>
<td>与真实显示相同</td>
<td>可不同</td>
<td></td>
</tr>
<tr>
<td></td>
<td>当前 dom 的 vdom 树</td>
<td>改变的状态需要更新的节点树。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>它是工作的终点</td>
<td>diff从此树开始执行</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>每个节点使用 render 方法创建新的 ReactElement。再由新的 ReactElement 生成 workInProgress</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>不为用户提供服务。是 react 内置的用于缓存的对象。</td>
<td></td>
</tr>
</tbody>
</table>
<!-- prettier-ignore-end -->
<p>副作用（side-effects）： 每次活动（如：改变 dom）和调用生命周期方法<br>
Fiber 的 Effecttag 属性是副作用函数<br>
副作用 tag<br>
Current 就是 fiberroot</p>
<p>FiberRootNode 下的第一个 FiberNode 是使用 FiberRootNode()创建的。</p>
<p>工作在 commit 阶段进行<br>
<strong>深度优先</strong></p>
<ol>
<li>当完成所有 workInProgress 树的工作后</li>
<li>开始同步更新 dom.</li>
<li>此树成为 current 树。</li>
</ol>
<p>react 只更新 dom</p>
<h3 id="fiber-如何工作">fiber 如何工作</h3>
<ul>
<li>state change</li>
<li>触发生命周期方法</li>
<li>dom 改变</li>
<li>生成时间表</li>
<li>可分割工作为多块</li>
<li>分高优、低优处理
<ul>
<li>高优 requestAnimationFrame() // 该方法是浏览器支持的处理异步任务的方法。</li>
<li>低优 requestIdleCallback()</li>
</ul>
</li>
</ul>
<pre><code>    a1
    |
    b1 -- b2 -- b3
          |
          c1
          |
          c2
</code></pre>
<p><a href="https://vimeo.com/302222454">https://vimeo.com/302222454</a></p>
<ol>
<li>从 beginWork() 开始</li>
<li>一直处于此步骤</li>
<li>到 completeWork() 结束</li>
</ol>
<h2 id="更新-dom-的二个阶段">更新 dom 的二个阶段</h2>
<p>也就是 react 内部更新 dom 的过程。</p>
<ul>
<li>render phase (processing)
<ul>
<li>异步</li>
<li>定义任务的优先级，工作可能停止（可以被打断）、丢弃。</li>
<li>开始的方法，如：beginWork() / completeWork()</li>
<li>此阶段处理 fiber。（diff在此执行）</li>
</ul>
</li>
<li>commit phase (committing)
<ul>
<li>同步</li>
<li>从 commitWork()开始</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>render phase</td>
<td>异步</td>
<td>操作 workInProgress/current，即diff</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>getDerivedStateFromProps</td>
<td>被反对的生命周期方法不列出来</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>shouldComponentUpdate</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>render</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit phase</td>
<td>同步</td>
<td>操作 dom</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>getSnapshotBeforeUpdate</td>
<td>执行side-effect</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>componentDidMount</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>componentDidUdate</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>componentWillUnmount</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>调用 setState/React.render 会把对应的 FiberNode 指定为需要更新的元素。</p>
<h3 id="render-phase">render phase</h3>
<p>使用 effectTag 标记该节点应该如何更新。更新dom的工作在 commit 阶段做。<br>
此阶段不能执行 side-effect
从根节点开始，然后深度优先，跳过不需要更新的节点 FiberNode，标记出需要更新的节点 FiberNode。</p>
<ul>
<li>nextUnitOfWork</li>
<li>performUnitOfWork 参数是 workInProgress</li>
<li>beginWork // 返回下一个子节点或 null</li>
<li>completeUnitOfWork //</li>
<li>completeWork</li>
</ul>
<p>按照 FiberNode 形成的二叉树，深度优先。</p>
<h3 id="commit-phase">commit phase</h3>
<p>从 completeWork 开始。<br>
主要在 commitRoot 方法中<br>
因为要改变视图，所以必须是同步。<br>
当调用<code>finishedWork</code>时更新视图。</p>
<ul>
<li>标记了 Snapshot 的 fiberNode 会执行 getSnapshotBeforeUpdate 方法</li>
<li>标记了 Deletion 的 fiberNode 会执行 componentWillUnmount 方法</li>
<li>执行所有节点的插入、更新、删除操作 commitAllHostEffects。此步骤完成了从 current 到视图的工作。</li>
<li>设置新的 current</li>
<li>标记了 Placement 的 fiberNode 会执行 componentDidMount 方法</li>
<li>标记了 Update 的 fiberNode 会执行 componentDidUpdate 方法</li>
</ul>
<h2 id="diff">diff</h2>
<h3 id="diff-策略">diff 策略</h3>
<ol>
<li>忽略节点跨层级移动</li>
<li>相同类型<code>type</code>的组件产生的 dom 结构相似。反之不相似。</li>
<li>同层级组件之间使用 key 做惟一值。</li>
</ol>
<h3 id="同级之间的-diff">同级之间的 diff</h3>
<h4 id="复用节点">复用节点</h4>
<ol>
<li>在新节点列表中，从头开始取出一个节点 N。</li>
<li>在旧节点列表中，取出相同 key 的节点 N'.</li>
<li>设置 lastIndex = 0;此值表示该值前的已经已经排好序了。</li>
<li>若 N'.index &lt; lastIndex，则不移动。否则移动 N'到 lastIndex.再更新 N'.index = lastIndex</li>
<li>lastIndex++.</li>
<li>直到完成所有新节点列表。</li>
</ol>
<h4 id="增减节点">增、减节点</h4>
<pre><code>在新节点列表中，从头开始取出一个节点N.
在旧节点列表中，若能取出相同key的节点N'.----------------------------------
  |                                                                |
  Y                                                                N
  |                                                                |
  V                                                                V
设置lastIndex = 0;此值表示该值前的已经已经排好序了。               lastIndex++
  |                                                                |
  |                                                                |
  |                                                                |
  V                                                                |
若N'.index &lt; lastIndex，则不移动。否则移动N'到lastIndex.  &lt;-------------
lastIndex++.
遍历完新节点列表。再遍历旧节点列表，删除在新节点列表中不存在的节点。
</code></pre>
<h4 id="不足">不足</h4>
<p>当最后一个节点移到第一个节点时，react 会把非最后一个节点依次移到后面。也就是会移到 n-1 次。<br>
开发时不要这么做。</p>
<h4 id="自己实现一个同级-diff-方法">自己实现一个同级 diff 方法</h4>
<pre><code class="language-js"><span class="hljs-comment">// 待测试</span>
<span class="hljs-keyword">let</span> oldChain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleChain</span>()
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   value: &#x27;a&#x27;</span>
<span class="hljs-comment">//   next</span>
<span class="hljs-comment">//   position</span>
<span class="hljs-comment">// }</span>
oldChain.<span class="hljs-title function_">appen</span>(<span class="hljs-string">&#x27;a&#x27;</span>)
oldChain.<span class="hljs-title function_">appen</span>(<span class="hljs-string">&#x27;b&#x27;</span>)
oldChain.<span class="hljs-title function_">appen</span>(<span class="hljs-string">&#x27;c&#x27;</span>)
oldChain.<span class="hljs-title function_">appen</span>(<span class="hljs-string">&#x27;d&#x27;</span>)
<span class="hljs-comment">// a -&gt; b -&gt; c -&gt; d</span>
<span class="hljs-keyword">let</span> newChain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleChain</span>()
newChain.<span class="hljs-title function_">appen</span>(<span class="hljs-string">&#x27;b&#x27;</span>)
newChain.<span class="hljs-title function_">appen</span>(<span class="hljs-string">&#x27;e&#x27;</span>)
newChain.<span class="hljs-title function_">appen</span>(<span class="hljs-string">&#x27;c&#x27;</span>)
newChain.<span class="hljs-title function_">appen</span>(<span class="hljs-string">&#x27;a&#x27;</span>)
<span class="hljs-comment">// b -&gt; e -&gt; c -&gt; a</span>
<span class="hljs-keyword">let</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">newChain, oldChain</span>) =&gt; {
  <span class="hljs-comment">// 遍历新节点列表</span>
  <span class="hljs-keyword">let</span> newChainCur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">newChain</span>.<span class="hljs-property">head</span>
  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// 其实newChainCur.position也可以使用</span>
  <span class="hljs-keyword">while</span> (newChainCur) {
    <span class="hljs-keyword">let</span> oldChainCur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldChain</span>.<span class="hljs-property">head</span>
    <span class="hljs-keyword">while</span> (oldChainCur) {
      <span class="hljs-keyword">if</span> (oldChainCur.<span class="hljs-property">value</span> === newChainCur.<span class="hljs-property">value</span>) {
        <span class="hljs-keyword">break</span>
      }
      oldChainCur = oldChainCur.<span class="hljs-property">next</span>
    }
    <span class="hljs-comment">// 是否找到</span>
    <span class="hljs-keyword">if</span> (oldChainCur) {
      oldChain.<span class="hljs-title function_">removeAt</span>(oldChainCur.<span class="hljs-property">position</span>)
      oldChain.<span class="hljs-title function_">insert</span>(oldChainCur, lastIndex)
    } <span class="hljs-keyword">else</span> {
      oldChain.<span class="hljs-title function_">insert</span>(newChainCur.<span class="hljs-property">value</span>, lastIndex)
    }
    lastIndex++
    newChainCur = newChainCur.<span class="hljs-property">next</span>
  }
  <span class="hljs-comment">// 删除节点</span>
  <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">newChain</span>.<span class="hljs-property">length</span>
  <span class="hljs-keyword">return</span> oldChain.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, index)
}
</code></pre>
<h2 id="自己理出的过程">自己理出的过程</h2>
<p>创建组件时</p>
<pre><code class="language-js"><span class="hljs-title function_">createRoot</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 经过若干验证参数</span>
    <span class="hljs-keyword">var</span> root = <span class="hljs-title function_">createContainer</span>(container, <span class="hljs-title class_">ConcurrentRoot</span>, <span class="hljs-literal">null</span>, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberRoot</span>(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
                            <span class="hljs-keyword">let</span> root = <span class="hljs-title class_">FiberRootNode</span>(...)
                            <span class="hljs-keyword">var</span> uninitializedFiber = <span class="hljs-title function_">createHostRootFiber</span>(tag, isStrictMode); <span class="hljs-comment">// 返回FiberNode对象</span>
                                                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiber</span>(...)
                                                            <span class="hljs-keyword">return</span> <span class="hljs-title class_">FiberNode</span>(...)
                            root.<span class="hljs-property">current</span> = uninitializedFiber;
                            uninitializedFiber.<span class="hljs-property">stateNode</span> = root;
                            <span class="hljs-title function_">initializeUpdateQueue</span>(uninitializedFiber)
                                fiber.<span class="hljs-property">updateQueue</span> = {
                                    <span class="hljs-attr">baseState</span>: fiber.<span class="hljs-property">memoizedState</span>,
                                    <span class="hljs-attr">firstBaseUpdate</span>: <span class="hljs-literal">null</span>,
                                    <span class="hljs-attr">lastBaseUpdate</span>: <span class="hljs-literal">null</span>,
                                    <span class="hljs-attr">shared</span>: {
                                    <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
                                    <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">NoLanes</span>,
                                    <span class="hljs-attr">hiddenCallbacks</span>: <span class="hljs-literal">null</span>
                                    },
                                    <span class="hljs-attr">callbacks</span>: <span class="hljs-literal">null</span>
                                };
                            <span class="hljs-keyword">return</span>
                            root;
    <span class="hljs-title function_">markContainerAsRoot</span>(root.<span class="hljs-property">current</span>, container); <span class="hljs-comment">// 为了验证参数，在这里做标记</span>
    <span class="hljs-keyword">var</span> rootContainerElement = container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span> ? container.<span class="hljs-property">parentNode</span> : container; <span class="hljs-comment">// COMMENT_NODE 是注释节点的码值 8</span>
    <span class="hljs-comment">// rootContainerElement      dom</span>
    <span class="hljs-title function_">listenToAllSupportedEvents</span>(rootContainerElement);
        <span class="hljs-comment">// 它里面调用的方法太多了。</span>
        <span class="hljs-comment">// listenToNativeEvent</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactDOMRoot</span>(root);
                <span class="hljs-keyword">function</span> <span class="hljs-title function_">ReactDOMRoot</span>(<span class="hljs-params">internalRoot</span>) {
                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span> = internalRoot;
                }
                <span class="hljs-title class_">ReactDOMRoot</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-function">() =&gt;</span> {
                    <span class="hljs-keyword">var</span> root = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span>;
                    <span class="hljs-title function_">updateContainer</span>(children, root, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
                }
                <span class="hljs-title class_">ReactDOMRoot</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">unmount</span> = <span class="hljs-function">() =&gt;</span> {
                    <span class="hljs-keyword">var</span> root = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span>;
                }
}
</code></pre>
<p>更新组件时</p>
<pre><code>ReactDOMRoot
</code></pre>
<h2 id="常用对象">常用对象</h2>
<pre><code class="language-js"><span class="hljs-title class_">ReactElement</span>
{
  <span class="hljs-string">&quot;$$typeof&quot;</span>: <span class="hljs-title class_">Symbol</span>(react.<span class="hljs-property">element</span>) <span class="hljs-comment">// 惟一标记</span>
  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-comment">// html标签 | 构造函数 | class组件名</span>
  <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 惟一键</span>
  <span class="hljs-string">&quot;ref&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;props&quot;</span>: {
    <span class="hljs-string">&quot;children&quot;</span>: <span class="hljs-string">&quot;title&quot;</span>
  },
  <span class="hljs-string">&quot;_owner&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;_store&quot;</span>: {},
  <span class="hljs-string">&quot;_self&quot;</span>: <span class="hljs-literal">null</span>
  <span class="hljs-string">&quot;_source&quot;</span>: <span class="hljs-literal">null</span>
}

<span class="hljs-title class_">FiberNode</span> 也有人叫 <span class="hljs-title class_">Fiber</span>
总是与组件一对一。
{
  <span class="hljs-string">&quot;tag&quot;</span>: <span class="hljs-number">5</span>,
  <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-literal">null</span>,          <span class="hljs-comment">// key 兄弟间惟一</span>
  <span class="hljs-string">&quot;elementType&quot;</span>: <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 构造函数 | html标签 | class组件名</span>
  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-literal">null</span>,         <span class="hljs-comment">// 组件的类型。与elementType相同值。createFiberFromTypeAndProps</span>
            <span class="hljs-comment">// 一共有 0-24。 有几个重要的。如下</span>
            <span class="hljs-comment">// FunctionComponent 0</span>
            <span class="hljs-comment">// ClassComponent 1</span>
            <span class="hljs-comment">// HostComponent 5 div/p/...</span>
            <span class="hljs-comment">// Fragment 7</span>
            <span class="hljs-comment">// ContextConsumer 9</span>
            <span class="hljs-comment">// ContextProvider 10</span>
  <span class="hljs-string">&quot;stateNode&quot;</span>: <span class="hljs-literal">null</span>,    <span class="hljs-comment">// dom | FiberRootNode 的引用</span>
  <span class="hljs-string">&quot;return&quot;</span>: <span class="hljs-literal">null</span>,       <span class="hljs-comment">// 父 FiberNode</span>
  <span class="hljs-string">&quot;child&quot;</span>: <span class="hljs-literal">null</span>,        <span class="hljs-comment">// 第一个子元素 FiberNode</span>
  <span class="hljs-string">&quot;sibling&quot;</span>: <span class="hljs-literal">null</span>,      <span class="hljs-comment">// 后面的第一个兄弟元素 FiberNode</span>
  <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-number">0</span>,           <span class="hljs-comment">// 兄弟间下标。用于同级节点移动位置时。</span>
  <span class="hljs-string">&quot;ref&quot;</span>: <span class="hljs-literal">null</span>,          <span class="hljs-comment">// ref</span>
  <span class="hljs-string">&quot;pendingProps&quot;</span>: {     <span class="hljs-comment">// 这是被修改后的props。应该传入子组件或dom</span>
    <span class="hljs-string">&quot;children&quot;</span>: {
      <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;h1&quot;</span>,
      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-string">&quot;ref&quot;</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-string">&quot;props&quot;</span>: {
        <span class="hljs-string">&quot;children&quot;</span>: <span class="hljs-string">&quot;title&quot;</span>
      },
      <span class="hljs-string">&quot;_owner&quot;</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-string">&quot;_store&quot;</span>: {}
    }
  },
  <span class="hljs-string">&quot;memoizedProps&quot;</span>: <span class="hljs-literal">null</span>,    <span class="hljs-comment">// 输出更新后节点需要使用的props</span>
  <span class="hljs-string">&quot;updateQueue&quot;</span>: <span class="hljs-literal">null</span>,      <span class="hljs-comment">// 更新队列。详见下文。链表结构。</span>
  <span class="hljs-string">&quot;memoizedState&quot;</span>: <span class="hljs-literal">null</span>,    <span class="hljs-comment">// 上次渲染组件是使用的状态。初始化FiberNode节点时会赋初始值。</span>
                            <span class="hljs-comment">// 输出更新后节点需要使用的state</span>
                {           <span class="hljs-comment">// 这是一个hook对象</span>
                  baseState,
                  next,         <span class="hljs-comment">// 指向下一次useState对应的hook对象</span>
                                <span class="hljs-comment">// 又是链表</span>
                  baseUpdate,
                  queue,
                  memoizedState, <span class="hljs-comment">// useState返回的结果</span>
                }
  <span class="hljs-string">&quot;dependencies&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;mode&quot;</span>: <span class="hljs-number">3</span>,
  <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-number">0</span>,               <span class="hljs-comment">// 该节点的side-effect。功能同原来的effectTag</span>
  <span class="hljs-string">&quot;subtreeFlags&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;deletions&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;lanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;childLanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;alternate&quot;</span>: <span class="hljs-literal">null</span>,        <span class="hljs-comment">// 指向在另一棵树上对应的节点</span>
  <span class="hljs-string">&quot;actualDuration&quot;</span>: <span class="hljs-number">0</span>,      <span class="hljs-comment">//</span>
  <span class="hljs-string">&quot;actualStartTime&quot;</span>: -<span class="hljs-number">1</span>,    <span class="hljs-comment">// 好像是开始更新的时刻，相对于根组件被创建的时间。</span>
  <span class="hljs-string">&quot;selfBaseDuration&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;treeBaseDuration&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;_debugSource&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;_debugOwner&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;_debugNeedsRemount&quot;</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-string">&quot;_debugHookTypes&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-comment">// effectTag: xxxxx              // 该节点的side-effect 副作用</span>
}

<span class="hljs-title class_">FiberRootNode</span>
{
  <span class="hljs-string">&quot;tag&quot;</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">&quot;containerInfo&quot;</span>: {},      <span class="hljs-comment">// 就是createRoot的第一个参数。dom类型。</span>
  <span class="hljs-string">&quot;pendingChildren&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;current&quot;</span>: <span class="hljs-literal">null</span>,          <span class="hljs-comment">// FiberNode。它是在createRoot方法中被设置的。</span>
  <span class="hljs-string">&quot;pingCache&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;finishedWork&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;timeoutHandle&quot;</span>: -<span class="hljs-number">1</span>,
  <span class="hljs-string">&quot;context&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;pendingContext&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;callbackNode&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;callbackPriority&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;eventTimes&quot;</span>: [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ],
  <span class="hljs-string">&quot;expirationTimes&quot;</span>: [ -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> ],
  <span class="hljs-string">&quot;pendingLanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;suspendedLanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;pingedLanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;expiredLanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;mutableReadLanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;finishedLanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;entangledLanes&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;entanglements&quot;</span>: [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ],
  <span class="hljs-string">&quot;identifierPrefix&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,
  <span class="hljs-string">&quot;mutableSourceEagerHydrationData&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;effectDuration&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;passiveEffectDuration&quot;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&quot;memoizedUpdaters&quot;</span>: {},
  <span class="hljs-string">&quot;pendingUpdatersLaneMap&quot;</span>: [ {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} ],
  <span class="hljs-string">&quot;_debugRootType&quot;</span>: <span class="hljs-string">&quot;createRoot()&quot;</span>
}

update = {
  <span class="hljs-attr">eventTime</span>: eventTime,
  <span class="hljs-attr">lane</span>: lane,
  <span class="hljs-attr">tag</span>: <span class="hljs-title class_">UpdateState</span>,
  <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
};

current 指向 <span class="hljs-title class_">FiberRootNode</span>

<span class="hljs-title class_">ReactWorkTags</span>:
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">FunctionComponent</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ClassComponent</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IndeterminateComponent</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// Before we know whether it is function or class</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostRoot</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// Root of a host tree. Could be nested inside another node.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostPortal</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// A subtree. Could be an entry point to a different renderer.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostComponent</span> = <span class="hljs-number">5</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostText</span> = <span class="hljs-number">6</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Fragment</span> = <span class="hljs-number">7</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Mode</span> = <span class="hljs-number">8</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextConsumer</span> = <span class="hljs-number">9</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContextProvider</span> = <span class="hljs-number">10</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ForwardRef</span> = <span class="hljs-number">11</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Profiler</span> = <span class="hljs-number">12</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SuspenseComponent</span> = <span class="hljs-number">13</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComponent</span> = <span class="hljs-number">14</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SimpleMemoComponent</span> = <span class="hljs-number">15</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LazyComponent</span> = <span class="hljs-number">16</span>;
<span class="hljs-comment">// 还17 、 18 不在这里</span>

flags 表示effect的编码
<span class="hljs-comment">// 使用二进制很方便判断值，以后我也可以使用它。</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoFlags</span> = <span class="hljs-comment">/*                      */</span> <span class="hljs-number">0b00000000000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">PerformedWork</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b00000000000000000000000001</span>;
<span class="hljs-comment">// You can change the rest (and add more).</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Placement</span> = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b00000000000000000000000010</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Update</span> = <span class="hljs-comment">/*                       */</span> <span class="hljs-number">0b00000000000000000000000100</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ChildDeletion</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b00000000000000000000001000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ContentReset</span> = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b00000000000000000000010000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b00000000000000000000100000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">DidCapture</span> = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b00000000000000000001000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ForceClientRender</span> = <span class="hljs-comment">/*            */</span> <span class="hljs-number">0b00000000000000000010000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Ref</span> = <span class="hljs-comment">/*                          */</span> <span class="hljs-number">0b00000000000000000100000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Snapshot</span> = <span class="hljs-comment">/*                     */</span> <span class="hljs-number">0b00000000000000001000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Passive</span> = <span class="hljs-comment">/*                      */</span> <span class="hljs-number">0b00000000000000010000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Hydrating</span> = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b00000000000000100000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Visibility</span> = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b00000000000001000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">StoreConsistency</span> = <span class="hljs-comment">/*             */</span> <span class="hljs-number">0b00000000000010000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LifecycleEffectMask</span> =
  <span class="hljs-title class_">Passive</span> | <span class="hljs-title class_">Update</span> | <span class="hljs-title class_">Callback</span> | <span class="hljs-title class_">Ref</span> | <span class="hljs-title class_">Snapshot</span> | <span class="hljs-title class_">StoreConsistency</span>;
<span class="hljs-comment">// Union of all commit flags (flags with the lifetime of a particular commit)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HostEffectMask</span> = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b00000000000011111111111111</span>;
<span class="hljs-comment">// These are not really side effects, but we still reuse this field.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Incomplete</span> = <span class="hljs-comment">/*                   */</span> <span class="hljs-number">0b00000000000100000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ShouldCapture</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b00000000001000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ForceUpdateForLegacySuspense</span> = <span class="hljs-comment">/* */</span> <span class="hljs-number">0b00000000010000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">DidPropagateContext</span> = <span class="hljs-comment">/*          */</span> <span class="hljs-number">0b00000000100000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NeedsPropagation</span> = <span class="hljs-comment">/*             */</span> <span class="hljs-number">0b00000001000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Forked</span> = <span class="hljs-comment">/*                       */</span> <span class="hljs-number">0b00000010000000000000000000</span>;
<span class="hljs-comment">// Static tags describe aspects of a fiber that are not specific to a render,</span>
<span class="hljs-comment">// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).</span>
<span class="hljs-comment">// This enables us to defer more work in the unmount case,</span>
<span class="hljs-comment">// since we can defer traversing the tree during layout to look for Passive effects,</span>
<span class="hljs-comment">// and instead rely on the static flag as a signal that there may be cleanup work.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">RefStatic</span> = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b00000100000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LayoutStatic</span> = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b00001000000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">PassiveStatic</span> = <span class="hljs-comment">/*                */</span> <span class="hljs-number">0b00010000000000000000000000</span>;
<span class="hljs-comment">// Flag used to identify newly inserted fibers. It isn&#x27;t reset after commit unlike `Placement`.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">PlacementDEV</span> = <span class="hljs-comment">/*                 */</span> <span class="hljs-number">0b00100000000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MountLayoutDev</span> = <span class="hljs-comment">/*               */</span> <span class="hljs-number">0b01000000000000000000000000</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MountPassiveDev</span> = <span class="hljs-comment">/*              */</span> <span class="hljs-number">0b10000000000000000000000000</span>;
</code></pre>
<h2 id="使用本地-reactreact-dom-调试源码"><a href="/framework/react/useLocalReact.html">使用本地 react/react-dom 调试源码</a></h2>
<h2 id="hooks-的工作原理">hooks 的工作原理</h2>
<p>更新是如何发生：</p>
<p>调用 useState，内部通过 setState 修改状态后，调用 scheduleUpdate 方法，从根节点执行完整的 dom-diff 比较，进行组件的更新。</p>
<p>为什么不能在条件语句或循环中使用 Hook？</p>
<p>从实现来看，每次 hook 的执行，都是从索引为 0 即第一个 hook 开始执行。也是依靠索引记录当前操作的 Hook，假如使用条件语句或者循环，那么 hook 执行的顺序可能与我们在数组中存放的顺序不一致，就会乱掉。因此不能在条件语句或循环中使用 Hook。
我看源码得到的结果是：各个状态组件一个链表，每个状态是一个节点。最后一个节点是当前状态。</p>
<p>方法组件中使用<code>memoizedState</code>属性保存 state。
<code>FiberNode.memoizedState</code><br>
一个组件的多个 useState()使用链表的方式串起来。<br>
在方法组件更新时会执行完整的方法体。所以会依次执行 useState()。若把 useState()写在非顶级，则有可能不会执行全部 useState()，这样会引发<code>memoizedState</code>链出错。</p>
<p>hooks 的状态数据是存放在对应的函数组件的 fiber.memoizedState；<br>
一个函数组件上如果有多个 hook，他们会通过声明的顺序以链表的结构存储；</p>
<h1 id="本地笔记">本地笔记</h1>
<h2 id="inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</h2>
<h3 id="side-effects">side-effects</h3>
<ul>
<li><strong>操作 dom 的方法</strong></li>
<li><strong>生命周期方法</strong></li>
<li>……</li>
</ul>
<h3 id="effect-list">effect list</h3>
<p>根据 FiberNode 链表结构依次处理<br>
处理链表比处理树快。<br>
firstEffect 指向第一个节点。nextEffect 指向下一个节点。单向链表。</p>
<h3 id="root-of-the-fiber-tree">root of the fiber tree</h3>
<p>使用变量 container 指定根节点的容器。它是 dom 元素。<br>
current 指向 FiberRootNode<br>
根节点是 HostRoot<br>
FiberRootNode.stateNode 指向 HostRoot</p>
<h2 id="in-depth-explanation-of-state-and-props-update-in-react"><a href="https://indepth.dev/posts/1009/in-depth-explanation-of-state-and-props-update-in-react">In-depth explanation of state and props update in React</a></h2>
<h3 id="scheduling-updates">scheduling updates</h3>
<pre><code class="language-js">当组件需要更新时，也就是更新前。
fiber
{
    <span class="hljs-attr">effectTag</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">elementType</span>: <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickCounter</span>,
    <span class="hljs-attr">firstEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">memoizedState</span>: {<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>},
    <span class="hljs-attr">type</span>: <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickCounter</span>,
    <span class="hljs-attr">stateNode</span>: {
        <span class="hljs-attr">state</span>: {<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>}
    },
    <span class="hljs-attr">updateQueue</span>: {
        <span class="hljs-attr">baseState</span>: {<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>},
        <span class="hljs-attr">firstUpdate</span>: {
            <span class="hljs-attr">next</span>: {
                <span class="hljs-attr">payload</span>: <span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> {…}
            }
        },
        ...
    }
}
fiber更新后
{
    <span class="hljs-attr">effectTag</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">// 源码中使用二进制表示   100</span>
    <span class="hljs-comment">// 因这里标记为 Update 所以会执行此节点的componentDidUpdate生命周期方法</span>
    <span class="hljs-attr">elementType</span>: <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickCounter</span>,
    <span class="hljs-attr">firstEffect</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">memoizedState</span>: {<span class="hljs-attr">count</span>: <span class="hljs-number">1</span>},
    <span class="hljs-attr">type</span>: <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickCounter</span>,
    <span class="hljs-attr">stateNode</span>: {
        <span class="hljs-attr">state</span>: {<span class="hljs-attr">count</span>: <span class="hljs-number">1</span>}
    },
    <span class="hljs-attr">updateQueue</span>: {
        <span class="hljs-attr">baseState</span>: {<span class="hljs-attr">count</span>: <span class="hljs-number">1</span>},
        <span class="hljs-attr">firstUpdate</span>: <span class="hljs-literal">null</span>,
        ...
    }
}

另一个示例：
fiber更新前
{
    <span class="hljs-attr">stateNode</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLSpanElement</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;span&quot;</span>,
    <span class="hljs-attr">effectTag</span>: <span class="hljs-number">0</span>
    <span class="hljs-attr">updateQueue</span>: <span class="hljs-literal">null</span>
    ...
}
fiber更新后
{
    <span class="hljs-attr">stateNode</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLSpanElement</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;span&quot;</span>,
    <span class="hljs-attr">effectTag</span>: <span class="hljs-number">4</span>,
    <span class="hljs-attr">updateQueue</span>: [<span class="hljs-string">&quot;children&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>],
    ...
}
</code></pre>
<p>全局变量 nextUnitOfWork 表示在 workInProgress 树上下一个需要工作的 FiberNode。<br>
若此变量为空，则完成所有工作。</p>
<ol>
<li>当执行 setState 时，会在该组件对应的 FiberNode 的 uqdateQueue 中添加工作。</li>
<li>进入 render 阶段。</li>
<li>调用 renderRoot 方法。从 HostRoot(它是一个 FiberNode)开始，会跳过完成工作的 FiberNode，直到未完成工作的 FiberNode.</li>
<li>调用 createWorkInProgress 方法，根据 ReactElement 创建 workInProgress.（可能没有此步）</li>
<li>调用 beginWork 方法。根据 type 分别调用相应的方法。如<code>updateClassComponent() 、 updateFunctionComponent()</code>。会创建并挂载组件的实例或更新实例。</li>
<li>调用 updateClassInstance 方法，去更新组件。然后依次调用：
<ol>
<li>UNSAFE_componentWillReceiveProps() deprecated</li>
<li>执行 updateQueue 里的方法。会得到新的 state</li>
<li>使用新 state 调用 getDerivedStateFromProps 方法。</li>
<li>执行 shouldComponentUpdate 方法。若返回 false，则跳过整个渲染处理（包括该组件的 render 方法及其子组件的 render 方法）。否则执行更新。</li>
<li>调用 UNSAFE_componentWillUpdate（） deprecated</li>
<li>添加一个触发 componentDidUpdate()的 effect 在 render 阶段中是添加。实际执行在 commit 阶段。</li>
</ol>
</li>
<li>更新实例的 state/props。 为执行 render 方法做准备。</li>
<li>执行 finishClassComponent 方法。react 会调用 render 方法，得到新组件实例，再执行 diffing 运算。
<ol>
<li>执行 createWorkInProgress 方法，根据新的 ReactElement 对象得到替补节点（它是 FiberNode）</li>
<li>在 FiberNode.pendingProps 的数据会作用于子组件。</li>
<li>子组件中使用 memoizedProps</li>
<li>为 nextUnitOfWork 赋值。 其中的处理逻辑同上。</li>
</ol>
</li>
<li>调用 updateHostComponent 方法，结束。</li>
</ol>
<h3 id="commit-phase">commit phase</h3>
<ol>
<li>从调用 completeRoot 方法开始。</li>
<li>设置 FiberRootNode.finishedWork 为 null</li>
<li>调用 commitBeforeMutationLifeCycles 方法。若标记 snapshot 则执行 getSnapshotBeforeUpdate()</li>
<li>调用 commitAllHostEffects 方法。</li>
<li>调用 updateDOMProperties 方法。设置了 dom 的属性。</li>
<li>调用 finishedWork 方法。把 workInProgress 赋值给 current</li>
<li>调用 commitAllLifecycles 方法。调用所有的生命周期方法。
<ol>
<li>调用 commitLifeCycles 方法。会更新 refs 引入。 componentDidMount 会只执行一次。</li>
</ol>
</li>
</ol>
<h3 id="处理-fibernode-的更新">处理 FiberNode 的更新</h3>
<p>全局变量保留了 workInProgress 中需要工作的 FiberNode。用它表明是否完成工作。<br>
使用<code>renderRoot()</code>从<code>HostRoot</code>FiberNode 开始工作（这是 render 阶段）。<br>
使用<code>createWorkInProgress()</code>创建一个该 FiberNode 的替补节点。更新操作都在这个替补节点上工作。</p>
<h3 id="the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree"><a href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7">The how and why on React’s usage of linked list in Fiber to walk the component’s tree</a></h3>
<h1 id="参考文档">参考文档</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=7YhdqIR2Yzo&amp;t=422s">youtobe philip fabinek react</a></li>
<li><a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e">https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e</a></li>
<li><a href="https://indepth.dev/posts/1009/in-depth-explanation-of-state-and-props-update-in-react">https://indepth.dev/posts/1009/in-depth-explanation-of-state-and-props-update-in-react</a></li>
<li><a href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7">https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7</a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
<h1 id="开拓">开拓</h1>
<h2 id="babel-开创了前端中把一种功能换一种写法的思想如">babel 开创了前端中把一种功能换一种写法的思想。如:</h2>
<pre><code>&lt;span id=&quot;#id&quot;&gt;string&lt;/span&gt;
=&gt;
React.createElement('span', {id: '#id'}, string)
</code></pre>
<h2 id="使用配置文件控制是否使用新代码同时保持了新代码与老代码在项目中优点是迭代平滑">使用配置文件控制是否使用新代码。同时保持了新代码与老代码在项目中。优点是迭代平滑。</h2>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>